import json

dataset = []

safe_templates = [
    r"""CLASS lhc_calc DEFINITION INHERITING FROM cl_abap_behavior_handler.
  PRIVATE SECTION.

    METHODS delete_all FOR MODIFY
      IMPORTING keys FOR ACTION calc~delete_all.

    METHODS get_global_authorizations FOR GLOBAL AUTHORIZATION
      IMPORTING REQUEST requested_authorizations FOR calc RESULT result.

    METHODS validate FOR VALIDATE ON SAVE
      IMPORTING keys FOR calc~validate.

    METHODS det_modify FOR DETERMINE ON MODIFY
      IMPORTING keys FOR calc~det_modify.

    METHODS calculation FOR MODIFY
      IMPORTING keys FOR ACTION calc~calculation.

ENDCLASS.""",

    r"""CLASS lhc_calc IMPLEMENTATION.

  METHOD delete_all.
    "Purpose: The method deletes all persisted database entries.

    DATA all_keys TYPE TABLE FOR DELETE zdemo_abap_rap_draft_m.

    SELECT id FROM zdemo_abap_tabca INTO CORRESPONDING FIELDS OF TABLE @all_keys.

    READ ENTITIES OF zdemo_abap_rap_draft_m IN LOCAL MODE
    ENTITY calc
      ALL FIELDS WITH CORRESPONDING #( all_keys )
        RESULT DATA(lt_del).

    IF lt_del IS NOT INITIAL.

      MODIFY ENTITY IN LOCAL MODE zdemo_abap_rap_draft_m
        DELETE FROM CORRESPONDING #( lt_del ).

      APPEND VALUE #( %msg = new_message_with_text( text     = 'All persisted calculations were deleted.'
                                                    severity = if_abap_behv_message=>severity-information )
                                ) TO reported-calc.

    ELSE.
      APPEND VALUE #( %msg = new_message_with_text( text     = 'No persisted calculations available.'
                                                    severity = if_abap_behv_message=>severity-information )
                                ) TO reported-calc.

    ENDIF.

  ENDMETHOD.

  METHOD get_global_authorizations.
    "Purposely kept without implementation.
  ENDMETHOD.

  METHOD validate.
    "Retrieving instances based on requested keys
    READ ENTITIES OF zdemo_abap_rap_draft_m IN LOCAL MODE
     ENTITY calc
     ALL FIELDS
     WITH CORRESPONDING #( keys )
     RESULT DATA(result_validate)
     FAILED DATA(f).

    CHECK result_validate IS NOT INITIAL.

    "Various calculation errors are handled.
    LOOP AT result_validate ASSIGNING FIELD-SYMBOL(<fs>).

      APPEND VALUE #(  %tky        = <fs>-%tky
                       %state_area = 'VALIDATE_CALCULATION'
                    ) TO reported-calc.

      IF <fs>-calc_result = `Wrong operator`.
        APPEND VALUE #( %tky = <fs>-%tky ) TO failed-calc.

        APPEND VALUE #( %tky        = <fs>-%tky
                        %state_area = 'VALIDATE_CALCULATION'
                         %msg       = new_message_with_text( text     = 'Only + - * / P allowed as operators.'
                                                             severity = if_abap_behv_message=>severity-error )
                       "%element highlights the input field
                        %element-arithm_op = if_abap_behv=>mk-on
                      ) TO reported-calc.

      ELSEIF <fs>-calc_result = `Division by 0`.
        APPEND VALUE #( %tky = <fs>-%tky ) TO failed-calc.

        APPEND VALUE #( %tky        = <fs>-%tky
                        %state_area = 'VALIDATE_CALCULATION'
                        %msg        = new_message_with_text( text     = 'Zero division not possible.'
                                                             severity = if_abap_behv_message=>severity-error )
                        %element-arithm_op = if_abap_behv=>mk-on
                        %element-num2 = if_abap_behv=>mk-on
                      ) TO reported-calc.

      ELSEIF <fs>-calc_result = `Overflow error`.
        APPEND VALUE #( %tky = <fs>-%tky ) TO failed-calc.

        APPEND VALUE #( %tky        = <fs>-%tky
                        %state_area = 'VALIDATE_CALCULATION'
                         %msg       = new_message_with_text( text     = 'Check the numbers. Try smaller ones.'
                                                             severity = if_abap_behv_message=>severity-error )
                       %element-num1 = if_abap_behv=>mk-on
                       %element-num2 = if_abap_behv=>mk-on
                      ) TO reported-calc.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.

  METHOD det_modify.
    MODIFY ENTITIES OF zdemo_abap_rap_draft_m IN LOCAL MODE
       ENTITY calc
         EXECUTE calculation
         FROM CORRESPONDING #( keys ).
  ENDMETHOD.

  METHOD calculation.
    READ ENTITIES OF zdemo_abap_rap_draft_m IN LOCAL MODE
          ENTITY calc
            FIELDS ( num1 num2 arithm_op ) WITH CORRESPONDING #( keys )
            RESULT DATA(lt_calc)
            FAILED DATA(f).

    LOOP AT lt_calc ASSIGNING FIELD-SYMBOL(<calc>).
      TRY.
          <calc>-calc_result = SWITCH #( <calc>-arithm_op
                                          WHEN `+` THEN <calc>-num1 + <calc>-num2
                                          WHEN `-` THEN <calc>-num1  -  <calc>-num2
                                          WHEN `*` THEN  <calc>-num1  * <calc>-num2
                                          WHEN `/` THEN <calc>-num1  /  <calc>-num2
                                          WHEN `P` THEN ipow( base = <calc>-num1 exp = <calc>-num2 )
                                          ELSE `Wrong operator` ).
          IF <calc>-calc_result CA `-`.
            <calc>-calc_result = shift_right( val = <calc>-calc_result circular = 1 ).
          ENDIF.

          REPLACE PCRE `\.0+\b` IN <calc>-calc_result WITH ``.

          IF <calc>-num1 = 0 AND <calc>-num2 = 0 AND <calc>-arithm_op = `/`.
            <calc>-calc_result = `Division by 0`.
          ENDIF.

        CATCH cx_sy_zerodivide.
          <calc>-calc_result = `Division by 0`.

        CATCH cx_sy_arithmetic_overflow.
          <calc>-calc_result = `Overflow error`.

      ENDTRY.
    ENDLOOP.

    MODIFY ENTITY IN LOCAL MODE zdemo_abap_rap_draft_m
            UPDATE FIELDS ( calc_result )
            WITH CORRESPONDING #( lt_calc ).
  ENDMETHOD.

ENDCLASS.""",

    r"""CLASS lsc_zdemo_abap_rap_draft_m DEFINITION INHERITING FROM cl_abap_behavior_saver.
  PROTECTED SECTION.
    METHODS adjust_numbers REDEFINITION.
ENDCLASS.""",

    r"""CLASS lsc_zdemo_abap_rap_draft_m IMPLEMENTATION.
  METHOD adjust_numbers.
    LOOP AT mapped-calc ASSIGNING FIELD-SYMBOL(<fs>).
      <fs>-%key-id = <fs>-%pid.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.""",
    r"""
    CLASS zbp_demo_abap_rap_ro_u DEFINITION PUBLIC ABSTRACT FINAL FOR BEHAVIOR OF zdemo_abap_rap_ro_u.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS ZBP_DEMO_ABAP_RAP_RO_U IMPLEMENTATION.
ENDCLASS.""",
    r"""CLASS lcl_buffer DEFINITION.
  PUBLIC SECTION.

    "Structure and internal table types for the internal table serving
    "as transactional buffers for the root and child entities
    TYPES: BEGIN OF gty_buffer,
             instance TYPE zdemo_abap_rap_ro_u,
             cid      TYPE string,
             changed  TYPE abap_bool,
             deleted  TYPE abap_bool,
           END OF gty_buffer.

    TYPES: BEGIN OF gty_buffer_child,
             instance   TYPE zdemo_abap_rap_ch_u,
             cid_ref    TYPE string,
             cid_target TYPE string,
             changed    TYPE abap_bool,
             deleted    TYPE abap_bool,
           END OF gty_buffer_child.

    TYPES gtt_buffer TYPE TABLE OF gty_buffer WITH EMPTY KEY.
    TYPES gtt_buffer_child TYPE TABLE OF gty_buffer_child WITH EMPTY KEY.
    "Structure and internal table types to include the keys for buffer preparation methods
    TYPES: BEGIN OF root_keys,
             key_field TYPE zdemo_abap_rap_ro_u-key_field,
           END OF root_keys,
           BEGIN OF child_keys,
             key_field TYPE zdemo_abap_rap_ch_u-key_field,
             key_ch    TYPE zdemo_abap_rap_ch_u-key_ch,
             full_key  TYPE abap_bool,
           END OF child_keys,
           tt_root_keys  TYPE TABLE OF root_keys WITH EMPTY KEY,
           tt_child_keys TYPE TABLE OF child_keys WITH EMPTY KEY.

    CLASS-DATA:
      "Internal tables serving as transactional buffers for the root and child entities
      root_buffer  TYPE STANDARD TABLE OF gty_buffer WITH EMPTY KEY,
      child_buffer TYPE STANDARD TABLE OF gty_buffer_child WITH EMPTY KEY.

    "Buffer preparation methods
    CLASS-METHODS: prep_root_buffer IMPORTING keys TYPE tt_root_keys,
      prep_child_buffer IMPORTING keys TYPE tt_child_keys.

ENDCLASS.""",
    r""" CLASS lcl_buffer IMPLEMENTATION.

  "Buffer preparation for the root entity based on the requested key values
  METHOD prep_root_buffer.

    LOOP AT keys ASSIGNING FIELD-SYMBOL(<buffer>).
      "Logic:
      "- Line with the specific key values exists in the buffer for the root entity
      "- If it is true: Do nothing, buffer is prepared for the specific instance.
      "- Note: If the line is marked as deleted, the buffer should not be filled anew with the data.
      IF line_exists( lcl_buffer=>root_buffer[ instance-key_field = <buffer>-key_field ] ).
        "Do nothing, buffer is prepared for the specific instance.
      ELSE.
        "Checking if entry exists in the database table of the root entity based on the key value
        SELECT SINGLE @abap_true
          FROM zdemo_abap_rapt1
          WHERE key_field = @<buffer>-key_field
          INTO @DATA(exists).

        IF exists = abap_true.
          "If entry exists, retrieve it based on the shared key value
          DATA line TYPE zdemo_abap_rap_ro_u.

          SELECT SINGLE * FROM zdemo_abap_rapt1
            WHERE key_field = @<buffer>-key_field
            INTO CORRESPONDING FIELDS OF @line.

          IF sy-subrc = 0.
            "Adding line to the root buffer
            APPEND VALUE #( instance = line ) TO lcl_buffer=>root_buffer.
          ENDIF.

        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  "Buffer preparation for the child entity based on the requested key values
  METHOD prep_child_buffer.

    LOOP AT keys ASSIGNING FIELD-SYMBOL(<buffer_ch>).

      "The full_key flag is in this example only relevant if a read operation is executed on the child entity directly
      "and all key values should be considered for the data retrieval from the database table.
      IF <buffer_ch>-full_key = abap_true.
        "Logic:
        "- Line with specific key values exists in the buffer for the child entity
        "- If it is true: Do nothing, buffer is prepared for the specific instance.
        IF line_exists( lcl_buffer=>child_buffer[ instance-key_field = <buffer_ch>-key_field
                                                  instance-key_ch    = <buffer_ch>-key_ch ] ).
          "Buffer is prepared for the instance.
        ELSE.
          "Checking if entry exists in the database table of the child entity based on the shared key value
          SELECT SINGLE @abap_true
           FROM zdemo_abap_rapt2
           WHERE key_field = @<buffer_ch>-key_field
             AND key_ch    = @<buffer_ch>-key_ch
           INTO @DATA(exists).

          "If entry exists, retrieve all entries based on the key values
          IF exists = abap_true.

            DATA line_ch TYPE zdemo_abap_rap_ch_u.
            SELECT SINGLE * FROM zdemo_abap_rapt2
            WHERE key_field = @<buffer_ch>-key_field
                AND key_ch    = @<buffer_ch>-key_ch
            INTO CORRESPONDING FIELDS OF @line_ch.

            IF sy-subrc = 0.
              "Adding line to the child buffer if no line exists with all key values
              APPEND VALUE #( instance = line_ch ) TO lcl_buffer=>child_buffer.
            ENDIF.

          ENDIF.
        ENDIF.

      ELSE.

        "Logic:
        "- Line with specific keys exists in the buffer for the root entity and is marked for deletion
        "- If all is true: Doing nothing, buffer is prepared for the specific instance.
        "- Else: Retrieving all lines from the database table of the child entity having the shared key
        IF line_exists( lcl_buffer=>root_buffer[ instance-key_field = <buffer_ch>-key_field ] )
        AND VALUE #( lcl_buffer=>root_buffer[ instance-key_field = <buffer_ch>-key_field ]-deleted OPTIONAL ) IS NOT INITIAL.
          "Buffer is prepared for the instance.
        ELSE.
          "Checking if entry exists in the database table of the child entity based on the shared key value
          SELECT SINGLE @abap_true
            FROM zdemo_abap_rapt2
            WHERE key_field = @<buffer_ch>-key_field
            INTO @DATA(exists_ch).

          "If entry exists, retrieve all entries based on the shared key value
          IF exists_ch = abap_true.

            DATA ch_tab TYPE TABLE OF zdemo_abap_rap_ch_u WITH EMPTY KEY.
            SELECT * FROM zdemo_abap_rapt2
            WHERE key_field = @<buffer_ch>-key_field
            INTO CORRESPONDING FIELDS OF TABLE @ch_tab.

            IF sy-subrc = 0.

              LOOP AT ch_tab ASSIGNING FIELD-SYMBOL(<ch>).
                "Adding line to the child buffer if no line exists with all key values
                IF NOT line_exists( lcl_buffer=>child_buffer[ instance-key_field = <ch>-key_field
                                                              instance-key_ch = <ch>-key_ch ] ).
                  APPEND VALUE #( instance = <ch> ) TO lcl_buffer=>child_buffer.
                ENDIF.
              ENDLOOP.
            ENDIF.

          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

ENDCLASS.""",
    r""" CLASS lhc_root DEFINITION INHERITING FROM cl_abap_behavior_handler.

  PRIVATE SECTION.

    METHODS get_global_authorizations FOR GLOBAL AUTHORIZATION
    IMPORTING REQUEST requested_authorizations FOR root RESULT result.

    METHODS create FOR MODIFY
      IMPORTING entities FOR CREATE root.

    METHODS read FOR READ
      IMPORTING keys FOR READ root RESULT result.

    METHODS lock FOR LOCK
      IMPORTING keys FOR LOCK root.

    METHODS update FOR MODIFY
      IMPORTING entities FOR UPDATE root.

    METHODS delete FOR MODIFY
      IMPORTING keys FOR DELETE root.

    METHODS rba_child FOR READ
      IMPORTING keys_rba FOR READ root\_child FULL result_requested RESULT result LINK association_links.

    METHODS cba_child FOR MODIFY
      IMPORTING entities_cba FOR CREATE root\_child.

    METHODS multiply_by_2 FOR MODIFY
      IMPORTING keys FOR ACTION root~multiply_by_2.

    METHODS get_instance_authorizations FOR INSTANCE AUTHORIZATION
      IMPORTING keys REQUEST requested_authorizations FOR root RESULT result.

    METHODS get_instance_features FOR INSTANCE FEATURES
      IMPORTING keys REQUEST requested_features FOR root RESULT result.

    METHODS multiply_by_3 FOR MODIFY
      IMPORTING keys FOR ACTION root~multiply_by_3.

    METHODS get_global_features FOR GLOBAL FEATURES
    IMPORTING REQUEST requested_features FOR root RESULT result.

    METHODS set_z FOR MODIFY
      IMPORTING keys FOR ACTION root~set_z.

ENDCLASS.""",
    r"""CLASS lhc_root IMPLEMENTATION.

  METHOD get_global_authorizations.
    "No implementation. All users are authorized.
  ENDMETHOD.

  METHOD create.
    "Preparing the transactional buffer based on the input BDEF derived type.
    lcl_buffer=>prep_root_buffer( CORRESPONDING #( entities ) ).

    "Processing requested entities sequentially
    LOOP AT entities ASSIGNING FIELD-SYMBOL(<create>).
      "Logic:
      "- Line with the specific key does not exist in the buffer for the root entity
      "- Line with the specific key exists in the buffer but it is marked as deleted
      "- If it is true: Add new instance to the buffer and, if needed, remove the instance marked as deleted beforehand
      IF NOT line_exists( lcl_buffer=>root_buffer[ instance-key_field = <create>-key_field ] )
      OR line_exists( lcl_buffer=>root_buffer[ instance-key_field = <create>-key_field deleted = abap_true ] ).

        "If it exists, removing instance that is marked for deletion from the transactional buffer since it gets replaced by a new one.
        DELETE lcl_buffer=>root_buffer WHERE instance-key_field = VALUE #(
            lcl_buffer=>root_buffer[ instance-key_field = <create>-key_field ]-instance-key_field OPTIONAL ) AND deleted = abap_true.

        "Adding new instance to the transactional buffer by considering %control values
        APPEND VALUE #( cid                = <create>-%cid
                        instance-key_field = <create>-key_field
                        instance-field1    = COND #( WHEN <create>-%control-field1 NE if_abap_behv=>mk-off
                                                     THEN <create>-field1 )
                        instance-field2    = COND #( WHEN <create>-%control-field2 NE if_abap_behv=>mk-off
                                                     THEN <create>-field2 )
                        instance-field3    = COND #( WHEN <create>-%control-field3 NE if_abap_behv=>mk-off
                                                     THEN <create>-field3 )
                        instance-field4    = COND #( WHEN <create>-%control-field4 NE if_abap_behv=>mk-off
                                                     THEN <create>-field4 )
                        changed            = abap_true
                        deleted            = abap_false ) TO lcl_buffer=>root_buffer.

        "Filling the MAPPED response parameter for the root entity
        INSERT VALUE #( %cid = <create>-%cid
                        %key = <create>-%key ) INTO TABLE mapped-root.

      ELSE.

        "Filling FAILED and REPORTED response parameters
        APPEND VALUE #( %cid        = <create>-%cid
                        %key        = <create>-%key
                        %create     = if_abap_behv=>mk-on
                        %fail-cause = if_abap_behv=>cause-unspecific
                    ) TO failed-root.

        APPEND VALUE #( %cid      = <create>-%cid
                        %key      = <create>-%key
                        %create   = if_abap_behv=>mk-on
                        %msg      = new_message_with_text(
                        severity  = if_abap_behv_message=>severity-error
                        text      = 'Create operation failed.' )
                    ) TO reported-root.

      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD update.
    "Preparing the transactional buffer based on the input BDEF derived type.
    lcl_buffer=>prep_root_buffer( CORRESPONDING #( entities ) ).

    "Processing requested entities sequentially
    "Note:
    "The example is implemented in a way that instances that failed in methods called before this method are not handled.
    "The instances that have failed before this method call are not available in this method's input parameter.
    "Hence, an adding to FAILED and REPORTED is not implemented here.
    LOOP AT entities ASSIGNING FIELD-SYMBOL(<update>).

      "Logic:
      "- Line with the specific key exists in the buffer for the root entity and it is not marked as deleted
      "- If it is true: Updating the buffer based on the input BDEF derived type and considering %control values
      READ TABLE lcl_buffer=>root_buffer
         WITH KEY instance-key_field = <update>-key_field
                  deleted            = abap_false
         ASSIGNING FIELD-SYMBOL(<fs_up>).

      IF sy-subrc = 0.
        <fs_up>-instance-field1  = COND #( WHEN <update>-%control-field1 NE if_abap_behv=>mk-off
                                           THEN <update>-field1
                                           ELSE <fs_up>-instance-field1 ).

        <fs_up>-instance-field2  = COND #( WHEN <update>-%control-field2 NE if_abap_behv=>mk-off
                                           THEN <update>-field2
                                           ELSE <fs_up>-instance-field2 ).

        <fs_up>-instance-field3  = COND #( WHEN <update>-%control-field3 NE if_abap_behv=>mk-off
                                           THEN <update>-field3
                                           ELSE <fs_up>-instance-field3 ).

        <fs_up>-instance-field4  = COND #( WHEN <update>-%control-field4 NE if_abap_behv=>mk-off
                                           THEN <update>-field4
                                           ELSE <fs_up>-instance-field4 ).

        <fs_up>-changed  = abap_true.
        <fs_up>-deleted  = abap_false.
      ENDIF.


    ENDLOOP.
  ENDMETHOD.

  METHOD read.
    "Preparing the transactional buffer based on the input BDEF derived type.
    lcl_buffer=>prep_root_buffer( CORRESPONDING #( keys ) ).

    "Processing requested keys sequentially
    LOOP AT keys ASSIGNING FIELD-SYMBOL(<read>) GROUP BY <read>-%tky.
      "Logic:
      "- Line exists in the buffer and it is not marked as deleted
      "- If it is true: Adding the entries to the buffer based on the input BDEF derived type and considering %control values
      READ TABLE lcl_buffer=>root_buffer
        WITH KEY instance-key_field = <read>-key_field
                 deleted            = abap_false
        ASSIGNING FIELD-SYMBOL(<fs_r>).

      IF sy-subrc = 0.

        APPEND VALUE #( %tky   = <read>-%tky
                        field1 = COND #( WHEN <read>-%control-field1 NE if_abap_behv=>mk-off
                                         THEN <fs_r>-instance-field1 )
                        field2 = COND #( WHEN <read>-%control-field2 NE if_abap_behv=>mk-off
                                         THEN <fs_r>-instance-field2 )
                        field3 = COND #( WHEN <read>-%control-field3 NE if_abap_behv=>mk-off
                                         THEN <fs_r>-instance-field3 )
                        field4 = COND #( WHEN <read>-%control-field4 NE if_abap_behv=>mk-off
                                         THEN <fs_r>-instance-field4 )
                        ) TO result.

      ELSE.

        "Filling FAILED and REPORTED response parameters
        APPEND VALUE #( %tky         = <read>-%tky
                        %fail-cause  = if_abap_behv=>cause-not_found
                    ) TO failed-root.

        APPEND VALUE #( %tky = <read>-%tky
                        %msg = new_message_with_text(
                        severity  = if_abap_behv_message=>severity-error
                        text      = 'Read operation failed.' )
                    ) TO reported-root.

      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD lock.

    TRY.
        "Instantiating lock object
        DATA(lo_lock) = cl_abap_lock_object_factory=>get_instance(
                        iv_name = 'EZDEMO_ABAP_LOCK' ).

        "Processing requested keys sequentially
        LOOP AT keys REFERENCE INTO DATA(lr_key).
          TRY.
              lo_lock->enqueue( it_parameter = VALUE #(
                ( name = 'KEY_FIELD' value = REF #( lr_key->key_field ) ) ) ).
            CATCH cx_abap_foreign_lock.
              APPEND VALUE #( %key        = CORRESPONDING #( lr_key->* )
                              %fail-cause = if_abap_behv=>cause-locked )
              TO failed-root.
            CATCH cx_abap_lock_failure.
              APPEND VALUE #( %key        = CORRESPONDING #( lr_key->* )
                              %fail-cause = if_abap_behv=>cause-locked )
              TO failed-root.
          ENDTRY.
        ENDLOOP.
      CATCH cx_abap_lock_failure.
        APPEND VALUE #( %fail-cause = if_abap_behv=>cause-locked )
        TO failed-root.
    ENDTRY.
  ENDMETHOD.

  METHOD delete.
    "Preparing the transactional buffer based on the input BDEF derived type.
    lcl_buffer=>prep_root_buffer( CORRESPONDING #( keys ) ).
    "Preparing the child buffer to mark child instances when parent instances are marked for deletion.
    lcl_buffer=>prep_child_buffer( VALUE #( FOR wa IN keys ( key_field = wa-key_field ) ) ).

    "Processing requested keys sequentially
    "Note:
    "The example is implemented in a way that instances that failed in methods called before this method are not handled.
    "The instances that have failed before this method call are not available in this method's input parameter.
    "Hence, an adding to FAILED and REPORTED is not implemented here.
    LOOP AT keys ASSIGNING FIELD-SYMBOL(<delete>).
      "Logic:
      "- Line exists in the buffer and it is not marked as deleted
      "- If it is true: Flagging the instance as deleted
      READ TABLE lcl_buffer=>root_buffer
        WITH KEY instance-key_field = <delete>-key_field
                 deleted = abap_false
        ASSIGNING FIELD-SYMBOL(<fs_del>).

      IF sy-subrc = 0.
        <fs_del>-changed  = abap_false.
        <fs_del>-deleted  = abap_true.

        "When parent instances are marked for deletion, child instances with the shared key should be marked as well.
        LOOP AT lcl_buffer=>child_buffer ASSIGNING FIELD-SYMBOL(<del_ch>) WHERE instance-key_field = <delete>-key_field.
          <del_ch>-changed = abap_false.
          <del_ch>-deleted = abap_true.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD rba_Child.
    "Preparing the transactional buffers for both the root and child entity based on the input BDEF derived type.
    lcl_buffer=>prep_root_buffer( CORRESPONDING #( keys_rba ) ).
    lcl_buffer=>prep_child_buffer( CORRESPONDING #( keys_rba ) ).

    "Processing requested keys sequentially
    LOOP AT keys_rba ASSIGNING FIELD-SYMBOL(<rba>) GROUP BY <rba>-key_field.
      "Logic:
      "- Line with the shared key value exists in the buffer for the root entity and it is not marked as deleted
      "- Line with the shared key value exists in the child buffer
      "- If it is true: Sequentially processing the child buffer entries (the example is set up in a way that there can be multiple entries)
      IF line_exists( lcl_buffer=>root_buffer[ instance-key_field = <rba>-key_field deleted = abap_false ] )
      AND line_exists( lcl_buffer=>child_buffer[ instance-key_field = <rba>-key_field deleted = abap_false ] ).

        LOOP AT lcl_buffer=>child_buffer ASSIGNING FIELD-SYMBOL(<ch>) WHERE instance-key_field = <rba>-key_field.

          "Filling the table for the LINK parameter
          INSERT VALUE #( source-%tky = <rba>-%tky
                          target-%tky = VALUE #( key_field = <ch>-instance-key_field
                                                 key_ch    = <ch>-instance-key_ch ) ) INTO TABLE association_links.

          "Filling the table for the RESULT parameter based on the FULL parameter
          "Note: If the FULL parameter is initial, only the LINK parameter should be provided
          IF result_requested = abap_true.
            APPEND VALUE #( key_field   = <ch>-instance-key_field
                            key_ch      = <ch>-instance-key_ch
                            field_ch1 = COND #( WHEN <rba>-%control-field_ch1 NE if_abap_behv=>mk-off
                                                THEN <ch>-instance-field_ch1 )
                            field_ch2 = COND #( WHEN <rba>-%control-field_ch2 NE if_abap_behv=>mk-off
                                                THEN <ch>-instance-field_ch2 )
                          ) TO result.
          ENDIF.
        ENDLOOP.

      ELSE.

        "Filling FAILED and REPORTED response parameters
        APPEND VALUE #( %tky          = <rba>-%tky
                        %fail-cause   = if_abap_behv=>cause-not_found
                        %assoc-_child = if_abap_behv=>mk-on
                    ) TO failed-root.


        APPEND VALUE #( %tky = <rba>-%tky
                        %msg = new_message_with_text(
                        severity  = if_abap_behv_message=>severity-error
                        text      = 'RBA (parent to child) operation failed.' )
                    ) TO reported-root.

      ENDIF.
    ENDLOOP.

    "Removing potential duplicate entries
    SORT association_links BY target ASCENDING.
    DELETE ADJACENT DUPLICATES FROM association_links COMPARING ALL FIELDS.

    SORT result BY %tky ASCENDING.
    DELETE ADJACENT DUPLICATES FROM result COMPARING ALL FIELDS.

  ENDMETHOD.

  METHOD cba_Child.
    "Preparing the transactional buffers for both the root and child entity based on the input BDEF derived type
    lcl_buffer=>prep_root_buffer( CORRESPONDING #( entities_cba ) ).
    lcl_buffer=>prep_child_buffer( CORRESPONDING #( entities_cba ) ).

    "Processing requested entities sequentially
    LOOP AT entities_cba ASSIGNING FIELD-SYMBOL(<cba>) GROUP BY <cba>-key_field.
      "Logic:
      "- Line with the shared key value exists in the buffer for the root entity and it is not marked as deleted
      "- If it is true: Sequentially processing the instances in the %target table
      IF line_exists( lcl_buffer=>root_buffer[ instance-key_field = <cba>-key_field deleted = abap_false ] ).

        "If it exists, removing instance that is marked for deletion from the child transactional buffer since it gets replaced by a new one.
        DELETE lcl_buffer=>child_buffer WHERE instance-key_field = <cba>-key_field AND deleted = abap_true.

        LOOP AT <cba>-%target ASSIGNING FIELD-SYMBOL(<ch>).

          "Adding instance to child buffer if it does not exist there and considering %control values
          "The example is implemented in a way that the RAP BO consumer need not specify the common key with the root entity.
          "Plus, the keys of the child entity should not be initial.
          IF NOT line_exists( lcl_buffer=>child_buffer[ instance-key_field = <cba>-key_field
                                                        instance-key_ch    = <ch>-key_ch ] )
          AND <ch>-key_ch IS NOT INITIAL.

            APPEND VALUE #( cid_ref            = <cba>-%cid_ref
                            cid_target         = <ch>-%cid
                            instance-key_field = <cba>-key_field
                            instance-key_ch    = <ch>-key_ch
                            instance-field_ch1 = COND #( WHEN <ch>-%control-field_ch1 NE if_abap_behv=>mk-off
                                                         THEN <ch>-field_ch1 )
                            instance-field_ch2 = COND #( WHEN <ch>-%control-field_ch2 NE if_abap_behv=>mk-off
                                                         THEN <ch>-field_ch2 )
                            changed            = abap_true
                        ) TO lcl_buffer=>child_buffer.

            "Filling MAPPED response parameter
            INSERT VALUE #( %cid = <ch>-%cid
                            %key = VALUE #( key_field = <cba>-key_field
                                            key_ch    = <ch>-key_ch ) ) INTO TABLE mapped-child.

          ELSE.

            "Filling FAILED and REPORTED response parameters
            APPEND VALUE #( %cid          = <cba>-%cid_ref
                            %tky          = <cba>-%tky
                            %assoc-_child = if_abap_behv=>mk-on
                            %fail-cause   = if_abap_behv=>cause-unspecific
                        ) TO failed-root.

            APPEND VALUE #( %cid = <cba>-%cid_ref
                            %tky = <cba>-%tky
                            %msg = new_message_with_text(
                            severity  = if_abap_behv_message=>severity-error
                            text      = 'Create-by-association (root to child) operation failed.' )
                        ) TO reported-root.

            APPEND VALUE #( %cid        = <ch>-%cid
                            %key        = VALUE #( key_field = <cba>-key_field key_ch = <ch>-key_ch )
                            %fail-cause = if_abap_behv=>cause-dependency
                            ) TO failed-child.

            APPEND VALUE #( %cid = <ch>-%cid
                            %key = VALUE #( key_field = <cba>-key_field key_ch = <ch>-key_ch )
                            %msg = new_message_with_text(
                                severity  = if_abap_behv_message=>severity-error
                                text      = 'Create-by-association (root to child) operation failed.' )
                            ) TO reported-child.

          ENDIF.
        ENDLOOP.

      ELSE.

        "Filling FAILED and REPORTED response parameters
        APPEND VALUE #( %cid          = <cba>-%cid_ref
                        %tky          = <cba>-%tky
                        %assoc-_child = if_abap_behv=>mk-on
                        %fail-cause   = if_abap_behv=>cause-not_found
                    ) TO failed-root.

        APPEND VALUE #( %cid = <cba>-%cid_ref
                        %tky = <cba>-%tky
                        %msg = new_message_with_text(
                        severity  = if_abap_behv_message=>severity-error
                        text      = 'Create-by-association (root to child) operation failed.' )
                    ) TO reported-root.

        LOOP AT <cba>-%target ASSIGNING FIELD-SYMBOL(<target>).
          APPEND VALUE #( %cid        = <target>-%cid
                          %key        = <target>-%key
                          %fail-cause = if_abap_behv=>cause-dependency
                          ) TO failed-child.

          APPEND VALUE #( %cid = <target>-%cid
                          %key = <target>-%key
                          %msg = new_message_with_text(
                              severity  = if_abap_behv_message=>severity-error
                              text      = 'Create-by-association (root to child) operation failed.' )
                          ) TO reported-child.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD multiply_by_2.

    "Retrieving instances based on requested keys
    READ ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      FIELDS ( field3 field4 ) WITH CORRESPONDING #( keys )
      RESULT DATA(result)
      FAILED failed.

    "If read result is initial, stop further method execution.
    CHECK result IS NOT INITIAL.

    "Setting %action value in failed response parameter
    LOOP AT failed-root ASSIGNING FIELD-SYMBOL(<f>).
      <f>-%action-multiply_by_2 = if_abap_behv=>mk-on.
    ENDLOOP.

    "Multiply integer values by 2
    MODIFY ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      UPDATE FIELDS ( field3 field4 ) WITH VALUE #( FOR key IN result ( %tky   = key-%tky
                                                                      field3 = key-field3 * 2
                                                                      field4 = key-field4 * 2 ) ).
  ENDMETHOD.

  METHOD get_instance_authorizations.

    "Retrieving instances based on requested keys
    READ ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      FIELDS ( field1 ) WITH CORRESPONDING #( keys )
      RESULT DATA(status)
      FAILED failed.

    "If the read result is initial, stop further method execution.
    CHECK status IS NOT INITIAL.

    LOOP AT status ASSIGNING FIELD-SYMBOL(<auth>).

      "If a specific field has a certain value, the deletion should be disallowed.
      IF requested_authorizations-%delete = if_abap_behv=>mk-on.
        APPEND VALUE #( %tky = <auth>-%tky
                        %op  = VALUE #( %delete = COND #( WHEN <auth>-field1 = 'X'
                                                          THEN if_abap_behv=>auth-unauthorized
                                                          ELSE if_abap_behv=>auth-allowed ) )
                      ) TO result.

      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD get_instance_features.

    READ ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      FIELDS ( field3 field4 ) WITH CORRESPONDING #( keys )
      RESULT DATA(numbers)
      FAILED failed.

    "If the read result is initial, stop further method execution.
    CHECK numbers IS NOT INITIAL.

    LOOP AT numbers ASSIGNING FIELD-SYMBOL(<feat>).

      "If two fields have certain values, the execution of an action should be disabled for the instance.
      IF requested_features-%action-multiply_by_3 = if_abap_behv=>mk-on.
        APPEND VALUE #( %tky                            = <feat>-%tky
                        %features-%action-multiply_by_3 = COND #( WHEN <feat>-field3 = 0 OR <feat>-field4 = 0
                                                                  THEN if_abap_behv=>fc-o-disabled
                                                                  ELSE if_abap_behv=>fc-o-enabled )
                      ) TO result.

      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD multiply_by_3.
    "Retrieving instances based on requested keys
    READ ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      FIELDS ( field3 field4 ) WITH CORRESPONDING #( keys )
      RESULT DATA(result)
      FAILED failed.

    "Setting %action value in failed response parameter
    LOOP AT failed-root ASSIGNING FIELD-SYMBOL(<f>).
      <f>-%action-multiply_by_3 = if_abap_behv=>mk-on.
    ENDLOOP.

    "Multiply integer values by 3
    MODIFY ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      UPDATE FIELDS ( field3 field4 ) WITH VALUE #( FOR key IN result ( %tky   = key-%tky
                                                                        field3 = key-field3 * 3
                                                                        field4 = key-field4 * 3 ) ).
  ENDMETHOD.

  METHOD get_global_features.
    "The execution of an action should be disabled based on a certain time frame.
    DATA(time1) = CONV t( '070000' ).
    DATA(time2) = CONV t( '120000' ).

    result = VALUE #( %action-set_z = COND #( WHEN cl_abap_context_info=>get_system_time( ) BETWEEN time1 AND time2
                                              THEN if_abap_behv=>fc-o-enabled
                                              ELSE if_abap_behv=>fc-o-disabled )
                    ).

    IF result-%action-set_z = if_abap_behv=>fc-o-disabled.
      APPEND VALUE #( %msg    = new_message_with_text( text     = 'Execution of action currently not allowed.'
                                                       severity = if_abap_behv_message=>severity-error )
                      %global = if_abap_behv=>mk-on ) TO reported-root.
    ENDIF.
  ENDMETHOD.

  METHOD set_z.

    "Retrieving instances based on requested keys
    READ ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      FIELDS ( field3 field4 ) WITH CORRESPONDING #( keys )
      RESULT DATA(result)
      FAILED failed.

    "Setting %action value in failed response parameter
    LOOP AT failed-root ASSIGNING FIELD-SYMBOL(<f>).
      <f>-%action-set_z = if_abap_behv=>mk-on.
    ENDLOOP.

    "Setting a field value
    MODIFY ENTITIES OF zdemo_abap_rap_ro_u IN LOCAL MODE
      ENTITY root
      UPDATE FIELDS ( field2 ) WITH VALUE #( FOR key IN result ( %tky   = key-%tky
                                                                 field2 = 'Z' ) ).

  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_amdp DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES:
      if_oo_adt_classrun, "Interface for displaying output
      if_amdp_marker_hdb. "This interface specification is mandatory for an AMDP class

    "Various internal table type specifications for the parameters of AMDP methods
    "Note: Only table and elementary data types are possible for the parameters.
    TYPES carr_tab TYPE STANDARD TABLE OF zdemo_abap_carr_ve WITH EMPTY KEY.

    TYPES fli_tab TYPE STANDARD TABLE OF zdemo_abap_fli_ve WITH EMPTY KEY.

    TYPES:
      "Structured data type as basis for the table type below
      BEGIN OF carr_fli_struc,
        carrname TYPE zdemo_abap_carr_ve-carrname,
        connid   TYPE zdemo_abap_flsch_ve-connid,
        cityfrom TYPE zdemo_abap_flsch_ve-cityfrom,
        cityto   TYPE zdemo_abap_flsch_ve-cityto,
      END OF carr_fli_struc,

      "Internal table type
      carr_fli_tab TYPE STANDARD TABLE OF carr_fli_struc WITH EMPTY KEY,

      "Structured data type as basis for the table type below
      BEGIN OF fli_struc,
        carrid   TYPE zdemo_abap_flsch_ve-carrid,
        connid   TYPE zdemo_abap_flsch_ve-connid,
        cityfrom TYPE zdemo_abap_flsch_ve-cityfrom,
        cityto   TYPE zdemo_abap_flsch_ve-cityto,
        fltime   TYPE zdemo_abap_flsch_ve-fltime,
      END OF fli_struc,

      "Internal table type
      flsch_tab TYPE STANDARD TABLE OF zdemo_abap_flsch_ve WITH EMPTY KEY.

    "Various instance method declarations
    "The selection for instance and static methods is irrelevant for the example.
    "It is just meant to visualize that AMDP methods can be declared as either of them.

    "AMDP procedure
    "It's a simple AMDP procedure having only an output parameter with tabular type.
    "Note the parameter declaration that includes the mandatory passing by value.
    "This is true for all of the AMDP method declarations.
    METHODS select_carriers
      AMDP OPTIONS READ-ONLY CDS SESSION CLIENT dependent
      EXPORTING VALUE(carr_tab) TYPE carr_tab.

    "AMDP procedure to call an AMDP table function
    "As can be seen in the implementation part, this example method calls the
    "AMDP table function get_carr_fli. AMDP table functions can only be called
    "by other AMDP methods.
    METHODS select_get_carr_fli
      AMDP OPTIONS READ-ONLY CDS SESSION CLIENT dependent
      IMPORTING VALUE(carrid)       TYPE zdemo_abap_fli_ve-carrid
      EXPORTING VALUE(carr_fli_tab) TYPE carr_fli_tab.

    "Various static method declarations

    "The purpose of the implementation of the static constructor in this example is to
    "fill a demo database table to have data to work with in the example.
    CLASS-METHODS class_constructor.

    "AMDP procedure
    "This method demonstrates the calling of an AMDP procedure from SQLScript.
    "In this example, the selection of data is 'delegated' to another AMDP method get_flights_amdp
    "in the same AMDP class. The method declaration includes the addition RAISING with an
    "exception class for AMDP-specific exceptions.
    CLASS-METHODS  get_flights
      AMDP OPTIONS READ-ONLY CDS SESSION CLIENT dependent
      IMPORTING VALUE(carrid)  TYPE zdemo_abap_fli_ve-carrid
      EXPORTING VALUE(fli_tab) TYPE fli_tab
      RAISING   cx_amdp_execution_error.

    "AMDP Table Function for CDS Table Function
    "Note that, in this case, a static method declaration is required along with the special
    "syntax FOR TABLE FUNCTION. Plus, there are no parameters specified and the declaration
    "is made in the PUBLIC visibility section.
    CLASS-METHODS flight_analysis FOR TABLE FUNCTION zdemo_abap_table_function.

  PROTECTED SECTION.
  PRIVATE SECTION.

    "AMDP procedure
    "This method demonstrates the calling of an AMDP procedure from SQLScript as mentioned above.
    CLASS-METHODS get_flights_amdp
      AMDP OPTIONS READ-ONLY CDS SESSION CLIENT dependent
      IMPORTING VALUE(carrid)  TYPE zdemo_abap_fli_ve-carrid
      EXPORTING VALUE(fli_tab) TYPE fli_tab
      RAISING   cx_amdp_execution_error.

    "AMDP table function
    "AMDP table functions can only be called by other AMDP methods. In this example,
    "the AMDP procedure select_get_carr_fli calls this AMDP table function.
    METHODS get_carr_fli
      AMDP OPTIONS READ-ONLY CDS SESSION CLIENT dependent
      IMPORTING VALUE(carrid)       TYPE zdemo_abap_flsch_ve-carrid
      RETURNING VALUE(carr_fli_tab) TYPE carr_fli_tab.

    CONSTANTS nl TYPE string VALUE cl_abap_char_utilities=>newline.
ENDCLASS.""",
    r""" CLASS zcl_demo_abap_amdp IMPLEMENTATION.


  METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.


  METHOD flight_analysis
         BY DATABASE FUNCTION
         FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING zdemo_abap_flsch_ve
               zdemo_abap_carr_ve.
* Reading data from two CDS view entities
    itab_cities =
     select DISTINCT
            zdemo_abap_flsch_ve.mandt    as client,
            zdemo_abap_flsch_ve.carrid   as carrier_id,
            zdemo_abap_flsch_ve.airpfrom as airport_from,
            zdemo_abap_flsch_ve.airpto   as airport_to,
            zdemo_abap_flsch_ve.fltime   as flight_time,
            zdemo_abap_flsch_ve.distance as flight_distance,
            zdemo_abap_flsch_ve.distid   as unit
       from zdemo_abap_flsch_ve;

    itab_carrier_names =
     select distinct
            zdemo_abap_carr_ve.mandt    as client,
            zdemo_abap_carr_ve.carrid   as carrier_id,
            zdemo_abap_carr_ve.carrname as carrier_name
       from zdemo_abap_carr_ve;

* Returning joined data using an inner join
   return
     select fl.client, fl.carrier_id, ca.carrier_name,
* Departure and destination airports are concatenated; then all results are joined by string aggregation
        string_agg( concat(concat(fl.airport_from,' -> '),fl.airport_to), ', ' ORDER BY fl.airport_from) AS connections,
* Retrieving the average flight time of all flights by carrier
        AVG( fl.flight_time ) as avg_flight_time,
* Retrieving the average flight distance of all flights by carrier; miles are converted to kilometers
        avg( case 'MI'
             when fl.unit then fl.flight_distance * 1.609
             ELSE fl.flight_distance
             END ) AS avg_distance
       FROM :itab_cities AS fl
       INNER JOIN :itab_carrier_names AS ca
       ON ca.client = fl.client
       AND ca.carrier_id = fl.carrier_id
       WHERE fl.client = ca.client AND fl.carrier_id = ca.carrier_id
       GROUP BY fl.client, ca.carrier_name, fl.carrier_id;
  ENDMETHOD.


  METHOD get_carr_fli
         BY DATABASE FUNCTION
         FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING zdemo_abap_carr_ve zdemo_abap_flsch_ve.
* AMDP table function to be called by other AMDP methods only.
* In the example, joined data from two CDS view entities are returned.
    RETURN
      SELECT ca.carrname, fl.connid, fl.cityfrom, fl.cityto
        FROM zdemo_abap_carr_ve as ca
        INNER JOIN zdemo_abap_flsch_ve as fl
        ON ca.carrid = fl.carrid
        WHERE fl.carrid = :carrid
        ORDER BY ca.mandt, ca.carrname, fl.connid;
  ENDMETHOD.


  METHOD get_flights
         BY DATABASE PROCEDURE
         FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING zcl_demo_abap_amdp=>get_flights_amdp.
* Another AMDP procedure is called from SQLScript
    CALL "ZCL_DEMO_ABAP_AMDP=>GET_FLIGHTS_AMDP"(
      carrid => :carrid,
      fli_tab => :fli_tab );
  ENDMETHOD.


  METHOD get_flights_amdp
         BY DATABASE PROCEDURE
         FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING zdemo_abap_fli_ve.
* Simple data selection
    fli_tab = SELECT carrid, connid, fldate, price, currency, planetype,
                     seatsmax, seatsocc, paymentsum, seatsmax_b, seatsocc_b,
                     seatsmax_f, seatsocc_f
                FROM "ZDEMO_ABAP_FLI_VE"
                WHERE carrid = :carrid
                ORDER BY carrid;
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( `ABAP Cheat Sheet Example: AMDP` ).

    out->write( |\n1) AMDP Procedure\n\n| ).

    "Declaring an internal table to store the data that are
    "returned by the following method.
    "You could also choose to create the internal table inline
    "within the method call,
    "i. e. like ... IMPORTING carr_tab = DATA(tab) ).
    DATA amdp_proc_res TYPE zcl_demo_abap_amdp=>carr_tab.

    "Since the method is declared as an instance method, an instance
    "has to be created. Here, the instance constructor NEW is used
    "in a standalone method call that includes a chained method call.
    NEW zcl_demo_abap_amdp( )->select_carriers(
      IMPORTING carr_tab = amdp_proc_res ).

    out->write( data = amdp_proc_res name = `amdp_proc_res` ).

    out->write( zcl_demo_abap_aux=>heading( `2) Calling an AMDP Procedure from SQLScript` ) ).

    TRY.
        zcl_demo_abap_amdp=>get_flights( EXPORTING carrid = 'LH'
                                         IMPORTING fli_tab = DATA(call_amdp_res) ).
      CATCH cx_amdp_execution_error INTO DATA(error1).
        out->write( error1->get_text( ) ).
    ENDTRY.

    out->write( data = call_amdp_res name = `call_amdp_res` ).


    out->write( zcl_demo_abap_aux=>heading( `3) AMDP Table Function for AMDP Method` ) ).
    
    TRY.
        NEW zcl_demo_abap_amdp( )->select_get_carr_fli(
          EXPORTING carrid = 'LH'
          IMPORTING carr_fli_tab = DATA(amdp_tab_func) ).
      CATCH cx_amdp_execution_error INTO DATA(error2).
        out->write( error2->get_text( ) ).
    ENDTRY.

    out->write( data = amdp_tab_func name = `amdp_tab_func` ).

    out->write( zcl_demo_abap_aux=>heading( `4) AMDP Table Function for CDS Table Function` ) ).

    SELECT * FROM zdemo_abap_table_function
      INTO TABLE @DATA(cds_tab_func).

    out->write( data = cds_tab_func name = `cds_tab_func` ).

  ENDMETHOD.


  METHOD select_carriers
         BY DATABASE PROCEDURE
         FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING zdemo_abap_carr_ve.
* Simple data selection
    carr_tab = SELECT carrid, carrname, currcode, url
                FROM "ZDEMO_ABAP_CARR_VE"
                ORDER BY carrid;
  ENDMETHOD.


  METHOD select_get_carr_fli
         BY DATABASE PROCEDURE
         FOR HDB
         LANGUAGE SQLSCRIPT
         OPTIONS READ-ONLY
         USING zcl_demo_abap_amdp=>get_carr_fli.
* AMDP procedure to call an AMDP table function as specified after USING
    carr_fli_tab = SELECT *
                     FROM "ZCL_DEMO_ABAP_AMDP=>GET_CARR_FLI"(
                        carrid => :carrid );
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_aux DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    CLASS-METHODS: clear_dbtabs,
      fill_dbtabs,
      heading IMPORTING text          TYPE string
              RETURNING VALUE(output) TYPE string.
    CONSTANTS no_output TYPE string VALUE `No output for this section. You can set breakpoints and check the content of data objects (if available) in the debugger.`.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_aux IMPLEMENTATION.

  METHOD clear_dbtabs.
    DELETE FROM zdemo_abap_flsch.
    DELETE FROM zdemo_abap_carr.
    DELETE FROM zdemo_abap_fli.
  ENDMETHOD.


  METHOD fill_dbtabs.

    "Clearing db tables before filling
    clear_dbtabs( ).

    "Filling db table
    MODIFY zdemo_abap_flsch FROM TABLE @( VALUE #(
      ( carrid = 'AA'
        connid =  0017
        countryfr =  'US'
        cityfrom =  'NEW YORK'
        airpfrom = 'JFK'
        countryto = 'US'
        cityto = 'SAN FRANCISCO'
        airpto = 'SFO'
        fltime = 361
        deptime = '110000'
        arrtime = '140100'
        distance =  2572
        distid = 'MI'
        fltype = ''
        period = 0 )
      ( carrid = 'AA'
        connid =  0064
        countryfr =  'US'
        cityfrom =  'SAN FRANCISCO'
        airpfrom = 'SFO'
        countryto = 'US'
        cityto = 'NEW YORK'
        airpto = 'JFK'
        fltime = 321
        deptime = '090000'
        arrtime = '172100'
        distance =  2572
        distid = 'MI'
        fltype = ''
        period = 0 )
      ( carrid = 'AZ'
        connid =  0555
        countryfr =  'IT'
        cityfrom =  'ROME'
        airpfrom = 'FCO'
        countryto = 'DE'
        cityto = 'FRANKFURT'
        airpto = 'FRA'
        fltime = 125
        deptime = '190000'
        arrtime = '210500'
        distance =  845
        distid = 'MI'
        fltype = ''
        period = 0 )
      ( carrid = 'AZ'
        connid =  0788
        countryfr =  'IT'
        cityfrom =  'ROME'
        airpfrom = 'FCO'
        countryto = 'JP'
        cityto = 'TOKYO'
        airpto = 'TYO'
        fltime = 775
        deptime = '120000'
        arrtime = '085500'
        distance =  6130
        distid = 'MI'
        fltype = ''
        period = 1 )
      ( carrid = 'AZ'
        connid =  0789
        countryfr =  'JP'
        cityfrom =  'TOKYO'
        airpfrom = 'TYO'
        countryto = 'IT'
        cityto = 'ROME'
        airpto = 'FCO'
        fltime = 940
        deptime = '114500'
        arrtime = '192500'
        distance =  6130
        distid = 'MI'
        fltype = ''
        period = 0 )
      ( carrid = 'AZ'
        connid =  0790
        countryfr =  'IT'
        cityfrom =  'ROME'
        airpfrom = 'FCO'
        countryto = 'JP'
        cityto = 'OSAKA'
        airpto = 'KIX'
        fltime = 815
        deptime = '103500'
        arrtime = '081000'
        distance =  6030
        distid = 'MI'
        fltype = 'X'
        period = 1 )
      ( carrid = 'DL'
        connid =  0106
        countryfr =  'US'
        cityfrom =  'NEW YORK'
        airpfrom = 'JFK'
        countryto = 'DE'
        cityto = 'FRANKFURT'
        airpto = 'FRA'
        fltime = 475
        deptime = '193500'
        arrtime = '093000'
        distance =  3851
        distid = 'MI'
        fltype = ''
        period = 1 )
      ( carrid = 'DL'
        connid =  1699
        countryfr =  'US'
        cityfrom =  'NEW YORK'
        airpfrom = 'JFK'
        countryto = 'US'
        cityto = 'SAN FRANCISCO'
        airpto = 'SFO'
        fltime = 382
        deptime = '171500'
        arrtime = '203700'
        distance =  2572
        distid = 'MI'
        fltype = ''
        period = 0 )
      ( carrid = 'DL'
        connid =  1984
        countryfr =  'US'
        cityfrom =  'SAN FRANCISCO'
        airpfrom = 'SFO'
        countryto = 'US'
        cityto = 'NEW YORK'
        airpto = 'JFK'
        fltime = 325
        deptime = '100000'
        arrtime = '182500'
        distance =  2572
        distid = 'MI'
        fltype = ''
        period = 0 )
      ( carrid = 'JL'
        connid =  0407
        countryfr =  'JP'
        cityfrom =  'TOKYO'
        airpfrom = 'NRT'
        countryto = 'DE'
        cityto = 'FRANKFURT'
        airpto = 'FRA'
        fltime = 725
        deptime = '133000'
        arrtime = '173500'
        distance =  9100
        distid = 'KM'
        fltype = ''
        period = 0 )
      ( carrid = 'JL'
        connid =  0408
        countryfr =  'DE'
        cityfrom =  'FRANKFURT'
        airpfrom = 'FRA'
        countryto = 'JP'
        cityto = 'TOKYO'
        airpto = 'NRT'
        fltime = 675
        deptime = '202500'
        arrtime = '154000'
        distance =  9100
        distid = 'KM'
        fltype = 'X'
        period = 1 )
      ( carrid = 'LH'
        connid =  0400
        countryfr =  'DE'
        cityfrom =  'FRANKFURT'
        airpfrom = 'FRA'
        countryto = 'US'
        cityto = 'NEW YORK'
        airpto = 'JFK'
        fltime = 444
        deptime = '101000'
        arrtime = '113400'
        distance =  6162
        distid = 'KM'
        fltype = ''
        period = 0 )
      ( carrid = 'LH'
        connid =  0401
        countryfr =  'US'
        cityfrom =  'NEW YORK'
        airpfrom = 'JFK'
        countryto = 'DE'
        cityto = 'FRANKFURT'
        airpto = 'FRA'
        fltime = 435
        deptime = '183000'
        arrtime = '074500'
        distance =  6162
        distid = 'KM'
        fltype = ''
        period = 1 )
      ( carrid = 'LH'
        connid =  0402
        countryfr =  'DE'
        cityfrom =  'FRANKFURT'
        airpfrom = 'FRA'
        countryto = 'US'
        cityto = 'NEW YORK'
        airpto = 'JFK'
        fltime = 455
        deptime = '133000'
        arrtime = '150500'
        distance =  6162
        distid = 'KM'
        fltype = 'X'
        period = 0 )
      ( carrid = 'LH'
        connid =  2402
        countryfr =  'DE'
        cityfrom =  'FRANKFURT'
        airpfrom = 'FRA'
        countryto = 'DE'
        cityto = 'BERLIN'
        airpto = 'SXF'
        fltime = 65
        deptime = '103000'
        arrtime = '113500'
        distance =  555
        distid = 'KM'
        fltype = ''
        period = 0 ) ) ).

    "Filling db table
    MODIFY zdemo_abap_carr FROM TABLE @( VALUE #(
        ( carrid = 'AA'
          carrname = 'American Airlines'
          currcode = 'USD'
          url =  'http://www.aa.com' )
        ( carrid = 'LH'
          carrname = 'Lufthansa'
          currcode = 'EUR'
          url =  'http://www.lufthansa.com' )
        ( carrid = 'JL'
          carrname = 'Japan Airlines'
          currcode = 'JPY'
          url =  'http://www.jal.co.jp' )
        ( carrid = 'DL'
          carrname = 'Delta Airlines'
          currcode = 'USD'
          url =  'http://www.delta-air.com' )
        ( carrid = 'AZ'
          carrname = 'ITA Airways'
          currcode = 'EUR'
          url =  'http://www.ita-airways.com' ) ) ).

    "Filling db table
    MODIFY zdemo_abap_fli FROM TABLE @( VALUE #(
        ( carrid = 'AA'
          connid =  0017
          fldate =  '20230923'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   369
          paymentsum =   '191993.87'
          seatsmax_b = 31
          seatsocc_b = 31
          seatsmax_f =  21
          seatsocc_f = 19 )
        ( carrid = 'AA'
          connid =  0017
          fldate =  '20230929'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   372
          paymentsum =   '193537.52'
          seatsmax_b = 31
          seatsocc_b = 30
          seatsmax_f =  21
          seatsocc_f = 20 )
        ( carrid = 'AA'
          connid =  0017
          fldate =  '20231111'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   374
          paymentsum =   '193651.77'
          seatsmax_b = 31
          seatsocc_b = 29
          seatsmax_f =  21
          seatsocc_f = 21 )
        ( carrid = 'AA'
          connid =  0064
          fldate =  '20220131'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    'A340-600'
          seatsmax =   330
          seatsocc =   313
          paymentsum =   '168469.88'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'AA'
          connid =  0064
          fldate =  '20220215'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    'A340-600'
          seatsmax =   330
          seatsocc =   157
          paymentsum =   '84846.15'
          seatsmax_b = 30
          seatsocc_b = 15
          seatsmax_f =  20
          seatsocc_f = 10 )
        ( carrid = 'AZ'
          connid =  0555
          fldate =  '20230721'
          price  =    '226.41'
          currency = 'EUR'
          planetype  =    'A319-100'
          seatsmax =   120
          seatsocc =   114
          paymentsum =   '26519.75'
          seatsmax_b = 8
          seatsocc_b = 8
          seatsmax_f =  8
          seatsocc_f = 8 )
        ( carrid = 'AZ'
          connid =  0555
          fldate =  '20230728'
          price  =    '226.41'
          currency = 'EUR'
          planetype  =    'A319-100'
          seatsmax =   120
          seatsocc =   115
          paymentsum =   '16695.50'
          seatsmax_b = 8
          seatsocc_b = 8
          seatsmax_f =  8
          seatsocc_f = 8 )
        ( carrid = 'AZ'
          connid =  0788
          fldate =  '20230922'
          price  =    '1071.41'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   456
          paymentsum =   '548722.20'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 20 )
        ( carrid = 'AZ'
          connid =  0788
          fldate =  '20230722'
          price  =    '1071.41'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   455
          paymentsum =   '544674.30'
          seatsmax_b = 30
          seatsocc_b = 28
          seatsmax_f =  20
          seatsocc_f = 20 )
        ( carrid = 'AZ'
          connid =  0789
          fldate =  '20231025'
          price  =    '1071.41'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   455
          paymentsum =   '545704.30'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'AZ'
          connid =  0789
          fldate =  '20230221'
          price  =    '1071.41'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   459
          paymentsum =   '549226.90'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 20 )
        ( carrid = 'AZ'
          connid =  0790
          fldate =  '20231228'
          price  =    '1055.41'
          currency = 'EUR'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   370
          paymentsum =   '462373.86'
          seatsmax_b = 31
          seatsocc_b = 30
          seatsmax_f =  21
          seatsocc_f = 21 )
        ( carrid = 'AZ'
          connid =  0790
          fldate =  '20231201'
          price  =    '1055.41'
          currency = 'EUR'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   367
          paymentsum =   '463661.64'
          seatsmax_b = 31
          seatsocc_b = 31
          seatsmax_f =  21
          seatsocc_f = 21 )
        ( carrid = 'DL'
          connid =  0106
          fldate =  '20230209'
          price  =    '652.42'
          currency = 'USD'
          planetype  =    'A340-600'
          seatsmax =   330
          seatsocc =   178
          paymentsum =   '136750.33'
          seatsmax_b = 30
          seatsocc_b = 17
          seatsmax_f =  20
          seatsocc_f = 10 )
        ( carrid = 'DL'
          connid =  0106
          fldate =  '20240102'
          price  =    '652.42'
          currency = 'USD'
          planetype  =    'A340-600'
          seatsmax =   330
          seatsocc =   16
          paymentsum =   '12892.33'
          seatsmax_b = 30
          seatsocc_b = 2
          seatsmax_f =  20
          seatsocc_f = 10 )
        ( carrid = 'DL'
          connid =  1699
          fldate =  '20230921'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    '767-200'
          seatsmax =   260
          seatsocc =   250
          paymentsum =   '126636.91'
          seatsmax_b = 21
          seatsocc_b = 20
          seatsmax_f =  11
          seatsocc_f = 11 )
        ( carrid = 'DL'
          connid =  1699
          fldate =  '20230511'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    '767-200'
          seatsmax =   260
          seatsocc =   251
          paymentsum =   '126493.06'
          seatsmax_b = 21
          seatsocc_b = 20
          seatsmax_f =  11
          seatsocc_f = 11 )
        ( carrid = 'DL'
          connid =  1984
          fldate =  '20230719'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   460
          paymentsum =   '225427.35'
          seatsmax_b = 30
          seatsocc_b = 29
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'DL'
          connid =  1984
          fldate =  '20230213'
          price  =    '464.35'
          currency = 'USD'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   458
          paymentsum =   '225088.83'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'JL'
          connid =  0407
          fldate =  '20231128'
          price  =    '1102.77'
          currency = 'JPY'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   458
          paymentsum =   '563231.65'
          seatsmax_b = 30
          seatsocc_b = 27
          seatsmax_f =  20
          seatsocc_f = 20 )
        ( carrid = 'JL'
          connid =  0407
          fldate =  '20231019'
          price  =    '1102.77'
          currency = 'JPY'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   452
          paymentsum =   '553552.12'
          seatsmax_b = 30
          seatsocc_b = 28
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'JL'
          connid =  0408
          fldate =  '20231128'
          price  =    '1102.77'
          currency = 'JPY'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   365
          paymentsum =   '470129.20'
          seatsmax_b = 31
          seatsocc_b = 28
          seatsmax_f =  21
          seatsocc_f = 20 )
        ( carrid = 'JL'
          connid =  0408
          fldate =  '20230123'
          price  =    '1102.77'
          currency = 'JPY'
          planetype  =    '747-400'
          seatsmax =   385
          seatsocc =   372
          paymentsum =   '487715.90'
          seatsmax_b = 31
          seatsocc_b = 31
          seatsmax_f =  21
          seatsocc_f = 20 )
        ( carrid = 'LH'
          connid =  0400
          fldate =  '20230628'
          price  =    '1184.54'
          currency = 'EUR'
          planetype  =    'A340-600'
          seatsmax =   330
          seatsocc =   319
          paymentsum =   '270822.24'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 20 )
        ( carrid = 'LH'
          connid =  0400
          fldate =  '20230323'
          price  =    '1184.54'
          currency = 'EUR'
          planetype  =    'A340-600'
          seatsmax =   330
          seatsocc =   312
          paymentsum =   '262597.14'
          seatsmax_b = 30
          seatsocc_b = 28
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'LH'
          connid =  0401
          fldate =  '20231128'
          price  =    '669.20'
          currency = 'EUR'
          planetype  =    '767-200'
          seatsmax =   260
          seatsocc =   246
          paymentsum =   '195417.72'
          seatsmax_b = 21
          seatsocc_b = 19
          seatsmax_f =  11
          seatsocc_f = 10 )
        ( carrid = 'LH'
          connid =  0401
          fldate =  '20231229'
          price  =    '669.20'
          currency = 'EUR'
          planetype  =    '767-200'
          seatsmax =   260
          seatsocc =   252
          paymentsum =   '199300.50'
          seatsmax_b = 21
          seatsocc_b = 19
          seatsmax_f =  11
          seatsocc_f = 11 )
        ( carrid = 'LH'
          connid =  0402
          fldate =  '20230617'
          price  =    '669.20'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   461
          paymentsum =   '353526.12'
          seatsmax_b = 30
          seatsocc_b = 29
          seatsmax_f =  20
          seatsocc_f = 18 )
        ( carrid = 'LH'
          connid =  0402
          fldate =  '20230313'
          price  =    '669.20'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   450
          paymentsum =   '349223.76'
          seatsmax_b = 30
          seatsocc_b = 29
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'LH'
          connid =  2402
          fldate =  '20231028'
          price  =    '245.20'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   451
          paymentsum =   '127197.62'
          seatsmax_b = 30
          seatsocc_b = 29
          seatsmax_f =  20
          seatsocc_f = 19 )
        ( carrid = 'LH'
          connid =  2402
          fldate =  '20231223'
          price  =    '245.20'
          currency = 'EUR'
          planetype  =    'A380-800'
          seatsmax =   475
          seatsocc =   458
          paymentsum =   '18944.86'
          seatsmax_b = 30
          seatsocc_b = 30
          seatsmax_f =  20
          seatsocc_f = 20 ) ) ).

  ENDMETHOD.
  METHOD heading.
    output = |\n_________________________________________________________________________________\n\n{ text }\n\n|.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_cds_ve DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES:
      if_oo_adt_classrun.

    CLASS-METHODS class_constructor.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_cds_ve IMPLEMENTATION.


  METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).

    "Some more database table insertions for this particular example
    MODIFY zdemo_abap_carr FROM TABLE @( VALUE #(
        ( carrid = 'SQ'
          carrname = 'Singapore Airlines'
          currcode = 'SGD'
          url =  'http://www.singaporeair.com ' )
        ( carrid = 'QF'
          carrname = 'Qantas Airways'
          currcode = 'AUD'
          url =  'http://www.qantas.com.au' ) ) ).

    MODIFY zdemo_abap_flsch FROM TABLE @( VALUE #(
      ( carrid = 'UA'
        connid =  3517
        countryfr =  'DE'
        cityfrom =  'FRANKFURT'
        airpfrom = 'FRA'
        countryto = 'US'
        cityto = 'NEW YORK'
        airpto = 'JFK'
        fltime = 495
        deptime = '104000'
        arrtime = '125500'
        distance =  6162
        distid = 'KM'
        fltype = ''
        period = 0 ) ) ).

    MODIFY zdemo_abap_fli FROM TABLE @( VALUE #( ( carrid = 'UA' ) ) ).
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: CDS view entities\n\n| ).

    out->write( `1) Operands, expressions and built-in functions ` &&
    |in a CDS view entity\n\n|  ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. All data is retrieved. The sample CDS view entity
    "uses many operands, expressions and built-in functions to demonstrate
    "various syntax options. In addition, the view contains an input
    "parameter that must be provided with an actual parameter and
    "specified in the ABAP SQL SELECT statement.
    "In ADT, check out the CDS view entity by holding down CTRL and clicking
    "on the CDS view entity. This will take you to the artifact. There you
    "can choose F8 to open the data preview.

    SELECT *
      FROM zdemo_abap_cds_ve_sel( p_smax = 20 )
      ORDER BY CarrierId
      INTO TABLE @DATA(select_from_cds).

    out->write( data = select_from_cds name = `select_from_cds` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Aggregate Expressions` ) ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. All data is retrieved. The sample CDS view entity
    "uses aggregate expressions.

    SELECT *
      FROM zdemo_abap_cds_ve_agg_exp
      ORDER BY carrid
      INTO TABLE @DATA(agg_expr).

    out->write( data = agg_expr name = `agg_expr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Joins` ) ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. All data is retrieved. The sample CDS view entity
    "contains multiple joins.
    "The CDS view entity is designed to contain different join variants
    "in one artifact. There, you can comment in/out code sections to
    "check out the individual join variants. Therefore, the result of
    "the following SELECT statement depends on which section you have
    "commented in in the CDS view entity.

    SELECT *
      FROM zdemo_abap_cds_ve_joins
      ORDER BY carrid
      INTO TABLE @DATA(cds_joins).

    out->write( data = cds_joins name = `cds_joins` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Excursion: ABAP SQL and joins` ) ).

    "The following ABAP SQL SELECT statements are intended to reproduce
    "the different joins that are performed by the CDS view entity.
    "Inner, left and right outer, and cross joins are covered. The data
    "sources for the SELECT statements are the database tables.
    "Note:
    "- The prefix ~ is used in the ABAP SQL statements instead of . in
    "  the CDS view entity.
    "- To demonstrate the handling of null values, some SELECT statements
    "  contain the coalesce function and CASE expressions similar to the
    "  CDS view entity.

    out->write( `---------- Inner join ----------` ).
    out->write( |\n| ).
    out->write( |\n| ).

    SELECT _carr~carrid,
           _carr~carrname,
           _flsch_in~cityfrom AS cityfr_in,
           _flsch_in~cityto AS cityto_in
      FROM zdemo_abap_carr AS _carr
      INNER JOIN zdemo_abap_flsch AS _flsch_in
      ON _carr~carrid = _flsch_in~carrid
      ORDER BY _carr~carrid
      INTO TABLE @DATA(sql_inner_join).

    out->write( data = sql_inner_join name = `sql_inner_join` ).

    out->write( |\n| ).
    out->write( `---------- Left outer join ----------` ).
    out->write( |\n| ).
    out->write( |\n| ).

    SELECT _carr~carrid,
           _carr~carrname,
           _flsch_lo~cityfrom AS cityfr_lo,
           coalesce( _flsch_lo~cityto, '???' ) AS cityto_lo
      FROM zdemo_abap_carr AS _carr
      LEFT OUTER JOIN zdemo_abap_flsch AS _flsch_lo
      ON _carr~carrid = _flsch_lo~carrid
      ORDER BY _carr~carrid
      INTO TABLE @DATA(sql_left_outer_join).

    out->write( data = sql_left_outer_join name = `sql_left_outer_join` ).

    out->write( |\n| ).
    out->write( `---------- Right outer join ----------` ).
    out->write( |\n| ).
    out->write( |\n| ).

    SELECT _carr~carrid,
           _carr~carrname,
           CASE WHEN _carr~url IS NOT NULL THEN _carr~url
                ELSE '!!!'
           END AS url_ro,
           _flsch_ro~cityfrom AS cityfr_ro,
           _flsch_ro~cityto AS cityto_ro
      FROM zdemo_abap_carr AS _carr
      RIGHT OUTER JOIN zdemo_abap_flsch AS _flsch_ro
      ON _carr~carrid = _flsch_ro~carrid
      ORDER BY _carr~carrid
      INTO TABLE @DATA(sql_right_outer_join).

    out->write( data = sql_right_outer_join name = `sql_right_outer_join` ).

    out->write( |\n| ).
    out->write( `---------- Cross join ----------` ).
    out->write( |\n| ).
    out->write( |\n| ).

    SELECT _carr~carrid,
           _carr~carrname,
           _flsch_cr~cityfrom AS cityfr_cr,
           _flsch_cr~cityto AS cityto_cr
      FROM zdemo_abap_carr AS _carr
      CROSS JOIN zdemo_abap_flsch AS _flsch_cr
      ORDER BY _carr~carrid
      INTO TABLE @DATA(sql_cross_join).

    out->write( data = sql_cross_join name = `sql_cross_join` ).
    out->write( |\n| ).

    "Just a check what join example is currently commented in
    IF cds_joins = sql_inner_join.

      out->write( `In the example CDS view entity, the inner join example is commented in.` ).

    ELSEIF cds_joins = sql_left_outer_join.

      out->write( `In the example CDS view entity, the left outer join example is commented in.` ).

    ELSEIF cds_joins = sql_right_outer_join.

      out->write( `In the example CDS view entity, the right outer join example is commented in.` ).

    ELSEIF cds_joins = sql_cross_join.

      out->write( `In the example CDS view entity, the cross join example is commented in.` ).

    ELSE.

      out->write( `In the example CDS view entity, there is some other code present.` ).

    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Associations` ) ).

    out->write( |5) Selecting data from a CDS view that contains associations\n\n|  ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. All data is retrieved. The sample CDS view entity
    "contains multiple associations.
    "Some fields of some associations are used in the element list of the
    "CDS view entity. This data is included in the result set. Some
    "associations are exposed but no fields of those associations are
    "included in the element list. Therefore, no join is instantiated on
    "the database and no data from these exposed assocations is included
    "in the result set.

    SELECT *
      FROM zdemo_abap_cds_ve_assoc
      ORDER BY carrier
      INTO TABLE @DATA(assoc).

    out->write( data = assoc name = `assoc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Using exposed associations in ABAP SQL statements: ...` ) ).

    "The following examples use path expressions to access the association
    "targets of exposed associations.

    out->write( |6) ... SELECT clause\n\n|  ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. The statement uses an exposed association.
    "The SELECT list contains fields from the exposed association. Only in
    "this case (when a consumer, such as an ABAP SQL statement, requests
    "data) is the join instantiated on the database.
    "Note:
    "- No attributes are specified for the path expression (attributes
    "  are covered in examples further down). In particular, a join type is
    "  not explicitly specified. In such a case, the join type depends on
    "  the place where the path expression is used. Since the path expression
    "  is used in the SELECT list of an ABAP SQL SELECT statement (where
    "  fields are specified), a LEFT OUTER JOIN is used by default.
    "- The coalesce function is included for a field to handle null values.

    SELECT carrier,
           \_carr3-carrname,
           coalesce( \_carr3-url, '###' ) AS cityto_lo
      FROM zdemo_abap_cds_ve_assoc
      ORDER BY carrier
      INTO TABLE @DATA(assoc_exp_select).

    out->write( data = assoc_exp_select name = `assoc_exp_select` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) ... FROM clause` ) ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. All data is retrieved.
    "In this case, an exposed association is used in the FROM clause.
    "Note:
    "- No join type is explicitly specified. As mentioned above, the
    "  position of the path expression is important. In this case (when
    "  used in the FROM clause), an INNER JOIN is used by default.
    "- You can open the data preview for the CDS view entity used and
    "  compare the result set with the output here. Due to the inner
    "  join, non-existent 'carrid' values in the association target are
    "  not contained in the result set.

    SELECT *
      FROM zdemo_abap_cds_ve_assoc\_carr3 AS _exp
      ORDER BY carrid
      INTO TABLE @DATA(assoc_exp_from).

    out->write( data = assoc_exp_from name = `assoc_exp_from` ).
    out->write( |\n| ).

    "The following ABAP SQL SELECT statement is intended to reproduce
    "the data retrieval as above.
    "The statement uses the same CDS view entity as data source that
    "is used by the CDS view entity above as data source.
    "An inner join is performed on a database table (the _carr3
    "association from above has this table defined as the association
    "target in the CDS view entity) since the inner join is used by
    "default above so as to reproduce the effect. The result set
    "should be the same as above.

    SELECT _carr~mandt,
           _carr~carrid,
           _carr~carrname,
           _carr~currcode,
           _carr~url
      FROM zdemo_abap_cds_ve_assoc_e AS _cds
      JOIN  zdemo_abap_carr AS _carr ON _cds~carrid = _carr~carrid
      ORDER BY _carr~carrid
      INTO TABLE @DATA(sql_repr).

    out->write( data = sql_repr name = `sql_repr` ).
    out->write( |\n| ).

    IF sql_repr = assoc_exp_from.
      out->write( `The result sets are the same.` ).
    ELSE.
      out->write( `The result sets are differrent.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) ... Specifying attributes` ) ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. The statement uses an exposed association.
    "The SELECT list contains a path expression that is specified with
    "an attribute.
    "Note:
    "- Cardinality, join types, and filter conditions can be used as
    "  attributes.
    "- In the example, only the cardinality is specified.
    "- The cardinality can be specified to prevent syntax warnings/errors
    "  in cases where the cardinality of the association does not match
    "  the way it is used in a path expression.
    "- The example does not explicitly specify a join type. As mentioned
    "  above, if not explicitly specified, the join type depends on where
    "  the path expression is used. Here, a column is specified in the
    "  SELECT list. This means that a LEFT OUTER JOIN is used by default.
    "- The result set should contain an entry for 'UA' having an initial
    "  value for 'fldate'.

    SELECT carrid,
           connid,
           cityfrom,
           cityto,
          "Without specifying the cardinality, the following warning
          "occurs: Using association "_FLI" can increase the cardinality
          "of the results set
          "\_fli-fldate AS flightdate

          \_fli[ (*) ]-fldate AS flightdate
          "The specification above corresponds to the following specification
          "that includes an explicit specification of LEFT OUTER
          "\_fli[ (*) LEFT OUTER ]-fldate AS flightdate
       FROM zdemo_abap_cds_ve_assoc_e
       ORDER BY carrid, connid, flightdate
       INTO TABLE @DATA(assoc_attr_card).

    out->write( data = assoc_attr_card name = `assoc_attr_card` ).
    out->write( |\n| ).

    "Specifying the join type explicitly
    "- INNER, LEFT/RIGHT OUTER are possible
    "- The join type can only be specified together with the cardinality.
    "- In the result set of the example, the 'UA' entry should not be
    "  contained.

    SELECT carrid,
           connid,
           cityfrom,
           cityto,
           \_fli[ (*) INNER ]-fldate AS flightdate
      FROM zdemo_abap_cds_ve_assoc_e
      ORDER BY carrid, connid, flightdate
      INTO TABLE @DATA(assoc_attr_joty).

    out->write( data = assoc_attr_joty name = `assoc_attr_joty` ).
    out->write( |\n| ).

    "Specifying conditions
    "- Filter conditions can be specified for the current association
    "- The addition WHERE is optional in cases where the filter condition
    "  is the only attribute specified in the square brackets.
    "- When the association is instantiated as a join, the filter condition
    "  is transformed into an extended condition for the join.
    "- In the example, a specific 'carrid' value is filtered for. LEFT OUTER
    "  is specified as join type explicitly. Not specifying the join type here
    "  has the same effect. The 'fldate' value is only retrieved for 'DL'
    "  entries. The other ones have initial values.

    SELECT carrid,
           connid,
           cityfrom,
           cityto,
           \_fli[ (*) LEFT OUTER WHERE carrid = 'DL' ]-fldate AS flightdate
           "The following has the same effect in this example
           "\_fli[ (*) WHERE carrid = 'DL' ]-fldate as flightdate
      FROM zdemo_abap_cds_ve_assoc_e
      ORDER BY carrid, connid, flightdate
      INTO TABLE @DATA(assoc_attr_where).

    out->write( data = assoc_attr_where name = `assoc_attr_where` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) ... WHERE clause` ) ).

    "The following ABAP SQL SELECT statement uses a CDS view entity as
    "the data source. The statement uses an exposed association.
    "The SELECT list and the WHERE clause contain a path expression.

    SELECT carrid,
           connid,
           countryfr,
           countryto,
           \_carr_exp-carrname
      FROM zdemo_abap_cds_ve_assoc_e
      WHERE \_carr_exp-carrid LIKE 'A_'
      ORDER BY carrid, connid
      INTO TABLE @DATA(assoc_exp_where).

    out->write( data = assoc_exp_where name = `assoc_exp_where` ).

  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_cloud_excursion DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF details_struc,
             name    TYPE string,
             details TYPE string,
           END OF details_struc.

    CLASS-DATA details_tab TYPE TABLE OF details_struc WITH EMPTY KEY.
    CLASS-DATA str TYPE string.
    CLASS-DATA infos TYPE string_table.
    CLASS-METHODS heading IMPORTING text          TYPE string
                          RETURNING VALUE(output) TYPE string.

    "NOTE:
    "The names specified for the following constants are used by several
    "code snippets in the example class. Make sure that you insert suitable
    "values before running the example class.

    "Package name: Use the package name in which you cloned the ABAP cheat sheets,
    "for example, ZABAP_CHEAT_SHEETS.
    CONSTANTS package TYPE sxco_package VALUE 'ZABAP_CHEAT_SHEETS'.

    "The following constants are relevant for the ABAP repository object generation.
    "See the comments in the section further down.
    "Name of the package in which you want to generate the repository objects
    CONSTANTS package4gen TYPE sxco_package VALUE 'ZABAP_CHEAT_SHEETS'.
    "ID of a modifiable transport request
    CONSTANTS tr_req_id TYPE sxco_transport VALUE 'ID0A123456'.
    "Name of the data element to be created
    CONSTANTS gen_dtel TYPE sxco_ad_object_name VALUE 'ZDEMO_ABAP_DTEL'.
    "Name of the domain to be created
    CONSTANTS gen_doma TYPE sxco_ad_object_name VALUE 'ZDEMO_ABAP_STATUS'.
    "Name of the database table to be created
    CONSTANTS gen_tabl TYPE sxco_dbt_object_name VALUE 'ZDEMO_ABAP_BOOK'.
    "To enable the generation, specify "abap_true" for the contant value.
    CONSTANTS generation_ok TYPE abap_bool VALUE abap_false.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_cloud_excursion IMPLEMENTATION.


  METHOD heading.
    output = |\n_________________________________________________________________________________\n\n{ text }\n\n|.
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.
    out->write( |ABAP Cheat Sheet Example: Excursions into ABAP for Cloud Development\n| ).
    out->write( `1) Restrictions in ABAP for Cloud Development` ).
    out->write( |\nYou can check the code of this section by commenting it in and out. Note the comments in the code.| ).
    "The following statements demonstrate a selection of restrictions in ABAP for Cloud Development.
    "It includes (not) released APIs, deprecated and invalid syntax in ABAP for Cloud Development.
    "Comment in the code lines (CTRL + 7) up to BREAK-POINT and check the syntax errors/warnings
    "displayed.

*    "Released DDIC data elements
*    DATA dobj1 TYPE timestampl.
*    DATA dobj2 TYPE land1.
*
*    "Attributes of the accessible type pool ABAP
*    DATA flag TYPE abap_boolean.
*    flag = abap_true.
*
*    "Released table types
*    DATA it1 TYPE string_table.
*    DATA it2 TYPE string_hashed_table.
*    DATA it3 TYPE xstring_table.
*
*    "Released CDS object
*    DATA s1 TYPE i_timezone.
*
*    "Released interface
*    "The if_oo_adt_classrun interface is released, and you can implement it to run an ABAP class.
*    "In ADT, you can do this by choosing F9. To output the content of data objects, you can use
*    "out->write( ... ). in the main method.
*    DATA ref_classrun TYPE REF TO if_oo_adt_classrun.
*
*    "Not released DDIC database table
*    DATA s2 TYPE scarr.
*
*    "Classes
*    "Released class
*    DATA(ixml1) = cl_ixml_core=>create( ).
*    "Not released (API for classic ABAP)
*    DATA(ixml2) = cl_ixml=>create( ).
*
*    "Released APIs from the XCO library
*    "Retrieving the current user date
*    DATA(user_date) = xco_cp=>sy->date( xco_cp_time=>time_zone->user
*                          )->as( xco_cp_time=>format->iso_8601_extended
*                          )->value.
*
*    "Retrieving the current user time
*    DATA(user_time) = xco_cp=>sy->time( xco_cp_time=>time_zone->user
*                          )->as( xco_cp_time=>format->iso_8601_extended
*                          )->value.
*
*    "Not released API: Querying whether the current database supports AMDP methods
*    DATA(amdp_allowed) = xsdbool( cl_abap_dbfeatures=>use_features(
*      EXPORTING requested_features = VALUE #( ( cl_abap_dbfeatures=>call_amdp_method ) ) ) ).
*
*    "ABAP SQL statements
*    "Selecting from a
*    "... not released database table
*    SELECT carrid, connid FROM spfli WHERE carrid = 'LH' INTO TABLE @DATA(spfli_tab).
*
*    "... released CDS view
*    SELECT SINGLE * FROM i_timezone WHERE TimeZoneID = 'EST' INTO @DATA(tz_info).
*
*    "... not released database table using a dynamic ABAP SQL statement
*    "Although the source code provides an invalid data source, the dynamic ABAP SQL statement
*    "does not produce a syntax error during compilation. However, it would result in a runtime
*    "error because you cannot select from that data source. You can check the validity of dynamic
*    "specifications using the `cl_abap_dyn_prg` class, which supports dynamic programming.
*    SELECT SINGLE carrid, connid FROM ('SPFLI') WHERE carrid = 'LH' INTO NEW @DATA(ref_spfli_tab).
*
*    "ABAP SQL Statement involving client handling; using a cheat sheet database table
*    "The addition `USING CLIENT` for client handling is not allowed in the restricted ABAP language scope.
*    DATA(clnt) = sy-mandt.
*    SELECT carrid, connid FROM ('ZDEMO_ABAP_FLI') USING CLIENT @clnt WHERE carrid = 'LH' INTO TABLE NEW @DATA(ref_demo_tab).
*
*    "The example includes a selection of deprecated and invalid syntax in ABAP for Cloud Development. They are added
*    "for demonstration purposes. For example, classic UI technology-related (such as dynpro) syntax is not allowed.
*    "The pointless WRITE statement within the method implementation represents invalid classic list-related statements.
*    "Executable programs (reports) are not allowed in the restricted ABAP language scope. To set breakpoints in ADT,
*    "double-click the area to the left of the code line number.
*
*    "Assignments
*    DATA(num1) = 1.
*    DATA(num2) = 1.
*    DATA(num3) = 2.
*    "Invalid statement for an assignment
*    MOVE num3 TO num1.
*    "Using the assignment operator
*    num2 = num3.
*
*    "Determining the number of lines in an internal table
*    DATA(str_table) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ).
*    DATA(num_lines1) = lines( str_table ).
*    "Invalid statement
*    DESCRIBE TABLE str_table LINES DATA(num_lines2).
*
*    "Getting references
*    DATA: ref1 TYPE REF TO i,
*          ref2 TYPE REF TO i.
*
*    ref1 = REF #( num1 ).
*    "Deprecated statement
*    GET REFERENCE OF num1 INTO ref2.
*
*    "Classic ABAP-related statements and syntax
*    "Various sy components should not be used in ABAP for Cloud Development
*    DATA(current_as_abap_time) = sy-uzeit.
*    DATA(current_as_abap_date) = sy-datum.
*    DATA(current_local_time) = sy-timlo.
*
*    "Various invalid statements
*    DATA scarr_tab TYPE TABLE OF scarr WITH EMPTY KEY.
*    TRY.
*        cl_salv_table=>factory( IMPORTING r_salv_table = DATA(alv)
*                                CHANGING  t_table      = scarr_tab ).
*        "The exception class is not released, too.
*      CATCH cx_salv_msg.
*    ENDTRY.
*
*    DATA code TYPE string_table.
*    READ REPORT 'ZCL_DEMO_ABAP_UNIT_TEST=======CCAU' INTO code.
*    WRITE 'hi'.
*    BREAK-POINT.

**********************************************************************

    out->write( heading( `2) Using released APIs` ) ).
    "The following code uses several released APIs.
    "You can check out Released Objects in the Project Explorer in ADT in
    "ABAP Cloud.

    "In the example, a released API is used to return the current date in UTC.
    "You can use forward navigation by placing the cursor on the class,
    "choosing CTRL and clicking. In the opened class, go to the Properties
    "tab and choose API state to find the release contract for this class.
    DATA(date) = cl_abap_context_info=>get_system_date(  ).
    DATA(current_year) = date(4).
    DATA(up_to_year) = 2050.

    "The statement retrieves the leap years between the current year and
    "the specified year. A released CDS view is used as data source.
    SELECT calendaryear
      FROM i_calendaryear
      WHERE calendaryear BETWEEN @current_year AND @up_to_year
      AND IsLeapYear IS NOT INITIAL
      INTO TABLE @DATA(future_leap_years).

    "To display output, the example class uses a released API. You can implement
    "the interface if_oo_adt_classrun and the main method. The write method displays
    "content in the console when running the class using F9 in ADT.
    out->write( data = future_leap_years name = `future_leap_years` ).

    "Using a released data element
    DATA number TYPE int4.
    number = lines( future_leap_years ).

    out->write( |\nBetween { current_year } and { up_to_year }, there are { number } leap years.| ).

    "Using a released API as data source of a SELECT statement
    "Among others, the month names of specified languages are retrieved in the example.
    "The WHERE clause is specified in a way to only retrieve a selected set of months.
    "For this purpose, more released APIs (classes cl_abap_random_int, cl_abap_random)
    "are used. A minimum of 5 months and a maximum of all months is to be returned.
    DATA(number_of_months) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 5
                                     max = 12 )->get_next( ).

    SELECT CalendarMonth, CalendarMonthName, Language
      FROM i_calendarmonthtext
      WHERE Language IN ( 'E', 'I', 'D' )
      AND CalendarMonth <= @number_of_months
      ORDER BY Language, CalendarMonth
      INTO TABLE @DATA(months).

    "Using a released table type
    DATA string_tab TYPE string_table.

    "Inserting the retrieved data into a table of type string
    LOOP AT months INTO DATA(month_wa).
      APPEND |{ month_wa-CalendarMonth } { month_wa-CalendarMonthName } ({ month_wa-Language })| TO string_tab.
    ENDLOOP.

    "Creating a JSON string from a data object using a released API
    DATA(json_str) = xco_cp_json=>data->from_abap( months )->to_string( ).

    out->write( |\nNumber of months per language: { number_of_months }| ).
    out->write( |\nMonths returned:| ).
    out->write( data = string_tab name = `string_tab` ).
    out->write( |\nMonths returned (JSON string):| ).
    out->write( data = json_str name = `json_str` ).

    "Getting APIs for use in ABAP for Cloud Development
    "The released CDS view contains the relevant information. In the example,
    "the names of released classes are retrieved with a specific name pattern.
    SELECT ReleasedObjectType, ReleasedObjectName, ReleaseState
      FROM i_apisforclouddevelopment
      WHERE releasestate = 'RELEASED'
      AND ReleasedObjectType = 'CLAS'
      AND ReleasedObjectName LIKE 'CL_ABAP_RANDOM_P%'
      INTO TABLE @DATA(rel_cl_abap_random).

    out->write( |\nRead result:| ).
    out->write( data = rel_cl_abap_random name = `rel_cl_abap_random` ).

    "Getting the number of all released classes in the system
    SELECT COUNT(*)
      FROM i_apisforclouddevelopment
      WHERE releasestate = 'RELEASED'
      AND ReleasedObjectType = 'CLAS'
      INTO @DATA(num_rel_cl).

    "Getting the number of all released interfaces in the system
    SELECT COUNT(*)
      FROM i_apisforclouddevelopment
      WHERE releasestate = 'RELEASED'
      AND ReleasedObjectType = 'INTF'
      INTO @DATA(num_rel_intf).

    out->write( |\nThere are { num_rel_cl } released classes and { num_rel_intf } released interfaces in the system.|  ).

**********************************************************************

    out->write( heading( `Excursions into the XCO Library` ) ).
    "The following code snippets focus on the XCO library that provides
    "predefined functionality and can be used in ABAP for Cloud Development.
    "The examples cover a selection of options for you to explore. For more
    "detailed information and more code snippets, see the SAP Help Portal
    "documentation. In most cases, the examples deal with classes and methods
    "for getting information about repository objects.
    "Note:
    "- Due to the many methods and options, method chaining comes in handy.
    "- To further explore the options with the classes and methods, you can
    "  put the cursor behind => or -> and choose CTRL + Space to get input
    "  suggestions.

    out->write( |3) Getting Repository Object-Related Information| ).

    "Getting all accessible repository objects in the system (indicated by the
    "value provided for "in")
    "To further process the returned values, you can loop over them.
    DATA(all_obj) = xco_cp_abap_repository=>objects->all->in( xco_cp_abap=>repository )->get( ).

    out->write( |\nThere are { lines( all_obj ) } accessible repository objects in the system. Note that this number also includes custom artifacts.| ).

**********************************************************************

    "Getting all accessible database tables
    "You can specify concrete artifacts (check CTRL + Space after objects->)
    DATA(all_tables) = xco_cp_abap_repository=>objects->tabl->all->in( xco_cp_abap=>repository )->get( ).

    out->write( |\nThere are { lines( all_tables ) } accessible database tables in the system. Note that this number includes custom database tables.| ).

**********************************************************************

    "Checking the existence of a certain package
    "Note: The value provided for 'for' is specified in the private section
    "      of the class. Use the package name in which you cloned the ABAP
    "      cheat sheets, for example, ZABAP_CHEAT_SHEETS.

    "Creating a handler for the specified package
    "You can create a break point here and check out the content of the variable
    "in the debugger to find out what information is included.
    DATA(package_handle) = xco_cp_abap_repository=>package->for( package ).
    DATA(package_exists) = package_handle->exists( ).
    "Using method chaining, you can retreive the information in one go.
    DATA(package_exists_ch) = xco_cp_abap_repository=>package->for( package )->exists( ).

    IF package_exists IS NOT INITIAL
    AND package_exists_ch IS NOT INITIAL.
      out->write( |\nThe package { package } exists in the system.| ).
    ELSE.
      out->write( |\nThe package { package } does not exist in the system.| ).
    ENDIF.

**********************************************************************

    "Getting more information
    IF package_exists IS NOT INITIAL.
      DATA(package_name) = package_handle->name.
      DATA(software_comp) = package_handle->read( )-property-software_component->name.

      out->write( |\nThe package name is { package_name } (retrieved using the "name" attribute).| ).
      out->write( |\nIts software component is { software_comp }.| ).

      "Getting all repository objects contained in the package
      DATA(all_objs) = xco_cp_abap_repository=>objects->all->in( package_handle )->get( ).

      "Looping over the result for further processing
      "In this example, the name of the repository objects and their types are
      "extracted and inserted in a table for displaying purposes.
      LOOP AT all_objs ASSIGNING FIELD-SYMBOL(<a>).
        APPEND VALUE #( name = <a>->name->value
                        details = <a>->type->value ) TO details_tab.
      ENDLOOP.

      SORT details_tab BY name.

      out->write( |\nThe package { package } includes the following { lines( details_tab ) } repository objects:| ).
      out->write( details_tab ).
    ENDIF.

**********************************************************************

    "Refining the search using a filter and search pattern
    "The search patterns uses a name from the ABAP cheat sheets repository objects.
    DATA(filter1) = xco_cp_abap_repository=>object_name->get_filter(
        xco_cp_abap_sql=>constraint->contains_pattern( 'ZDEMO_ABAP_RAP_R%' ) ).

    "Getting all accessible BDEFs that start with ZDEMO_ABAP_RAP_R in the entire system
    "As shown above, loop over the handler to get more detailed information. You can also set
    "a break point to check out the content of the variable in the debugger.
    IF package_exists = abap_true.
      DATA(bdefs_in_package) = xco_cp_abap_repository=>objects->bdef->where( VALUE #( ( filter1 )
        ) )->in( xco_cp_abap=>repository )->get( ).

      out->write( |\nThere are { lines( bdefs_in_package ) } accessible BDEFs with the specified name pattern in the entire system.| ).
    ENDIF.

    "Getting all accessible interfaces with a particular name pattern in the entire system
    DATA(filter2) = xco_cp_abap_repository=>object_name->get_filter(
      xco_cp_abap_sql=>constraint->contains_pattern( 'IF_ABAP_BEHV%' ) ).

    DATA(all_intfs) = xco_cp_abap_repository=>objects->intf->where( VALUE #( ( filter2 )
      ) )->in( xco_cp_abap=>repository )->get( ).

    out->write( |\nThere are { lines( all_intfs ) } accessible interfaces with the specified name pattern in the entire system.| ).

    "Getting repository objects based on a particular software component
    "In the example, all classes are retrieved that have a particular name pattern
    "and have a particular software component.
    DATA(filter3) = xco_cp_system=>software_component->get_filter( xco_cp_abap_sql=>constraint->equal( 'SAP_BASIS' ) ).
    DATA(filter4) = xco_cp_abap_repository=>object_name->get_filter( xco_cp_abap_sql=>constraint->contains_pattern( '%CL_ABAP_RAND%' ) ).
    DATA(filtered_classes) = xco_cp_abap_repository=>objects->clas->where( VALUE #( ( filter3 ) ( filter4 )
      ) )->in( xco_cp_abap=>repository )->get( ).

    out->write( |\nThere are { lines( filtered_classes ) } accessible classes with the specified name pattern and software component.| ).

**********************************************************************

    out->write( heading( `4) Getting Database Table-Related Information` ) ).

    "Creating a filter with a search pattern
    DATA(pattern) = 'ZDEMO_ABAP_FL%'.
    DATA(filter5) = xco_cp_abap_repository=>object_name->get_filter(
      xco_cp_abap_sql=>constraint->contains_pattern( pattern ) ).

    "Getting all database tables whose names begin with the specified name pattern
    "and that are contained in the package specified above.
    DATA(dbtabs) = xco_cp_abap_repository=>objects->tabl->database_tables->where( VALUE #( ( filter5 )
      ) )->in( package_handle )->get( ).

    IF dbtabs IS NOT INITIAL.

      infos = VALUE #( ( |Information about database tables retrieved using search pattern { pattern }| ) ).
      LOOP AT dbtabs INTO DATA(db).
        "Getting the name of the database table
        DATA(a1_name) = db->name.
        "Getting information about technical properties (selection)
        DATA(a2_content) = db->content( )->get( ).
        DATA(a3_descr) = a2_content-short_description.
        DATA(a4_del_cl) = a2_content-delivery_class->value.
        DATA(a5_data_maint) = a2_content-data_maintenance->if_xco_printable~get_text( )->get_lines( )->join( )->value.
        "Getting all fields of the database table
        "The handler is further processed. In the example, only the field names are retrieved.
        DATA(a6_fields) = db->fields->all->get( ).

        CLEAR str.
        LOOP AT a6_fields INTO DATA(fields).
          str = str && COND #( WHEN sy-tabix <> 1 THEN `, ` ELSE `` ) && fields->name.
        ENDLOOP.

        infos = VALUE #( BASE infos
         ( `*********************************` )
         ( |Db table name: { a1_name }| )
         ( |Description: { a3_descr }| )
         ( |Delivery class: { a4_del_cl }| )
         ( |Data maintenance: { a5_data_maint }| )
         ( |Field names: { str }| ) ).

      ENDLOOP.
      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nNo database tables found.| ).
    ENDIF.

**********************************************************************

    "Getting information about a particular database table
    out->write( |\nInformation about a particular demo database table| ).
    DATA(db_table) = CONV sxco_dbt_object_name( 'ZDEMO_ABAP_CARR' ).
    DATA(b1_handler) = xco_cp_abap_dictionary=>database_table( db_table ).
    DATA(b2_exists) = b1_handler->exists( ).
    IF b2_exists IS NOT INITIAL.
      DATA(b3_name) = b1_handler->name.
      DATA(b4_descr) = b1_handler->content( )->get_short_description( ).
      DATA(b5_del_cl) = b1_handler->content( )->get_delivery_class( )->value.
      DATA(b6_data_maint) = a2_content-data_maintenance->if_xco_printable~get_text( )->get_lines( )->join( )->value.
      DATA(b7_fields) = b1_handler->fields->all->get_names( ).
      DATA(b8_keys) = b1_handler->fields->key->get_names( ).
      DATA(b9_vis) = b1_handler->get_api_state( )->get_visibilities( ).
      DATA(b10_rel_state) = b1_handler->get_api_state( )->get_release_state( )->value.

      CLEAR str.
      "Getting information about the visibility of the repository object
      LOOP AT b9_vis INTO DATA(vis_b).
        CASE abap_true.
          WHEN vis_b->use_in_key_user_apps( ).
            str = |Key user: { vis_b->use_in_key_user_apps( ) }|.
          WHEN vis_b->use_in_sap_cloud_platform( ).
            str = str && | Cloud: { vis_b->use_in_sap_cloud_platform( ) }|.
        ENDCASE.
      ENDLOOP.

      infos = VALUE #(
       ( |Information about database table { db_table }| )
       ( `*********************************` )
       ( |Db table name: { b3_name }| )
       ( |Description: { b4_descr }| )
       ( |Delivery class: { b5_del_cl }| )
       ( |Data maintenance: { b6_data_maint }| )
       ( |Visibilities: { COND #( WHEN str IS INITIAL THEN `None` ELSE str ) }| )
       ( |Release state: { b10_rel_state }| )
       ( |Field names: { concat_lines_of( table = b7_fields sep = `, ` ) }| )
       ( |Key fields: { concat_lines_of( table = b8_keys sep = `, ` ) }| )
       ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe database table { db_table } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( |\nInformation about a particular database table field| ).

    IF b2_exists IS NOT INITIAL.
      db_table = 'ZDEMO_ABAP_CARR'.
      DATA(db_field) = CONV sxco_ad_field_name( 'CARRID' ).
      DATA(c1_handler) = xco_cp_abap_dictionary=>database_table( db_table )->field( db_field )->content( ).

      "Getting attributes of the field
      DATA(c2_field_attributes) = c1_handler->get( ).
      DATA(c3_is_key) = c2_field_attributes-key_indicator.
      DATA(c4_is_not_null) = c2_field_attributes-not_null.
      "You can get the information also using a different way, as shown below.
      DATA(c5_built_in_t) = c2_field_attributes-type->get_built_in_type( )->abap_type->get_type_descriptor( )->type_kind.
      "Getting information using the handler created initially and for getting attributes individually.
      DATA(c6_field_name) = c1_handler->field->name.
      DATA(c7_db_name) = c1_handler->field->database_table->name.
      DATA(c8_is_key) = c1_handler->get_key_indicator( ).
      "You may want to check the details for the following variable in the debugger.
      DATA(c9_type_handler) = c1_handler->get_type( ).
      DATA(c10_built_in_t) = c9_type_handler->get_built_in_type( )->abap_type->get_type_descriptor( )->type_kind.
      DATA(c11_type_outp_len) = c9_type_handler->get_built_in_type( )->abap_type->get_type_descriptor( )->output_length.
      DATA(c12_type_abs_name) = c9_type_handler->get_built_in_type( )->abap_type->get_type_descriptor( )->absolute_name.

      infos = VALUE #(
           ( |Information about field { db_field } in database table { db_table }| )
           ( `*********************************` )
           ( |Field name: { c6_field_name }| )
           ( |Db table name: { c7_db_name }| )
           ( |Is key field: { c3_is_key } (Alternative retrieval: { c8_is_key })| )
           ( |Is not null: { c4_is_not_null }| )
           ( |Built-in type of field: { c5_built_in_t } (Alternative retrieval: { c10_built_in_t })| )
           ( |Output length: { c11_type_outp_len }| )
           ( |Absolute name of type: { c12_type_abs_name }| ) ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe database table { db_table } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `5) Getting Data Element-Related Information` ) ).

    "Getting information about a released data element
    DATA(dtel) = CONV sxco_ad_object_name( 'MANDT' ).
    DATA(d1_handler) = xco_cp_abap_dictionary=>data_element( dtel ).
    DATA(d2_exists) = d1_handler->exists( ).
    IF d2_exists IS NOT INITIAL.
      DATA(d3_name) = d1_handler->name.
      DATA(d4_vis) = d1_handler->get_api_state( )->get_visibilities( ).
      DATA(d5_rel_state) = d1_handler->get_api_state( )->get_release_state( )->value.
      DATA(d6_descr) = d1_handler->content( )->get_short_description( ).
      DATA(d7_built_in_t) = d1_handler->content( )->get_underlying_built_in_type( )->abap_type->get_type_descriptor( )->type_kind.
      DATA(d8_type_outp_len) = d1_handler->content( )->get_underlying_built_in_type( )->abap_type->get_type_descriptor( )->output_length.

      CLEAR str.
      "Processing visibility information
      LOOP AT d4_vis INTO DATA(vis_d).
        CASE abap_true.
          WHEN vis_d->use_in_key_user_apps( ).
            str = |Key user: { vis_d->use_in_key_user_apps( ) }|.
          WHEN vis_d->use_in_sap_cloud_platform( ).
            str = str && | Cloud: { vis_d->use_in_sap_cloud_platform( ) }|.
        ENDCASE.
      ENDLOOP.

      infos = VALUE #(
         ( |Information about data element { dtel }| )
         ( `*********************************` )
         ( |Data element name: { d3_name }| )
         ( |Short description: { d6_descr }| )
         ( |Visibilities: { COND #( WHEN str IS INITIAL THEN `None` ELSE str ) }| )
         ( |Release state: { d5_rel_state }| )
         ( |Built-in type: { d7_built_in_t }| )
         ( |Output length: { d8_type_outp_len }| ) ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe data element { dtel } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `6) Getting Table Type-Related Information` ) ).

    DATA(tab_type) = CONV sxco_ad_object_name( 'STRING_TABLE' ).
    DATA(e1_handler) = xco_cp_abap_dictionary=>table_type( tab_type ).
    DATA(e2_exists) = e1_handler->exists( ).
    IF e2_exists IS NOT INITIAL.
      DATA(e3_name) = e1_handler->name.
      DATA(e4_vis) = e1_handler->get_api_state( )->get_visibilities( ).
      DATA(e5_rel_state) = e1_handler->get_api_state( )->get_release_state( )->value.
      DATA(e6_descr) = e1_handler->content( )->get_short_description( ).
      DATA(e7_tab_key) = e1_handler->content( )->get_primary_key( )->key_definition->value.
      DATA(e8_tab_key) = e1_handler->content( )->get_primary_key( )->key_definition->if_xco_printable~get_text( )->get_lines( )->join( )->value.
      DATA(e9_type_abs_name) = e1_handler->content( )->get_row_type( )->get_built_in_type( )->abap_type->get_type_descriptor( )->absolute_name.

      CLEAR str.
      "Processing visibility information
      LOOP AT e4_vis INTO DATA(vis_e).
        CASE abap_true.
          WHEN vis_e->use_in_key_user_apps( ).
            str = |Key user: { vis_e->use_in_key_user_apps( ) }|.
          WHEN vis_e->use_in_sap_cloud_platform( ).
            str = str && | Cloud: { vis_e->use_in_sap_cloud_platform( ) }|.
        ENDCASE.
      ENDLOOP.

      infos = VALUE #(
         ( |Information about table type { tab_type }| )
         ( `*********************************` )
         ( |Table type name: { e3_name }| )
         ( |Short description: { e6_descr }| )
         ( |Visibilities: { COND #( WHEN str IS INITIAL THEN `None` ELSE str ) }| )
         ( |Release state: { e5_rel_state }| )
         ( |Table key: { e7_tab_key } (i.e. { e8_tab_key })| )
         ( |Absolute type name of underlying built-in type: { e9_type_abs_name }| ) ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe table type { tab_type } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `7) Getting CDS View Entity-Related Information` ) ).

    DATA(cds) = CONV sxco_cds_object_name( 'ZDEMO_ABAP_CDS_VE_ASSOC' ).
    DATA(f1_handler) = xco_cp_cds=>view_entity( cds ).
    DATA(f2_exists) = f1_handler->exists( ).
    IF f2_exists IS NOT INITIAL.
      DATA(f3_name) = f1_handler->name.
      "You may want to check the details for the following variable in the debugger.
      DATA(f4_content) = f1_handler->content( )->get( ).
      "Fields of the CDS view entity
      DATA(f5_field_handler) = f1_handler->fields->all->get( ).
      DATA(f6_get_field_names) = f1_handler->fields->all->get_names( ).
      DATA(f7_field_names) = concat_lines_of( table = f6_get_field_names sep = `, ` ).

      CLEAR infos.
      "Getting field information using the field handler
      LOOP AT f5_field_handler INTO DATA(cds_field).
        DATA(f8_field_name) = cds_field->name.
        APPEND f8_field_name TO infos.
        "The demo CDS view entity does not have much included for displaying purposes.
        "Therefore, you may create a break point here and check the variable content in
        "the debugger for various pieces of information that are accessible.
        DATA(f9_field_content) = cds_field->content( )->get( ).
      ENDLOOP.

      DATA(f10_field_names) = concat_lines_of( table = infos sep = `, ` ).

      "Getting the associations of the view entity
      DATA(f11_assoc) = f1_handler->associations->all->get( ).

      CLEAR infos.
      LOOP AT f11_assoc INTO DATA(assoc).
        DATA(f12_assoc_name) = assoc->name.
        APPEND f12_assoc_name TO infos.
        "You may want to check the details for the following variable in the debugger.
        DATA(f13_assoc_details) = assoc->content( )->get( ).
      ENDLOOP.

      DATA(f14_assocs) = concat_lines_of( table = infos sep = `, ` ).

      infos = VALUE #(
         ( |Information about CDS view entity { cds }| )
         ( `*********************************` )
         ( |CDS view entity name: { f3_name }| )
         ( |Field names: { f7_field_names }| )
         ( |Alternative field name retrieval: { f10_field_names }| )
         ( |Association names: { f14_assocs }| ) ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe CDS view entity { cds } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( |\nCDS View Entity Example with Parameters| ).

    cds = 'ZDEMO_ABAP_CDS_VE_SEL'.
    DATA(g1_handler) = xco_cp_cds=>view_entity( cds ).
    DATA(g2_exists) = g1_handler->exists( ).
    IF g2_exists IS NOT INITIAL.
      DATA(g3_name) = g1_handler->name.

      "Getting parameters
      DATA(g4_params) = g1_handler->parameters->all->get( ).
      LOOP AT g4_params INTO DATA(param).
        DATA(g5_param_name) = param->content( )->get_original_name( ).
        DATA(g6_param_built_in_type) = param->content( )->get_data_type( )->is_built_in_type( ).
        IF g6_param_built_in_type IS NOT INITIAL.
          DATA(g7_type_abs_name) = param->content( )->get_data_type( )->get_built_in_type( )->abap_type->get_type_descriptor( )->absolute_name.
        ENDIF.
        APPEND |{ g5_param_name } { COND #( WHEN g6_param_built_in_type IS NOT INITIAL THEN `(Absolute type name: ` && g7_type_abs_name && `)` ELSE `` ) } | TO infos.
      ENDLOOP.

      DATA(g8_all_params) = concat_lines_of( table = infos sep = `, ` ).

      infos = VALUE #(
       ( |Information about CDS view entity { cds }| )
       ( `*********************************` )
       ( |CDS view entity name: { g3_name }| )
       ( |Parameter: { g8_all_params }| ) ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe CDS view entity { cds } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( |\nCDS View Entity Example with Compositions| ).

    cds = 'ZDEMO_ABAP_RAP_RO_M'.
    DATA(h1_handler) = xco_cp_cds=>view_entity( cds ).
    DATA(h2_exists) = h1_handler->exists( ).
    IF h2_exists IS NOT INITIAL.
      DATA(h3_name) = h1_handler->name.

      DATA(h4_comps) = h1_handler->compositions->all->get( ).
      LOOP AT h4_comps INTO DATA(comp).

        DATA(h5_entity_name) = comp->entity->name.
        DATA(h6_fields) = comp->entity->fields->all->get_names( ).
        DATA(h7_target_name) = comp->target.
        DATA(h8_cardinality_max) = comp->content( )->get( )-cardinality-max.
        DATA(h9_cardinality_min) = comp->content( )->get( )-cardinality-min.
        DATA(h10_alias) = comp->content( )->get( )-alias.

        APPEND |Entity: { h5_entity_name } Fields: { concat_lines_of( table = h6_fields sep = `, ` ) } | &&
        |Target: { h7_target_name } Cardinality: Min { h9_cardinality_min } Max { h8_cardinality_max } | &&
        |Alias: { h10_alias } | TO infos.
      ENDLOOP.

      DATA(h11_comps) = concat_lines_of( table = infos sep = `, ` ).

      infos = VALUE #(
       ( |Information about CDS view entity { cds }| )
       ( `*********************************` )
       ( |CDS view entity name: { h3_name }| )
       ( |Compositions: { h11_comps }| ) ).

      out->write( infos ).
      CLEAR infos.
    ELSE.
      out->write( |\nThe CDS view entity { cds } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `8) Getting Interface-Related Information` ) ).

    "Getting a list of all implementations of a given interface
    DATA(intf) = CONV sxco_ao_object_name( 'ZDEMO_ABAP_OBJECTS_INTERFACE' ).
    DATA(i1_handler) = xco_cp_abap=>interface( intf ).
    DATA(i2_exist) = i1_handler->exists( ).
    IF i2_exist IS NOT INITIAL.
      DATA(i3_name) = i1_handler->name.

      "Getting static data object declarations
      DATA(i4_stat_dobj) = i1_handler->components->class_data->all->get( ).

      CLEAR str.
      LOOP AT i4_stat_dobj INTO DATA(do).
        str = str && COND #( WHEN sy-tabix <> 1 THEN `, ` ELSE ``  ) && do->name.
      ENDLOOP.

      DATA(i5_stat_dobjs) = str.
      CLEAR str.

      "Getting instance methods
      DATA(i5_in_meth) = i1_handler->components->method->all->get( ).
      LOOP AT i5_in_meth INTO DATA(imeth).
        DATA(i6_in_meth_name) = imeth->name.

        str = str && COND #( WHEN sy-tabix <> 1 THEN ` / ` ELSE ``  ) && imeth->name.

        "Getting formal parameter names using get_names
        DATA(params) = imeth->parameters->all->get_names( ).

        "Getting formal parameters
        DATA(i7_formal_params) = imeth->parameters->all->get( ).
        DATA i8_p TYPE string.
        LOOP AT i7_formal_params INTO DATA(p).
          DATA(i9_pname) = p->name.
          DATA(i10_ptype) = p->content( )->get_kind( )->if_xco_printable~get_text( )->get_lines( )->join( )->value.
          APPEND |{ i9_pname } ({ i10_ptype })| TO infos.
        ENDLOOP.

        str = |{ str } (Parameters: { concat_lines_of( table = infos sep = ` ` ) })|.
        CLEAR infos.
      ENDLOOP.

      "Getting information about where the interface is implemented
      "You may want to check the details for the following variable in the debugger.
      DATA(i11_intf_impl_get) = i1_handler->implementations->all->get( ).
      DATA(i11_intf_impl_names) = i1_handler->implementations->all->get_names( ).

      infos = VALUE #(
       ( |Information about interface { intf }| )
       ( `*********************************` )
       ( |Interface name: { i3_name }| )
       ( |Static data objects (CLASS-DATA) in interface: { i5_stat_dobjs }| )
       ( |Instance methods (METHODS) in interface: { str }| )
       ( |Implementations of the interface exist here: { concat_lines_of( table = i11_intf_impl_names sep = `, ` ) }| ) ).

      out->write( infos ).
      CLEAR: infos, str.
    ELSE.
      out->write( |\nThe interface { intf } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `9) Getting Class-Related Information` ) ).

    DATA(cl) = CONV sxco_ao_object_name( 'ZCL_DEMO_ABAP_UNIT_TEST' ).
    DATA(j1_handler) = xco_cp_abap=>class( cl ).
    DATA(j2_exists) = j1_handler->exists( ).
    IF j2_exists IS NOT INITIAL.
      DATA(j3_name) = j1_handler->name.
      "Accessing definition part
      "You may want to check the details for the following variable in the debugger.
      DATA(j4_name) = j1_handler->definition->content( )->get( ).
      "Getting instance methods in the private visibility section
      DATA(j5_in_meth_priv) = j1_handler->definition->section-private->components->method->all->get( ).

      CLEAR details_tab.
      LOOP AT j5_in_meth_priv INTO DATA(in_meth_priv).
        DATA(j6_in_meth_priv_name) = in_meth_priv->name.
        APPEND VALUE #( name = j6_in_meth_priv_name ) TO details_tab.
        "Getting formal paramter information
        DATA(j7_params) = in_meth_priv->parameters->all->get( ).
        DATA j8_form_param TYPE string.
        CLEAR j8_form_param.
        LOOP AT j7_params INTO DATA(par).
          DATA(j9_par_name) = par->name.
          DATA(j10_par_kind) = par->content( )->get_kind( )->if_xco_printable~get_text( )->get_lines( )->join( )->value.
          DATA(j11_par_type) = par->content( )->get_typing_definition( )->get_value( ).
          j8_form_param = j8_form_param && |{ j9_par_name } (Kind: { j10_par_kind }, Type: { j11_par_type }) / |.
        ENDLOOP.
        REPLACE PCRE `/\s$` IN j8_form_param WITH ``.
        details_tab[ name = j6_in_meth_priv_name ]-details = j8_form_param.
      ENDLOOP.

      "Accessing impementation part of a particular method and getting source code
      DATA(method_name) = CONV  sxco_clas_method_name( 'CLASS_CONSTRUCTOR' ).
      DATA(j12_method_content) = j1_handler->implementation->method( method_name )->content( )->get( ).

      DATA(j13_method_source_code) = xco_cp=>strings( j12_method_content-source
        )->join( |{ cl_abap_char_utilities=>cr_lf }|
        )->value.

      "Getting the source code using the get_source method
      "You may want to check the details for the following variable in the debugger.
      DATA(j14_get_source) = j1_handler->implementation->method( 'IF_OO_ADT_CLASSRUN~MAIN' )->content( )->get_source( ).
      DATA(j15_method_source_code_b) = xco_cp=>strings( j14_get_source
           )->join( |{ cl_abap_char_utilities=>cr_lf }|
           )->value.

      out->write( |Information about class { cl }| ).
      out->write( |\nInstance methods and their formal parameters| ).
      out->write( details_tab ).
      CLEAR details_tab.
      out->write( |\nSource code of implementation part of method { method_name }| ).
      out->write( j13_method_source_code ).
    ELSE.
      out->write( |\nThe class { cl } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( |\nGetting Subclasses| ).

    cl = 'CL_ABAP_TYPEDESCR'.
    DATA(k1_handler) = xco_cp_abap=>class( cl ).
    DATA(k2_exists) = k1_handler->exists( ).
    IF k2_exists = abap_true.
      "You may want to check the details for the following variable in the debugger.
      DATA(k3_get_subclasses) = k1_handler->subclasses->all->get( ).
      "Getting the names of the subclasses
      DATA(k4_subclass_names) = k1_handler->subclasses->all->get_names( ).

      out->write( data = k4_subclass_names name = `k4_subclass_names` ).
    ELSE.
      out->write( |\nThe class { cl } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `10) Getting AMDP-Related Information` ) ).

    cl = 'ZCL_DEMO_ABAP_AMDP'.
    method_name = 'SELECT_GET_CARR_FLI'.
    DATA(l1_handler) = xco_cp_abap=>class( cl ).
    DATA(l2_exists) = l1_handler->exists( ).
    IF l2_exists IS NOT INITIAL.
      DATA(l3_name) = l1_handler->name.
      "Getting content of the method
      DATA(l4_content) = l1_handler->implementation->method( method_name )->content( )->get( ).
      DATA(l5_db_type) = l4_content-amdp-database_type->if_xco_abap_token~get_source( ).
      DATA(l6_db_lang) = l4_content-amdp-database_language->if_xco_abap_token~get_source( ).
      IF l4_content-amdp-database_options IS NOT INITIAL.
        DATA(l4_db_opt) = l4_content-amdp-database_options[ 1 ]->if_xco_abap_token~get_source( ).
      ENDIF.

      CLEAR str.
      LOOP AT l4_content-amdp-database_entities INTO DATA(amdp_ent).
        str = str && ` ` && amdp_ent->if_xco_printable~get_text( )->get_lines( )->join( )->value.
      ENDLOOP.

      DATA(l5_method_source_code) = l4_content-source.
      DATA(l6_meth_source_code) = xco_cp=>strings( l5_method_source_code )->join( |{ cl_abap_char_utilities=>cr_lf }| )->value.

      infos = VALUE #(
       ( |Information about AMDP class { cl }| )
       ( `*********************************` )
       ( |Class name: { l3_name }| )
       ( |Db type: { l5_db_type }| )
       ( |Db language: { l6_db_lang }| )
       ( |Db options: { l4_db_opt }| )
       ( |Db entities: { str }| ) ).

      out->write( infos ).
      CLEAR: infos, str.
      out->write( |\nSource code of implementation part of method { method_name }| ).
      out->write( l6_meth_source_code ).
    ELSE.
      out->write( |\nThe interface { intf } does not exist.| ).
    ENDIF.

**********************************************************************

    out->write( heading( `11) Getting Date and Time Information Using XCO` ) ).
    "Among others, the examples cover time and date-related information.

    "Creating a time stamp
    DATA(m_moment) = xco_cp_time=>moment(
      iv_year   = '2024'
      iv_month  = '01'
      iv_day    = '01'
      iv_hour   = '12'
      iv_minute = '34'
      iv_second = '55' ).

    "Getting user time zone
    DATA(m1_user_time_zone) = xco_cp_time=>time_zone->user->value.
    "Result is of type string
    DATA(m2_moment_string) = m_moment->as( xco_cp_time=>format->abap )->value.
    "Result of type string using other formatting
    DATA(m3_moment_format_a) = m_moment->as( xco_cp_time=>format->iso_8601_basic )->value.
    DATA(m4_moment_format_b) = m_moment->as( xco_cp_time=>format->iso_8601_extended )->value.
    "Current moment in the time zone of the current user
    DATA(m5_cur_moment4user) = xco_cp=>sy->moment( xco_cp_time=>time_zone->user )->as( xco_cp_time=>format->iso_8601_extended )->value.
    "Current moment in UTC
    DATA(m6_cur_moment_utc) = xco_cp=>sy->moment( xco_cp_time=>time_zone->utc )->as( xco_cp_time=>format->iso_8601_extended )->value.
    "Current UNIX timestamp
    DATA(m7_unix_tstmp) = xco_cp=>sy->unix_timestamp( )->value.
    "For the time, you can also use the TIME method
    DATA(m8_time) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->as( xco_cp_time=>format->iso_8601_extended )->value.
    "Getting second, minute, hour information
    DATA(m9_seconds) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->second.
    DATA(m10_minutes) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->minute.
    DATA(m11_hours) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->hour.
    "Calculations
    DATA(m12_add_time) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->add( iv_hour = 1 iv_minute = 1 iv_second = 1 )->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(m13_subtract_time) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->subtract( iv_hour = 1 iv_minute = 1 iv_second = 1 )->as( xco_cp_time=>format->iso_8601_extended )->value.
    "Dates
    DATA(m14_date) = xco_cp=>sy->date( )->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(m15_day) = xco_cp=>sy->date( )->day.
    DATA(m16_month) = xco_cp=>sy->date( )->month.
    DATA(m17_year) = xco_cp=>sy->date( )->year.
    "Calculations
    DATA(m18_add_date) = xco_cp=>sy->date( )->add( iv_day = 1 iv_month = 1 iv_year = 1 )->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(m19_subtract_date) = xco_cp=>sy->date( )->subtract( iv_day = 1 iv_month = 1 iv_year = 1 )->as( xco_cp_time=>format->iso_8601_extended )->value.
    "You can also get more pieces of information using "sy" such as the technical name of your user (see also the class cl_abap_context_info)
    DATA(m20_user_name) = xco_cp=>sy->user( )->name.

    out->write( data = m1_user_time_zone name = `m1_user_time_zone` ).
    out->write( |\n| ).
    out->write( data = m2_moment_string name = `m2_moment_string` ).
    out->write( |\n| ).
    out->write( data = m3_moment_format_a name = `m3_moment_format_a` ).
    out->write( |\n| ).
    out->write( data = m4_moment_format_b name = `m4_moment_format_b` ).
    out->write( |\n| ).
    out->write( data = m5_cur_moment4user name = `m5_cur_moment4user` ).
    out->write( |\n| ).
    out->write( data = m6_cur_moment_utc name = `m6_cur_moment_utc` ).
    out->write( |\n| ).
    out->write( data = m7_unix_tstmp name = `m7_unix_tstmp` ).
    out->write( |\n| ).
    out->write( data = m8_time name = `m8_time` ).
    out->write( |\n| ).
    out->write( data = m9_seconds name = `m9_seconds` ).
    out->write( |\n| ).
    out->write( data = m10_minutes name = `m10_minutes` ).
    out->write( |\n| ).
    out->write( data = m11_hours name = `m11_hours` ).
    out->write( |\n| ).
    out->write( data = m12_add_time name = `m12_add_time` ).
    out->write( |\n| ).
    out->write( data = m13_subtract_time name = `m13_subtract_time` ).
    out->write( |\n| ).
    out->write( data = m14_date name = `m14_date` ).
    out->write( |\n| ).
    out->write( data = m15_day name = `m15_day` ).
    out->write( |\n| ).
    out->write( data = m16_month name = `m16_month` ).
    out->write( |\n| ).
    out->write( data = m17_year name = `m17_year` ).
    out->write( |\n| ).
    out->write( data = m18_add_date name = `m18_add_date` ).
    out->write( |\n| ).
    out->write( data = m19_subtract_date name = `m19_subtract_date` ).
    out->write( |\n| ).
    out->write( data = m20_user_name name = `m20_user_name` ).

**********************************************************************

    out->write( heading( `12) Generating Repository Objects Using XCO` ) ).
    "The example covers the generation of a domain, data element and a
    "database table using XCO.
    "NOTE:
    "To carry out the object generation, make sure that you meet the following
    "prerequisites:
    "1) You have a modifiable transport request (suitable for demo content). In
    "   ADT, go to the Transport Organizer tab, check that you have a transport
    "   request available under "Modifiable". Otherwise, create a new transport
    "   request.
    "   Copy the ID of the transport request and insert it in the constant "tr_req_id"
    "   that is available in the private visibility section of the class.
    "
    "2) You have specified a package for demo content, for example, the
    "   package of the ABAP cheat sheets, which is "ZABAP_CHEAT_SHEETS" in the example.
    "   Make sure that you have assigned the constant "package4gen" a value
    "   with a valid package in which you want to create the demo repository
    "   objects.
    "
    "3) You have provided suitable names for the demo objects. Check and, if need be,
    "   change the constant values for gen_dtel, gen_doma, gen_tabl.
    "
    "4) To enable the generation, assign the constant "generation_ok" the value
    "   "abap_true".
    "
    "The generation of the objects is only carried out if all of the mentioned
    "prerequisites are met.

    "Checking validity of the specified transport request ID
    TRY.
        DATA(n1_handler) = xco_cp_cts=>transport->for( tr_req_id ).
        DATA(n2_exists) = n1_handler->exists( ).
        DATA(n3_status) = n1_handler->get_status( ).
      CATCH cx_root INTO DATA(e).
    ENDTRY.

    "Checking if repository objects with the names specified already exist in the system
    DATA(n6_exists_tabl) = xco_cp_abap_dictionary=>database_table( gen_tabl  )->exists( ).
    DATA(n7_exists_dtel) = xco_cp_abap_dictionary=>data_element( gen_dtel )->exists( ).
    DATA(n8_exists_doma) = xco_cp_abap_dictionary=>domain( gen_doma )->exists( ).

    CASE abap_true.
      WHEN n6_exists_tabl.
        DATA(flag) = abap_true.
      WHEN n7_exists_dtel.
        flag = abap_true.
      WHEN n8_exists_doma.
        flag = abap_true.
      WHEN OTHERS.
    ENDCASE.

    "Checking if package exists
    DATA(n9_exists_devc) = xco_cp_abap_repository=>package->for( package4gen )->exists( ).

    IF n2_exists IS NOT INITIAL
    AND n3_status = xco_cp_transport=>status->modifiable
    AND flag IS INITIAL
    AND n9_exists_devc = abap_true
    AND generation_ok = abap_true.

      DATA(n10_handler) = xco_cp_generation=>environment->dev_system( tr_req_id ).
      DATA(n11_put) = n10_handler->create_put_operation( ).

**********************************************************************
      "Domain
      DATA(n12_doma_spec) = n11_put->for-doma->add_object( gen_doma
        )->set_package( package4gen
        )->create_form_specification( ).
      n12_doma_spec->set_short_description( 'Demo domain' ).
      n12_doma_spec->set_format( xco_cp_abap_dictionary=>built_in_type->char( 10 ) ).
      n12_doma_spec->fixed_values->add_fixed_value( 'BOOKED'
        )->set_description( 'Booked' ).
      n12_doma_spec->fixed_values->add_fixed_value( 'CANCELED'
        )->set_description( 'Canceled' ).
**********************************************************************
      "Data element
      DATA(n13_dtel_spec) = n11_put->for-dtel->add_object( gen_dtel
        )->set_package( package4gen
        )->create_form_specification( ).
      n13_dtel_spec->set_short_description( 'Booking status' ).

      n13_dtel_spec->set_data_type( xco_cp_abap_dictionary=>domain( gen_doma ) ).
***********************************************************************
      "Database table
      DATA(n14_tabl_spec) = n11_put->for-tabl-for-database_table->add_object( gen_tabl
        )->set_package( package4gen
        )->create_form_specification( ).
      n14_tabl_spec->set_short_description( 'Booking request'
        )->set_delivery_class( xco_cp_database_table=>delivery_class->a
        )->set_data_maintenance( xco_cp_database_table=>data_maintenance->allowed ).
      n14_tabl_spec->add_field( 'CLIENT' )->set_type( xco_cp_abap_dictionary=>built_in_type->clnt
        )->set_key_indicator(
        )->set_not_null( ).
      n14_tabl_spec->add_field( 'ID' )->set_type( xco_cp_abap_dictionary=>built_in_type->char( 30 )
        )->set_key_indicator(
        )->set_not_null( ).
      "Using built-in ABAP types
      n14_tabl_spec->add_field( 'FROM_DATE' )->set_type( xco_cp_abap_dictionary=>built_in_type->dats ).
      n14_tabl_spec->add_field( 'TO_DATE' )->set_type( xco_cp_abap_dictionary=>built_in_type->dats ).
      "Using the created data element
      n14_tabl_spec->add_field( 'STATUS' )->set_type( xco_cp_abap_dictionary=>data_element( gen_dtel ) ).
      "Using a released data element
      n14_tabl_spec->add_field( 'USER_NAME' )->set_type( xco_cp_abap_dictionary=>data_element( 'SYUNAME' ) ).
**********************************************************************
      "Executing the generation
      TRY.
          n11_put->execute( ).
          out->write( `Generation successful. Check out the newly created repository objects in the Project Explorer. Refresh the target package.` ).
        CATCH cx_xco_gen_put_exception INTO DATA(err).
          out->write( err->get_text( ) ).
      ENDTRY.

    ELSE.
      CLEAR details_tab.
      out->write( `The following information is displayed if the generation has not been carried out. Before generating the ` &&
      `repository objects, all of the following prerequisites must be met.` ).
      details_tab = VALUE #(
      ( name = `Transport request` details = `n2_exists: "` && n2_exists && `" / The value for "n2_exists" should be "X". ` &&
      `Otherwise, it indicates that the transport request does not exist. In that case, provide a suitable transport ` &&
      `request ID for the constant in the private section.` )
      ( name = `Modifiable transport request` details = COND #( WHEN e IS INITIAL THEN `n3_status: "` && n3_status->value &&
      `" / The value for "n3_status" should be "` && xco_cp_transport=>status->modifiable->value &&
      `". Otherwise, it indicates that the transport request is not modifiable. In that case, provide a suitable transport ` &&
      `request ID for the constant in the private section.` ELSE `There is an issue with the transport request ID provided: ` &&
      e->get_text( ) ) )
      ( name = `Package` details = `n9_exists_devc: "` && n9_exists_devc && `" / The value for "n9_exists_devc" should be "X". ` &&
      `Otherwise, it indicates that the package name as specified does not exist in the system. In that case, provide an ` &&
      `existing package name for the constant in the private section.` )
      ( name = `Repository object names` details = `flag: "` && flag && `" / The value for "flag" should be "" (initial). Otherwise, ` &&
      `it indicates that one or more artifacts with the same names as provided already exist in the system. In that case, ` &&
      `provide other names.` )
      ( name = `generation_ok flag` details = `generation_ok: "` && generation_ok && `" / The value for generation_ok should ` &&
      `be "X". Otherwise, it indicates that the execution of the generation is disabled. In that case, change the value of the constant ` &&
      `in the private section to "abap_true" to carry out the generation.` ) ).
      out->write( details_tab ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_constructor_expr DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF line1,
             col1 TYPE i,
             col2 TYPE i,
           END OF line1,
           BEGIN OF line2,
             col2 TYPE i,
             col3 TYPE i,
             col4 TYPE i,
           END OF line2,
           BEGIN OF s1_type,
             comp1 TYPE c LENGTH 1,
             comp2 TYPE string,
             comp3 TYPE i,
           END OF s1_type,
           BEGIN OF s2_type,
             comp1 TYPE string,
             comp2 TYPE c LENGTH 1,
             comp3 TYPE i,
             comp4 TYPE i,
           END OF s2_type.

    CLASS-DATA:
      "Deep structures as examples to demonstrate the CORRESPONDING operator
      BEGIN OF struc1,
        comp1 TYPE c LENGTH 1 VALUE 'W',
        BEGIN OF struc_nested,
          comp1 TYPE c LENGTH 1 VALUE 'X',
          BEGIN OF comp2,
            col1 TYPE c LENGTH 1 VALUE 'Y',
            col2 TYPE c LENGTH 1 VALUE 'Z',
          END OF comp2,
        END OF struc_nested,
        itab  TYPE TABLE OF line1 WITH EMPTY KEY,
      END OF struc1,
      BEGIN OF struc2,
        BEGIN OF struc_nested,
          comp1 TYPE string,
          comp2 TYPE string,
          comp3 TYPE string,
        END OF struc_nested,
        itab  TYPE TABLE OF line2 WITH EMPTY KEY,
        comp4 TYPE i,
      END OF struc2,
      s1   TYPE s1_type,
      s2   TYPE s2_type,
      tab1 TYPE TABLE OF s1_type WITH EMPTY KEY,
      tab2 TYPE TABLE OF s2_type WITH EMPTY KEY,
      tab3 TYPE TABLE OF s2_type WITH EMPTY KEY,
      tab4 TYPE SORTED TABLE OF s2_type WITH NON-UNIQUE KEY comp3,
      nl   TYPE string..

    CLASS-METHODS:
      fill_deep_structures,
      fill_struc_and_tab.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_constructor_expr IMPLEMENTATION.


  METHOD fill_deep_structures.
    "Clearing all contents of struc2
    CLEAR struc2.
    "Filling nested tables in deep structures
    struc2-struc_nested = VALUE #( comp1 = `aaa`
                                   comp2 = `bbb`
                                   comp3 = `ccc` ).

    struc1-itab = VALUE #(
      ( col1 = 111 col2 = 222 )
      ( col1 = 333 col2 = 444
     ) ).

    struc2-itab = VALUE #(
      ( col2 = 1 col3 = 2 col4 = 3 )
      ( col2 = 4 col3 = 5 col4 = 6 )
      ( col2 = 7 col3 = 8 col4 = 9 )
     ).

    "Filling individual component that is not shared by both structures
    struc2-comp4 = 999.
  ENDMETHOD.


  METHOD fill_struc_and_tab.
    CLEAR: s1, s2, tab1, tab2, tab3.

    s1 = VALUE #( comp1 = 'A' comp2 = `bbb` comp3 = 1 ).

    s2 = VALUE #( comp1 = `ccc` comp2 = 'D' comp3 = 2 comp4 = 3 ).

    tab1 = VALUE #(
      ( comp1 = 'A' comp2 = `bbb` comp3 = 1 )
      ( comp1 = 'B' comp2 = `ccc` comp3 = 2 )
      ( comp1 = 'C' comp2 = `ddd` comp3 = 3 ) ).

    tab2 = VALUE #(
      ( comp1 = `eee` comp2 = 'F' comp3 = 4 comp4 = 5 )
      ( comp1 = `ggg` comp2 = 'H' comp3 = 6 comp4 = 7 )
      ( comp1 = `iii` comp2 = 'J' comp3 = 8 comp4 = 9 ) ).

    tab3 = VALUE #(
      ( comp1 = `aaa` comp2 = 'B' comp3 = 1 comp4 = 2 )
      ( comp1 = `ccc` comp2 = 'D' comp3 = 3 comp4 = 4 )
      ( comp1 = `eee` comp2 = 'F' comp3 = 5 comp4 = 6 )
      ( comp1 = `ggg` comp2 = 'H' comp3 = 7 comp4 = 8 )
      ( comp1 = `iii` comp2 = 'J' comp3 = 9 comp4 = 10 ) ).

    tab4 = tab3.
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( `ABAP Cheat Sheet Example: Constructor Expressions` ).

    out->write( |\nVALUE\n| ).
    out->write( |1) Structures: Populating a flat structure\n\n| ).

    "A flat structure is created based on a data type defined with a
    "TYPES statement. The structure is then filled using a constructor
    "expression with VALUE by specifying the components and assigning
    "values. Here, the type can be inferred, hence, a # character can be used.

    TYPES: BEGIN OF struc_type,
             num   TYPE i,
             char1 TYPE c LENGTH 3,
             char2 TYPE c LENGTH 3,
           END OF struc_type.

    DATA struc TYPE struc_type.

    "Filling structure
    struc = VALUE #( num = 1 char1 = 'aaa'  char2 = 'abc' ).

    out->write( data = struc name = `struc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Structures: Omitting value assignment to components / BASE addition` ) ).

    "The same structure is then filled purposely omitting components, i.
    "e. these components remain initial.

    struc = VALUE #( char1 = 'bbb' ).

    out->write( data = struc name = `struc` ).

    "You can use the BASE addition to retain existing content
    "Compare with the BASE example further down regarding internal tables: There are
    "no extra parentheses within the outer pair of parentheses.
    struc = VALUE #( BASE struc char2 = 'xyz' ).

    out->write( |\n| ).
    out->write( data = struc name = `struc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Structures: Inline declaration, explicit type specification` ) ).

    "The example demonstrates a variable that is declared inline. Here,
    "the result is a structure which is filled using a constructor
    "expression with VALUE and by specifying the components and assigning
    "values in parentheses. The structure type is specified explicitly.
    "The # symbol would not work since no type can be inferred from the
    "specified parameters.

    DATA(struc_inl) = VALUE struc_type( num   = 3
                                        char1 = 'ccc'
                                        char2 = 'def' ).

    out->write( data = struc_inl name = `struc_inl` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Internal tables: Declaration and population` ) ).

    "The example demonstrates the declaration of an internal table. The
    "internal table is then filled using a constructor expression with
    "VALUE.
    "The type can be inferred here and need not be specified explicitly.
    "Note the extra pair of parentheses in which the components are
    "specified and assigned values. In the example, 3 lines are added to
    "the table. For one line, some components are purposely not assigned.

    DATA itab TYPE TABLE OF struc_type WITH EMPTY KEY.

    itab = VALUE #( ( num = 1 char1 = 'aaa'  char2 = 'abc' )
                    ( num = 2 char1 = 'bbb'  char2 = 'def' )
                    ( num = 3 char1 = 'ccc'                 ) ).

    out->write( data = itab name = `itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Internal tables: Inline declaration, explicit type specification` ) ).

    "The example demonstrates an internal table declared inline that is
    "filled using a constructor expression with VALUE by specifying the
    "internal table type explicitly. Note that the internal table type
    "cannot be generic in this context.

    TYPES: itab_type TYPE STANDARD TABLE OF struc_type
                        WITH NON-UNIQUE KEY num.

    DATA(itab2) = VALUE itab_type(
                    ( num = 4 char1 = 'ddd' char2 = 'ghi' )
                    ( num = 5 char1 = 'eee'  char2 = 'jkl' ) ).


    DATA(str_table) = VALUE string_table( ( `this` )
                                          ( `is a` )
                                          ( `table` )
                                          ( `of type string` ) ).

    out->write( data = itab2 name = `itab2` ).
    out->write( |\n| ).
    out->write( data = str_table name = `str_table` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) LINES OF addition` ) ).

    "Using the LINES OF addition, you can add lines of other tables.
    "Note: The line type of the other internal table must match the one of
    "the target internal table. Using FROM/TO, the table line selection can
    "be further restricted. Without FROM/TO, all lines of the table are
    "respected.

    itab2 = VALUE #( ( num = 6 char1 = 'fff'  char2 = 'mno' )
                     ( LINES OF itab )
                     ( LINES OF itab FROM 1 TO 2 ) ).

    out->write( data = itab2 name = `itab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) BASE addition for keeping existing data` ) ).

    "Using the BASE addition, you can keep existing content of the source
    "internal table.

    itab2 = VALUE #( BASE itab2 ( num = 7 char1 = 'ggg' char2 = 'pqr' ) ).

    out->write( data = itab2 name = `itab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Assignemnt with the VALUE operator without specifying content in parentheses` ) ).

    "Using the VALUE operator without populating anything in the parentheses,
    "data objects are initialized.

    "elementary types
    DATA(some_num) = 123.
    some_num = VALUE #( ).

    DATA(another_num) = VALUE i( ).

    DATA(some_str) = `hallo`.
    some_str = VALUE #( ).

    "Initializing internal table/structure
    str_table = VALUE #( ).
    struc = VALUE #( ).

    out->write( data = some_num name = `some_num` ).
    out->write( |\n| ).
    out->write( data = another_num name = `another_num` ).
    out->write( |\n| ).
    out->write( data = some_str name = `some_str` ).
    out->write( |\n| ).
    out->write( data = str_table name = `str_table` ).
    out->write( |\n| ).
    out->write( data = struc name = `struc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Short form for internal tables with structured line types` ) ).

    TYPES: BEGIN OF stype,
             a TYPE i,
             b TYPE c LENGTH 3,
             c TYPE string,
           END OF stype.
    TYPES tabtype TYPE TABLE OF stype WITH EMPTY KEY.

    DATA(itable) = VALUE tabtype( b = 'aaa'           ( a = 1 c = `xxx` )
                                                      ( a = 2 c = `yyy` )
                                  b = 'bbb' c = `zzz` ( a = 3 )
                                                      ( a = 4 ) ).

    out->write( data = itable name = `itable` ).
    out->write( |\n| ).

    "This option can be handy in various contexts, for example, in a
    "ranges table.
    TYPES int_tab_type TYPE TABLE OF i WITH EMPTY KEY.
    "Populating an integer table with values from 1 to 20 (see iteration
    "expressions with FOR further down)
    DATA(inttab) = VALUE int_tab_type( FOR x = 1 WHILE x <= 20 ( x ) ).

    DATA rangetab TYPE RANGE OF i.

    "Populating a range table using VALUE and the short form
    rangetab = VALUE #( sign   = 'I'
                        option = 'BT' ( low = 1  high = 3 )
                                      ( low = 6  high = 8 )
                                      ( low = 12 high = 15 )
                        option = 'GE' ( low = 18 ) ).

    "Using a SELECT statement to retrieve internal table content
    "based on the range table specifications
    SELECT * FROM @inttab AS tab
        WHERE table_line IN @rangetab
        INTO TABLE @DATA(result_tab).

    out->write( data = result_tab name = `result_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Excursions: VALUE operator in use with ABAP statements and ABAP SQL statements` ) ).

    "The following examples use ABAP and ABAP SQL statements in which table lines
    "are constructed inline using the VALUE operator.

    out->write( `10) Modifying internal table from a structure created inline` && |\n\n| ).

    MODIFY TABLE itab2 FROM VALUE #( num   = 7 char1 = 'hhh' char2 = 'stu' ).

    out->write( data = itab2 name = `itab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Inserting a table line that is created inline into an internal table` ) ).

    INSERT VALUE #( num = 8 char1 = 'iii'  char2 = 'vwx' ) INTO TABLE itab2.

    out->write( data = itab2 name = `itab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Deleting a table entry based on a line created inline` ) ).

    DELETE TABLE itab2 FROM VALUE #( num = 3 ).

    out->write( data = itab2 name = `itab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Modifying a database table based on an internal table created inline` ) ).

    "Deleting demo database table entries for the following example
    DELETE FROM zdemo_abap_carr.

    MODIFY zdemo_abap_carr FROM TABLE @( VALUE #(
           ( carrid = 'CO'
             carrname = 'Continental Airlines'
             currcode = 'USD'
             url =  'http://www.continental.com' )
           ( carrid = 'SQ'
             carrname = 'Singapore Airlines'
             currcode = 'SGD'
             url =  'http://www.singaporeair.com' )
           ) ).

    "Retrieving table entries for display purposes
    SELECT FROM zdemo_abap_carr
           FIELDS carrid, carrname, currcode, url
           ORDER BY carrid
           INTO TABLE @DATA(itab_carr).

    out->write( data = itab_carr name = `itab_carr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Excursion: Deep structures and tables` ) ).
    out->write( |14) Deep structure\n| ).

    "The example demonstrates the use of constructor expressions with
    "VALUE in the context of a deep structure. Here, a structure is declared
    "inline and filled. The structure type includes a nested structure. The
    "nested structure is filled using a nested VALUE expression.

    TYPES: BEGIN OF deep_struc_ty,
             num   TYPE i,
             char1 TYPE c LENGTH 3,
             BEGIN OF substruc,
               int TYPE i,
               str TYPE string,
             END OF substruc,
           END OF deep_struc_ty.

    DATA(deep_struc) = VALUE deep_struc_ty( num = 1
                                            char1 = 'aaa'
                                            substruc = VALUE #( int = 123 str = `hallo` ) ).

    out->write( data = deep_struc name = `deep_struc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Deep internal table` ) ).

    "A deep internal table is created. Also here, nested VALUE
    "expressions are demonstrated.

    TYPES: BEGIN OF deep_struc_ty2,
             char TYPE c LENGTH 3,
             tab  TYPE TABLE OF i WITH EMPTY KEY,
           END OF deep_struc_ty2.

    TYPES: itab_deep_type TYPE STANDARD TABLE OF deep_struc_ty2
            WITH NON-UNIQUE KEY char.

    DATA(deep_itab) = VALUE itab_deep_type(
      ( char = 'aaa' tab = VALUE #( ( 1 ) ( 2 ) ( 3 ) ) )
      ( char = 'bbb' tab = VALUE #( ( 4 ) ( 5 ) ( 6 ) ) ) ).

    out->write( data = deep_itab name = `deep_itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `CORRESPONDING` ) ).
    out->write( |Simple Examples with structures and internal tables\n| ).

    "Method to fill demo structures and internal tables
    "with values to work with
    fill_struc_and_tab( ).

    out->write( `16) Original structure and table content` && |\n\n| ).

    "Displaying the original structures and tables that are filled in the
    "course of a method call. The structures and tables are filled anew
    "throughout the examples so that all CORRESPONDING expressions are based
    "on the same values.

    out->write( data = s1 name = `s1` ).
    out->write( |\n| ).
    out->write( data = s2 name = `s2` ).
    out->write( |\n| ).
    out->write( data = tab1 name = `tab1` ).
    out->write( |\n| ).
    out->write( data = tab2 name = `it_st` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) CORRESPONDING without addition` ) ).

    "The target structure and table have a different type but identically
    "named components. The identically named components are filled. Note
    "that the target variables are initialized here. Also note the effect
    "of an automatic conversion of a variable-length string to a
    "fixed-length string (one component is typed with c, the other,
    "identically named component, is of type string).

    s2 = CORRESPONDING #( s1 ).

    tab2 = CORRESPONDING #( tab1 ).

    out->write( data = s2 name = `s2` ).
    out->write( |\n| ).
    out->write( data = tab2 name = `tab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) BASE addition for keeping original content` ) ).

    "The BASE addition keeps the original content. Structure: The non-
    "identical component name retains its value. Internal table: Existing
    "table lines are kept.

    fill_struc_and_tab( ).

    s2 = CORRESPONDING #( BASE ( s2 ) s1 ).

    tab2 = CORRESPONDING #( BASE ( tab2 ) tab1 ).

    out->write( data = s2 name = `s2` ).
    out->write( |\n| ).
    out->write( data = tab2 name = `tab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) MAPPING/EXCEPT additions` ) ).

    "The example demonstrates the additions MAPPING and EXCEPT. MAPPING:
    "One component of the target structure is assigned the value of a
    "dedicated component of the source structure. EXCEPT: All corresponding
    "components are assigned except a specific one.

    fill_struc_and_tab( ).

    s2 = CORRESPONDING #( s1 MAPPING comp4 = comp3 ).

    tab2 = CORRESPONDING #( tab1 EXCEPT comp1 ).

    out->write( data = s2 name = `s2` ).
    out->write( |\n| ).
    out->write( data = tab2 name = `tab2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `CORRESPONDING: Demonstrating various` &&
    ` additions using deep structures` ) ).

    out->write( `20) Original content of deep structures` && |\n\n| ).

    "Displaying the original deep structures and tables that are filled in
    "the course of a method call. The deep structures and tables are filled
    "anew throughout the examples so that all CORRESPONDING expressions are
    "based on the same values.

    "Method to fill demo deep structures and internal tables
    "with values to work with
    fill_deep_structures( ).

    out->write( data = struc1 name = `struc1` ).
    out->write( |\n| ).
    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) CORRESPONDING without addition` ) ).

    "CORRESPONDING operator without addition
    "Existing contents of identically named components are replaced.
    "Existing contents of components in the target structure that are not
    "available in the source structure are initialized.
    "Contents of the nested structure struc_nested is converted to
    "string. Note that the two components of the nested structure in
    "component struc_nested-comp2 of struc1 are drawn together when being
    "converted to string.
    "Contents of struc2-itab are replaced by table contents of struc1-
    "itab. Note the value assignment, for example, for col2 in struc2-itab.
    "Despite the fact that there is no identically named component comp1 in
    "the target structure, values are assigned starting with the first
    "column of the source structure. Check the conversion rules for
    "internal tables.

    struc2 = CORRESPONDING #( struc1 ).

    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) DEEP addition` ) ).

    "CORRESPONDING operator with the addition DEEP
    "Existing contents of identically named components are replaced.
    "Existing contents of components in the target structure that are not
    "available in the source structure are initialized.
    "Contents of the nested structure struc_nested is converted to
    "string. Note that the two components of the nested structure in
    "component struc_nested-comp2 of struc1 are drawn together when being
    "converted to string.
    "Contents of struc2-itab are replaced by table contents of struc1-
    "itab. Due to the addition DEEP, the value assignment happens for
    "identically named components in the nested table. Hence, only col2 as
    "the only shared and identically named component is filled.

    fill_deep_structures( ).

    struc2 = CORRESPONDING #( DEEP struc1 ).

    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) BASE addition` ) ).

    "CORRESPONDING operator with the addition BASE
    "Existing contents of identically named components are replaced.
    "Existing contents of components in the target structure that are not
    "available in the source structure are kept.
    "Contents of the nested structure struc_nested is converted to
    "string. Note that the two components of the nested structure in
    "component struc_nested-comp2 of struc1 are drawn together when being
    "converted to string.
    "Contents of struc2-itab are replaced by table contents of struc1-
    "itab. The value assignment in the nested table happens like using the
    "CORRESPONDING operator without addition. Note the value assignment, for
    "example, for col2 in struc2-itab. Despite the fact that there is no
    "identically named component col1 in the target structure, values are
    "assigned starting with the first column of the source structure. Check
    "the conversion rules for internal tables.

    fill_deep_structures( ).

    struc2 = CORRESPONDING #( BASE ( struc2 ) struc1 ).

    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) DEEP BASE addition` ) ).

    "CORRESPONDING operator with the additions DEEP BASE
    "Existing contents of identically named components are replaced.
    "Existing contents of components in the target structure that are not
    "available in the source structure are kept.
    "Contents of the nested structure struc_nested is converted to
    "string. Note that the two components of the nested structure in
    "component struc_nested-comp2 of struc1 are drawn together when being
    "converted to string.
    "Contents of struc2-itab are replaced by table contents of struc1-
    "itab. The value assignment in the nested table happens like using the
    "CORRESPONDING operator with the addition DEEP. That is, the value
    "assignment happens for identically named components in the nested table.
    "Hence, only col2 as the only shared and identically named component is filled.

    fill_deep_structures( ).

    struc2 = CORRESPONDING #( DEEP BASE ( struc2 ) struc1 ).

    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) APPENDING addition` ) ).

    "CORRESPONDING operator with the addition APPENDING
    "Existing contents of identically named components are replaced.
    "Existing contents of components in the target structure that are not
    "available in the source structure are kept.
    "Contents of the nested structure struc_nested is converted to
    "string. Note that the two components of the nested structure in
    "component struc_nested-comp2 of struc1 are drawn together when being
    "converted to string.
    "Contents of struc2-itab are kept and contents of struc1-itab are
    "added. The value assignment concerning the added lines happens like
    "using the CORRESPONDING operator without addition. Note the value
    "assignment, for example, for col2 in struc2-itab. Despite the fact that
    "there is no identically named component col1 in the target structure,
    "values are assigned starting with the first column of the source
    "structure. Check the conversion rules for internal tables.

    fill_deep_structures( ).

    struc2 = CORRESPONDING #( APPENDING ( struc2 ) struc1 ).

    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26) DEEP APPENDING` ) ).

    "CORRESPONDING operator with the additions DEEP APPENDING
    "Existing contents of identically named components are replaced.
    "Existing contents of components in the target structure that are not
    "available in the source structure are kept.
    "Contents of the nested structure struc_nested is converted to
    "string. Note that the two components of the nested structure in
    "component struc_nested-comp2 of struc1 are drawn together when being
    "converted to string.
    "Contents of struc2-itab are kept and contents of struc1-itab are
    "added. The value assignment concerning the added lines happens like
    "using the CORRESPONDING operator with the addition DEEP. That is, the
    "value assignment happens for identically named components in the nested
    "table. Hence, only col2 as the only shared and identically named
    "component is filled.

    fill_deep_structures( ).

    struc2 = CORRESPONDING #( DEEP APPENDING ( struc2 ) struc1 ).

    out->write( data = struc2 name = `struc2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `NEW` ) ).
    out->write( `27) Creating Anonymous Data Objects` && |\n\n| ).

    "The examples show the creation of anonymous data objects.
    "First, data reference variables are declared using a DATA statement.
    "Here, one variable is declared with a complete type, the other one with
    "a generic type.
    "Then, anonymous data objects are created using the NEW operator. For
    "one example, the type can be inferred. In the other example, the type
    "is specified explicitly.
    "The next examples show the direct assigning of values.
    "Furthermore, inline declarations can be used to avoid the prior
    "declaration of a variable.

    "Declaring data reference variables
    DATA dref1 TYPE REF TO i. "Complete type
    DATA dref2 TYPE REF TO data. "Generic type

    "Creating anonymous data objects
    "Here, no parameters are specified within the parentheses meaning the
    "data objects retain their initial values.
    dref1 = NEW #( ).
    dref2 = NEW string( ).

    IF dref1->* = 0 AND dref2->* = ``.
      DATA(val) = `Initial values`.
    ELSE.
      val = `No initial values`.
    ENDIF.

    "Directly assigning values within the parentheses.
    dref1 = NEW #( 123 ).
    dref2 = NEW string( `hallo` ).

    "Inline declaration, explicit type specification
    DATA(dref3) = NEW i( 456 ).

    "Another constructor expression specified within the parentheses
    DATA tx TYPE string VALUE `world`.
    DATA(dref4) = NEW string( `Hello ` && tx && CONV string( '!' ) ).

    DATA dref5 TYPE REF TO string_table.
    dref5 = NEW #( VALUE string_table( ( `a` ) ( `b` ) ) ).

    "Structured type; named arguments within the parentheses
    DATA(dref6) = NEW zdemo_abap_carr( carrid   = 'AA'
                                       carrname = 'American Airlines' ).

    out->write( data = val name = `val` ).
    out->write( |\n| ).
    out->write( data = dref1 name = `dref1` ).
    out->write( |\n| ).
    out->write( data = dref2 name = `dref2` ).
    out->write( |\n| ).
    out->write( data = dref3 name = `dref3` ).
    out->write( |\n| ).
    out->write( data = dref4 name = `dref4` ).
    out->write( |\n| ).
    out->write( data = dref5 name = `dref5` ).
    out->write( |\n| ).
    out->write( data = dref6 name = `dref6` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `28) Creating Instances of Classes` ) ).

    "The example demonstrates the creation of instances of classes.
    "First, an object reference variable is declared with a DATA statement.
    "As a next step, an instance of a class is created. The type can be
    "inferred here. The class has a constructor method defined. Hence, the
    "parentheses contain the parameter binding for the constructor method.
    "Here, it is only one parameter. That means the explicit specification
    "of the parameter name is not needed and the value can be specified
    "directly: oref1 = NEW #( `Hallo` ).
    "The next examples show object reference variables that are declared
    "inline. Here, the type (i. e. the class name) must be specified
    "explicitly.
    "The last example shows the method chaining that is possible with
    "expressions using the NEW operator. The demo class has a method that
    "has a returning parameter. In this case, the parameter of the method
    "is of type REF TO i.

    "Creating an object reference variable
    DATA oref1 TYPE REF TO local_class.

    "Creating an instance of a class;
    "providing parameter bindings for the constructor method
    "in the parentheses
    oref1 = NEW #( txt = `Hallo` ).

    out->write( data = oref1 name = `oref1` ).
    out->write( |\n| ).

    "Creating an instance of a class, object reference variable
    "is declared inline, explicit type specification
    DATA(oref2) = NEW local_class( `Salut` ).

    out->write( data = oref2 name = `oref2` ).
    out->write( |\n| ).

    "Method chaining
    DATA(result) = NEW local_class( `Ciao` )->double( int = NEW #( 5 ) ).

    out->write( data = result name = `result` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `29) CONV` ) ).

    "The examples show the effect of the CONV operator.
    "A variable of type i is declared and assigned a value. Then,
    "calculations are carried out. The result is stored in a variable
    "declared inline. The first result is 0 because the derived type is i.
    "The second calculation returns the precise value resulting from the
    "division because the CONV
    "expression triggers the conversion of the result (decfloat34).
    "The next examples demonstrate logical expressions using character-like
    "data types.
    "A variable is of type abap_bool, i. e. a single character is expected.
    "In this case, the variable is initial, i. e. the content is a blank.
    "Another variable is of type string. A blank is assigned to this
    "variable.
    "A logical expression compares the two variables. Without the conversion
    "using the CONV operator, the two are not equal due to the comparison
    "rules for character-like data types (trailing blanks are not respected
    "in variable-length strings). When the string is converted, the
    "comparison results to true.

    "Declaring data object and assign value
    DATA num TYPE i VALUE 1.

    "Effect of a calculation ...
    "... without conversion
    DATA(i) = num / 4.

    "... with conversion using an appropriate type
    DATA(dec_num) = CONV decfloat34( num / 4 ).

    out->write( data = i name = `i` ).
    out->write( |\n| ).
    out->write( data = dec_num name = `dec_num` ).
    out->write( |\n| ).

    "Declaring data objects
    DATA(txt) = VALUE abap_bool( ).

    DATA(str) = ` `.

    "Comparing the data objects with and without conversion
    out->write( `Without conversion:` ).

    IF txt = str.
      out->write( `txt is equal to str.` ).
    ELSE.
      out->write( `txt is not equal to str.` ).
    ENDIF.

    out->write( |\n| ).
    out->write( `With conversion:` ).

    IF txt = CONV abap_bool( str ).
      out->write( `txt is equal to converted str.` ).
    ELSE.
      out->write( `txt is not equal to converted str.` ).
    ENDIF.

    "Example with internal table types
    TYPES inttab_type TYPE TABLE OF i WITH EMPTY KEY.
    DATA int_itab TYPE SORTED TABLE OF i WITH NON-UNIQUE DEFAULT KEY.
    FIELD-SYMBOLS <it> TYPE inttab_type.
    int_itab = VALUE #( ( 1 ) ( 2 ) ( 3 ) ).

    "The following assignment is not possible due to incompatible types.
    "The internal table has the same line type, but it has a different
    "table type and key.
    "ASSIGN itab TO <fs>.

    "Using CONV to convert the internal table to the required table type.
    DATA(conv_itab) = CONV inttab_type( int_itab ).
    ASSIGN conv_itab TO <it>.

    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = <it> name = `<it>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `30) Constructing Data Objects with the CONV Operator` ) ).

    DATA(decnum1) = CONV decfloat34( '0.4' ).

    "Instead of
    DATA decnum2 TYPE decfloat34 VALUE '0.4'.
    "or
    DATA decnum3 TYPE decfloat34.
    decnum3 = '0.4'.

    out->write( `No output for this section. See the code.` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `31) EXACT` ) ).

    "-------------- Lossless assignments -------------

    "Note: An assignment is made in accordance with conversion rules. Check
    "the ABAP Keyword Documentation for these rules. An assignment is only
    "made if no values are lost. Otherwise, an error occurs. Either it is
    "detected by static code checks or at runtime raising a catchable exception.
    TYPES clen3 TYPE c LENGTH 3.
    DATA(as1) = EXACT clen3( abap_true ).
    DATA(as2) = EXACT clen3( 'XY' ).
    "DATA(as3) = EXACT clen3( 'abcd' ).

    out->write( data = as1 name = `as1` ).
    out->write( |\n| ).
    out->write( data = as2 name = `as2` ).
    out->write( |\n| ).


    "Catching exception
    TRY.
        DATA(as4) = EXACT clen3( 'abcd' ).
        out->write( data = as4 name = `as4` ).
      CATCH cx_sy_conversion_data_loss INTO DATA(dl_err).
        out->write( data = dl_err->get_text( ) name = `dl_err->get_text( )` ).
    ENDTRY.
    out->write( |\n| ).

    "-------------- Lossless calculations -------------

    "The first statement works, whereas the second statement raises an exception.
    "A rounding to two decimal places is required.
    TYPES packednum TYPE p LENGTH 8 DECIMALS 2.
    DATA(calc1) = EXACT packednum( 1 / 4 ).
    "DATA(calc2) = EXACT packednum( 1 / 3 ).

    out->write( data = calc1 name = `calc1` ).
    out->write( |\n| ).

    "Catching exceptions when rounding in lossless calculations
    TRY.
        DATA(calc3) = EXACT packednum( 1 / 3 ).
        out->write( data = calc3 name = `calc3` ).
      CATCH cx_sy_conversion_rounding INTO DATA(lc_err).
        out->write( data = lc_err->get_text( ) name = `lc_err->get_text( )` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32) REF` ) ).

    "The example includes the declaration of a data object and some data
    "reference variables. One data reference variable is typed with a
    "complete type, the other one is typed with a generic type. Then, data
    "references to the data object declared before are created. Using the #
    "symbol means that the type can be automatically derived.
    "You can also use inline declarations to omit the explicit declaration.
    "Another example shows the explicit specification of the data type after
    "REF.
    "Furthermore, an object reference is created using inline declaration.

    "Declaring data object
    DATA number TYPE i VALUE 5.

    "Declaring data reference variables
    DATA dref_a TYPE REF TO i.    "Complete type
    DATA dref_b TYPE REF TO data. "Generic type

    "Creating data references to data objects
    dref_a = REF #( number ).
    dref_b = REF #( number ).

    "Data reference variable declared inline
    DATA(dref_c) = REF #( number ).

    "Type specified explicitly
    DATA(dref_d) = REF string( `hallo` ).

    "Object references
    DATA(oref_a) = NEW local_class( `Ciao` ).
    DATA(oref_b) = REF #( oref_a ).

    out->write( data = dref_a name = `dref_a` ).
    out->write( |\n| ).
    out->write( data = dref_b name = `dref_b` ).
    out->write( |\n| ).
    out->write( data = dref_c name = `dref_c` ).
    out->write( |\n| ).
    out->write( data = dref_d name = `dref_d` ).
    out->write( |\n| ).
    out->write( data = oref_b name = `oref_b` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33) CAST` ) ).

    "The example demonstrates the CAST operator in the context of Run Time
    "Type Identification (RTTI).
    "First, the components of a structure are retrieved. Secondly, the
    "method information of a local class is retrieved. The syntax
    "particularly shows the advantages of downcasts carried out with the
    "CAST operator that also enables method chaining. An example is added
    "that demonstrates the use of the older ?= operator with which extra
    "variables are needed. Furthermore, simple downcasts are demonstrated
    "using data references.

    "RTTI examples
    "Using CAST
    "Retrieving structure components
    DATA(components_s2) =
      CAST cl_abap_structdescr(
        cl_abap_typedescr=>describe_by_data( s2 ) )->components.

    "Retrieving the methods of a local class
    DATA(methods) =
         CAST cl_abap_objectdescr(
                  cl_abap_objectdescr=>describe_by_name( 'LOCAL_CLASS' )
                    )->methods.

    "Excursion: Using the older cast operator ?=
    "Retrieving structure components
    "Note: More lines of code, helper variables needed
    DATA structdescr TYPE REF TO cl_abap_structdescr.

    structdescr ?= cl_abap_typedescr=>describe_by_data( s1 ).

    DATA(components_s1) = structdescr->components.

    "Casting with data references
    DATA dref_i TYPE REF TO i. "Complete type

    DATA dref_data TYPE REF TO data. "Generic type

    dref_data = NEW i( 123 ).

    dref_i = CAST #( dref_data ).

    out->write( data = components_s2 name = `components_s2` ).
    out->write( |\n| ).
    out->write( data = methods name = `methods` ).
    out->write( |\n| ).
    out->write( data = components_s1 name = `components_s1` ).
    out->write( |\n| ).
    out->write( data = dref_i name = `dref_i` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `34) COND` ) ).

    DATA(day_or_night) = COND #( WHEN cl_abap_context_info=>get_system_time( ) BETWEEN '050000' AND '220000'
                                 THEN `day`
                                 ELSE `night` ).

    out->write( data = day_or_night name = `day_or_night` ).
    out->write( |\n| ).

    "A constructor expression as above instead of, for example, an IF statement as follows.
    IF cl_abap_context_info=>get_system_time( ) BETWEEN '050000' AND '220000'.
      day_or_night = `day`.
    ELSE.
      day_or_night = `night`.
    ENDIF.

    out->write( data = day_or_night name = `day_or_night` ).
    out->write( |\n| ).

    "Multiple logical expressions initiated by WHEN
    "Also LET expressions are possible. See more details further down.
    DATA(time_of_day) = COND #( LET time = cl_abap_context_info=>get_system_time( ) IN
                                WHEN time BETWEEN '050001' AND '120000' THEN |Good morning, it's { time TIME = ISO }.|
                                WHEN time BETWEEN '120001' AND '180000' THEN |Good afternoon, it's { time TIME = ISO }.|
                                WHEN time BETWEEN '180001' AND '220000' THEN |Good evening, it's { time TIME = ISO }.|
                                ELSE |Good night, it's { time TIME = ISO }.| ).

    out->write( data = time_of_day name = `time_of_day` ).
    out->write( |\n| ).

    "THROW addition to raise an exception (working like RAISE EXCEPTION TYPE statements)
    "by specifying an exception class
    "Note: It is possible to ...
    "- specify the THROW addition also after THEN.
    "- make exceptions resumable using the RESUMABLE addition.
    DATA(number1) = 0.
    DATA(number2) = 0.
    TRY.
        "The example raises the exception because both operands have the value 0.
        DATA(div) = COND decfloat34( WHEN number1 <> 0 AND number2 <> 0 THEN number1 / number2
                                     WHEN number1 = 0  AND number2 <> 0 THEN number1 / number2
                                     ELSE THROW cx_sy_zerodivide( ) ).
        out->write( data = div name = `div` ).
      CATCH cx_sy_zerodivide.
        DATA(two_zeros) = `Zero division`.
        out->write( data = two_zeros name = `two_zeros` ).
    ENDTRY.

    out->write( |\n| ).

    "Excursion for the example above: The following statement does not result in an
    "error in ABAP (zero division 'allowed' if the first operand has also the value 0).
    div = 0 / 0.

    "THROW SHORTDUMP addition to raise a runtime error (working like RAISE SHORTDUMP
    "TYPE statements) by specifying an exception class; a message can be also passed,
    "and input parameters can be filled
*    TRY.
*        div = COND decfloat34( WHEN number1 <> 0 AND number2 <> 0 THEN number1 / number2
*                               WHEN number1 = 0  AND number2 <> 0 THEN number1 / number2
*                               ELSE THROW SHORTDUMP cx_sy_zerodivide( ) ).
*        out->write( data = div name = `div` ).
*      CATCH cx_sy_zerodivide.
*    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `35) SWITCH` ) ).

    "The example demonstrates the use of the SWITCH operator. Here,
    "calculations are carried out. For this
    "purpose, a string table is created that includes arithmetic operators
    "and, purposely, one entry that does not fit. The internal table is looped
    "across. Based on the current arithmetic operator, the calculation is
    "carried out. A string is displayed accordingly. The code is embedded in
    "a TRY ... CATCH ... ENDTRY block to take care of arithmetic errors. For
    "example, you might insert the value 0 for the variable num2 to provoke 0
    "division. The CONV operator is also used in the example to respect
    "decimals.

    DATA operator_tab TYPE TABLE OF string.

    operator_tab = VALUE #( ( `+` ) ( `-` ) ( `*` ) ( `/` ) ( `#` ) ).

    DATA(num1) = 2.
    DATA(num2) = 4.

    LOOP AT operator_tab ASSIGNING FIELD-SYMBOL(<fs>).
      TRY.
          DATA(calc_result) =
              SWITCH string( <fs>
                         WHEN '+' THEN |{ num1 + num2 STYLE = SIMPLE }|
                         WHEN '-' THEN |{ num1 - num2 STYLE = SIMPLE }|
                         WHEN '*' THEN |{ num1 * num2 STYLE = SIMPLE }|
                         WHEN '/' THEN |{ CONV decfloat34( num1 / num2 ) STYLE = SIMPLE }|
                         ELSE `That doesn't work.` ).
          out->write( |{ num1 } { <fs> } { num2 } = { calc_result }| ).
        CATCH cx_sy_arithmetic_error INTO DATA(error).
          out->write( |Arithmetic error. { error->get_text( ) }| ).
      ENDTRY.
    ENDLOOP.
    out->write( |\n| ).
    out->write( |\n| ).

    "A constructor expression as above instead of, for example, a CASE statement as follows.
    DATA(operator) = '+'.
    CASE operator.
      WHEN '+'.
        calc_result = |{ num1 + num2 STYLE = SIMPLE }|.
      WHEN '-'.
        calc_result = |{ num1 - num2 STYLE = SIMPLE }|.
      WHEN '*'.
        calc_result = |{ num1 * num2 STYLE = SIMPLE }|.
      WHEN '/'.
        calc_result = |{ CONV decfloat34( num1 / num2 ) STYLE = SIMPLE }|.
      WHEN OTHERS.
        calc_result = `Wrong operator.`.
    ENDCASE.

    out->write( data = calc_result name = `calc_result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `36) FILTER` ) ).

    "This section covers multiple examples demonstrating the syntactical variety
    "of the FILTER operator.

    TYPES: BEGIN OF fi_str,
             a TYPE i,
             b TYPE c LENGTH 3,
             c TYPE c LENGTH 3,
           END OF fi_str.

    "basic form, condition created with single values
    "itab must have at least one sorted key or one hash key used for access.
    "This variant of the filter operator is not possible for an internal table itab without a sorted key or hash key.
    DATA fi_tab1 TYPE SORTED TABLE OF fi_str WITH NON-UNIQUE KEY a.
    DATA fi_tab2 TYPE STANDARD TABLE OF fi_str WITH NON-UNIQUE SORTED KEY sec_key COMPONENTS a.
    DATA fi_tab3 TYPE HASHED TABLE OF fi_str WITH UNIQUE KEY a.

    "Filling internal tables
    fi_tab1 = VALUE #( ( a = 1  b = 'aaa' c = 'abc' )
                       ( a = 2  b = 'bbb' c = 'def' )
                       ( a = 3  b = 'ccc' c = 'hij' )
                       ( a = 4  b = 'ddd' c = 'klm' )
                       ( a = 5  b = 'eee' c = 'nop' ) ).

    fi_tab2 = fi_tab1.
    fi_tab3 = fi_tab1.

    "The lines meeting the condition are respected.
    "Note: The source table must have at least one sorted or hashed key.
    "Here, the primary key is used
    DATA(f1) = FILTER #( fi_tab1 WHERE a >= 3 ).

    out->write( data = f1 name = `f1` ).
    out->write( |\n| ).

    "USING KEY primary_key explicitly specified; same as above
    DATA(f2) = FILTER #( fi_tab1 USING KEY primary_key WHERE a >= 3 ).

    out->write( data = f2 name = `f2` ).
    out->write( |\n| ).

    "EXCEPT addition
    DATA(f3) = FILTER #( fi_tab1 EXCEPT WHERE a >= 3 ).

    out->write( data = f3 name = `f3` ).
    out->write( |\n| ).

    DATA(f4) = FILTER #( fi_tab1 EXCEPT USING KEY primary_key WHERE a >= 3 ).

    out->write( data = f4 name = `f4` ).
    out->write( |\n| ).

    "Secondary table key specified after USING KEY
    DATA(f5) = FILTER #( fi_tab2 USING KEY sec_key WHERE a >= 4 ).

    out->write( data = f5 name = `f5` ).
    out->write( |\n| ).

    DATA(f6) = FILTER #( fi_tab2 EXCEPT USING KEY sec_key WHERE a >= 3 ).

    out->write( data = f6 name = `f6` ).
    out->write( |\n| ).

    "Note: In case of a hash key, exactly one comparison expression for each key
    "component is allowed; only = as comparison operator possible.
    DATA(f7) = FILTER #( fi_tab3 WHERE a = 3 ).

    out->write( data = f7 name = `f7` ).
    out->write( |\n| ).

    "Using a filter table
    "In the WHERE condition, the columns of source and filter table are compared.
    "Those lines in the source table are used for which at least one line in the
    "filter table meets the condition. EXCEPT and USING KEY are also possible.

    "Declaring and filling filter tables
    DATA filter_tab1 TYPE SORTED TABLE OF i
      WITH NON-UNIQUE KEY table_line.

    DATA filter_tab2 TYPE STANDARD TABLE OF i
        WITH EMPTY KEY
        WITH UNIQUE SORTED KEY line COMPONENTS table_line.

    filter_tab1 = VALUE #( ( 3 ) ( 5 ) ).
    filter_tab2 = filter_tab1.

    DATA(f8) = FILTER #( fi_tab1 IN filter_tab1 WHERE a = table_line ).

    out->write( data = f8 name = `f8` ).
    out->write( |\n| ).

    "EXCEPT addition
    DATA(f9) = FILTER #( fi_tab1 EXCEPT IN filter_tab1 WHERE a = table_line ).

    out->write( data = f9 name = `f9` ).
    out->write( |\n| ).

    "USING KEY is specified for the filter table
    DATA(f10) = FILTER #( fi_tab2 IN filter_tab2 USING KEY line WHERE a = table_line ).

    out->write( data = f10 name = `f10` ).
    out->write( |\n| ).

    "USING KEY is specified for the source table, including EXCEPT
    DATA(f11) = FILTER #( fi_tab2 USING KEY sec_key EXCEPT IN filter_tab2 WHERE a = table_line ).

    out->write( data = f11 name = `f11` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading(  `37) Iteration Expressions with FOR` ) ).

    "Data objects and types to work with in the examples
    TYPES: BEGIN OF s,
             col1 TYPE c LENGTH 5,
             col2 TYPE i,
             col3 TYPE i,
           END OF s.
    TYPES it_type TYPE TABLE OF s WITH EMPTY KEY.
    DATA(itab4for) = VALUE it_type( ( col1 = 'a' col2 = 1 col3 = 30 )
                                    ( col1 = 'bb' col2 = 2 col3 = 10 )
                                    ( col1 = 'ccc' col2 = 3 col3 = 20 ) ).

    "-------------- Table iterations --------------

    DATA(it1) = VALUE it_type( FOR wa IN itab4for ( col1 = wa-col1 && 'z'
                                                  col2 = wa-col2 + 1 ) ).

    out->write( data = it1 name = `it1` ).
    out->write( |\n| ).

    "LOOP AT equivalent
    CLEAR it1.
    LOOP AT itab4for INTO DATA(wa_loop).
      APPEND VALUE #( col1 = wa_loop-col1 && 'z'
                      col2 = wa_loop-col2 + 1 ) TO it1.
    ENDLOOP.

    out->write( data = it1 name = `it1` ).
    out->write( |\n| ).

    "The following example shows more syntax options
    "- Field symbol specifed after FOR
    "- LET expressions after FOR: Denotes that the LET
    "  expressions is evaluated for each loop pass
    "- INDEX INTO addition (the variable that follows implicitly
    "  has the type i): Storing the sy-tabix value for each
    "  loop pass
    DATA(it2) = VALUE it_type( FOR <line> IN itab4for INDEX INTO idx
                                 LET idxplus1 = idx + 1 IN
                                 ( col1 = <line>-col1 col2 = idx col3 = idxplus1 ) ).

    out->write( data = it2 name = `it2` ).
    out->write( |\n| ).

    "Similar to the example above, the following example uses the INDEX INTO
    "addition, as well as a LET expression with multiple local variables
    DATA(it3) = VALUE string_table( FOR <str> IN itab4for INDEX INTO idx
                                    LET col1            = |COL1: "{ <str>-col1 }"|
                                        col2            = |COL2: "{ <str>-col2 }"|
                                        col3            = |COL3: "{ <str>-col3 }"|
                                        str_to_be_added = |Table index { idx } -> { col1 } / { col2 } / { col3 }|
                                    IN ( str_to_be_added ) ).

    out->write( data = it3 name = `it3` ).
    out->write( |\n| ).

    "---------- Excursions ----------

    "Merging tables
    "In the following example, the content of two existing internal tables is merged.
    "In the simple example, the index is used for the table index. You can also imagine
    "that you merge two internal tables, both having multiple columns. You could refer
    "to the specific component values, for example, using a free key in a table expression
    "such as ... VALUE #( some_itab[ comp_x = wa-comp_y ]-comp_z DEFAULT ... ) ...
    TYPES inttabtype TYPE TABLE OF i WITH EMPTY KEY.
    DATA(integertable) = VALUE inttabtype( ( 99 ) ( 100 ) ).

    DATA(it4) = VALUE it_type( FOR wa IN itab4for INDEX INTO idx
                                 ( col1 = wa-col1 col2 = VALUE #( integertable[ idx ] DEFAULT 0 ) ) ).

    out->write( data = it4 name = `it4` ).
    out->write( |\n| ).

    "Retaining non-specified column values using the BASE addition
    "In the example, the original value of col3 is retained.
    DATA(it5) = VALUE it_type( FOR wa IN itab4for ( VALUE #( BASE wa col1 = wa-col1 && 'y'
                                                                   col2 = wa-col2 + 3 ) ) ).

    out->write( data = it5 name = `it5` ).
    out->write( |\n| ).

    "Using the CORRESPONDING operator to handle different types
    TYPES: BEGIN OF s2,
             col1 TYPE c LENGTH 5,
             col2 TYPE i,
             str  TYPE string,
           END OF s2.
    TYPES itab_type_2 TYPE TABLE OF s2 WITH EMPTY KEY.

    DATA(it6) = VALUE itab_type_2( FOR wa IN itab4for ( CORRESPONDING #( wa ) ) ).

    out->write( data = it6 name = `it6` ).
    out->write( |\n| ).

    "Multiple FOR expressions that work like nested loops
    DATA(it7) = VALUE string_table( FOR wa1 IN itab4for
                                    FOR wa2 IN integertable
                                    ( |Comp. 1st itab: "{ wa1-col1 }", comp. 2nd itab: "{ wa2 }"| ) ).

    out->write( data = it7 name = `it7` ).
    out->write( |\n| ).

    "LOOP AT equivalent
    CLEAR it7.
    LOOP AT itab4for INTO DATA(wa3).
      LOOP AT integertable INTO DATA(wa4).
        it7 = VALUE #( BASE it7 ( |Comp. 1st itab: "{ wa3-col1 }", comp. 2nd itab: "{ wa4 }"| ) ).
      ENDLOOP.
    ENDLOOP.

    out->write( data = it7 name = `it7` ).
    out->write( |\n| ).

    "More additions can be specified such as WHERE, USING KEY, FROM/TO, STEP

    "WHERE condition
    "The WHERE condition must be placed in parentheses.
    DATA(it8) = VALUE it_type( FOR wa IN itab4for WHERE ( col2 < 3 ) ( col1 = wa-col1 && 'w'
                                                                     col2 = 5
                                                                     col3 = wa-col2 ) ).

    out->write( data = it8 name = `it8` ).
    out->write( |\n| ).

    "FROM/TO additions
    DATA(it9) = VALUE it_type( FOR wa IN itab4for FROM 2 TO 3 ( col1 = wa-col1 && 'v'
                                                              col2 = 6
                                                              col3 = wa-col2 + 5   ) ).

    out->write( data = it9 name = `it9` ).
    out->write( |\n| ).

    "STEP addition
    DATA(it10) = VALUE it_type( FOR wa IN itab4for STEP -1 ( col1 = wa-col1 && 'u'
                                                           col2 = 7
                                                           col3 = wa-col2 + 8 ) ).

    out->write( data = it10 name = `it10` ).
    out->write( |\n| ).

    "USING KEY addition
    DATA(it11) = VALUE it_type( FOR wa IN itab4for USING KEY primary_key ( col1 = wa-col1 && 't'
                                                                         col2 = 9
                                                                         col3 = wa-col2 + 10 ) ).

    out->write( data = it11 name = `it11` ).
    out->write( |\n| ).

    "---------- Conditional iterations ----------

    "FOR ... WHILE ...
    DATA(it12) = VALUE it_type( FOR x = 1 WHILE x < 4
                                  ( col1 = x col2 = x + 1 col3 = x + 2 ) ).

    out->write( data = it12 name = `it12` ).
    out->write( |\n| ).

    "FOR ... UNTIL ...
    "The THEN addition is also possible for ... WHILE ...
    DATA(it13) = VALUE it_type( FOR y = 31 THEN y - 10 UNTIL y < 10
                                  ( col1 = y col2 = y + 1 col3 = y + 2 ) ).

    out->write( data = it13 name = `it13` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `38) More Examples with Iteration Expressions with FOR` ) ).

    "The examples demonstrate iteration expressions with FOR. The examples
    "are based on demo internal tables that are filled using a method. The
    "tables are displayed to show the original content of the internal
    "tables that are to be processed.

    out->write( |Original table content\n\n| ).

    "Method to fill demo internal tables with values to work with.
    "Tables are displayed showing the values.
    fill_struc_and_tab( ).

    out->write( data = tab1 name = `tab1` ).
    out->write( |\n| ).
    out->write( data = tab2 name = `tab2` ).
    out->write( |\n| ).
    out->write( data = tab3 name = `tab3` ).

    out->write( |\n| ).
    out->write( `************ FOR ... IN ... (LOOP Semantics) ************` ).
    out->write( |\n| ).

    "Examples demonstrating FOR ... IN ... that has the semantics of LOOP.
    "1) An internal table is looped across. The whole line is stored in a
    "new table which is declared inline. The target table must have the
    "same table type as the internal table that is looped across. The
    "example is without a WHERE condition, i. e. all lines of the source
    "table are considered.
    "2) A new table is created that has a different table type. However,
    "both table types have identically named components. The example shows
    "how you can fill all identically named components of the target table.
    "The example includes a WHERE condition to restrict the lines to be
    "considered. Pay attention to potential type conversions.
    "3) A new table is created that has a different table type. Here, it is
    "shown that the components and their assignment might be specified
    "individually. A WHERE clause is included. Pay attention to potential
    "type conversions.

    "1) Storing the whole line in a new table.
    "The target table must have the same table type as the source table.
    "Without the WHERE condition, all lines are considered.

    TYPES t_type1 LIKE tab3.

    DATA(for1) = VALUE t_type1( FOR w IN tab3 ( w ) ).

    "2) Storing specific components having the same names.
    "The target type is not compatible to the type of the source table.
    "Identically named components exist.

    TYPES t_type2 LIKE tab1.

    DATA(for2) = VALUE t_type2( FOR w IN tab3
                                WHERE ( comp4 > 7 )
                                ( CORRESPONDING #( w ) ) ).

    "3) Specify components individually and providing a mapping

    DATA(for3) = VALUE t_type2( FOR w IN tab3
                                WHERE ( comp4 > 7 )
                                ( comp1 = w-comp1
                                  comp2 = `hallo`
                                  comp3 = w-comp4 ) ).

    out->write( data = for1 name = `for1` ).
    out->write( |\n| ).
    out->write( data = for2 name = `for2` ).
    out->write( |\n| ).
    out->write( data = for3 name = `for3` ).
    out->write( |\n| ).

    "The example demonstrates multiple iteration expressions with FOR. Here,
    "a new table is created that is declared inline. Three tables are
    "respected. The lines to be considered are restricted by a WHERE
    "clause.
    "A component name mapping takes care of assigning specific values to
    "non-identically named components.

    "Declaring an internal table type
    TYPES: BEGIN OF line_type2,
             compX TYPE c LENGTH 1,
             compY TYPE string,
             compZ TYPE i,
           END OF line_type2,
           t_type3 TYPE STANDARD TABLE OF line_type2 WITH EMPTY KEY.

    "Nested iteration expressions with FOR
    DATA(for4) = VALUE t_type3(
      FOR w1 IN tab1 WHERE ( comp1 = 'A' )
      FOR w2 IN tab2 WHERE ( comp4 > 6 )
      FOR w3 IN tab3 WHERE ( comp3 < 4 )
      ( compX = w1-comp1
        compY = w2-comp1
        compZ = w3-comp3 ) ).

    out->write( data = for4 name = `for4` ).

    out->write( |\n| ).
    out->write( `************ FOR ... WHILE/UNTIL ... (DO/WHILE Semantics) ************` ).
    out->write( |\n| ).

    "Examples demonstrating FOR ... WHILE/UNTIL ... that has the semantics
    "of DO/WHILE.
    "The example demonstrates the construction of internal tables using
    "condition iterations with a constructor expression
    "and the corresponding variant of the value operator VALUE. Two internal
    "tables with different iterations, one using FOR ... WHILE ..., the
    "other FOR ... UNTIL ..., are created.

    "Declaring and internal table type
    TYPES:
      BEGIN OF line_type3,
        col1 TYPE i,
        col2 TYPE i,
        col3 TYPE i,
      END OF line_type3,
      t_type4 TYPE STANDARD TABLE OF line_type3 WITH EMPTY KEY.

    "FOR ... WHILE ...
    DATA(for5) = VALUE t_type4(
          FOR x = 11 THEN x + 10 WHILE x < 40
          ( col1 = x col2 = x + 1 col3 = x + 2 ) ).

    "FOR ... UNTIL ...
    DATA(for6) = VALUE t_type4(
          FOR y = 31 THEN y - 10 UNTIL y < 10
          ( col1 = y col2 = y + 1 col3 = y + 2 ) ).

    out->write( data = for5 name = `for5` ).
    out->write( |\n| ).
    out->write( data = for6 name = `for6` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `39) REDUCE` ) ).

    "Data objects and types to work with in the examples
    TYPES: BEGIN OF st,
             col1 TYPE c LENGTH 5,
             col2 TYPE i,
             col3 TYPE i,
           END OF st.
    TYPES tab_type TYPE TABLE OF st WITH EMPTY KEY.
    DATA(itab4reduce) = VALUE tab_type( ( col1 = 'a' col2 = 1 col3 = 30 )
                                  ( col1 = 'bb' col2 = 2 col3 = 10 )
                                  ( col1 = 'ccc' col2 = 3 col3 = 20 ) ).

    "---------- Table iterations ----------

    "Calculating the sum of values in a table column
    DATA(sum_val) = REDUCE i( INIT len = 0
                              FOR <l> IN itab4reduce
                              NEXT len = len + <l>-col2 ).

    out->write( data = sum_val name = `sum_val` ).
    out->write( |\n| ).

    "Getting the longest string in a table column
    DATA(long_str) = REDUCE st-col1( INIT string = VALUE #( )
                                    FOR <l> IN itab4reduce
                                    NEXT string =  COND #( WHEN strlen( <l>-col1 ) > strlen( string )
                                                        THEN <l>-col1
                                                        ELSE string ) ).

    out->write( data = long_str name = `long_str` ).
    out->write( |\n| ).

    "Getting the maximum value (other than, for example, using a SORT statement)
    "Unlike above, a variable is used instead of a field symbol.
    DATA(max_val) = REDUCE i( INIT max = 0
                              FOR line IN itab4reduce
                              NEXT max =  COND #( WHEN line-col2 > max
                                                  THEN line-col2
                                                  ELSE max ) ).

    out->write( data = max_val name = `max_val` ).
    out->write( |\n| ).

    "Creating a new internal table using REDUCE
    "In the example, the sum of two values is calculated.
    "A VALUE expression with the BASE addition is used to
    "add a line to a table (retaining the existing lines).
    DATA(itstr) = REDUCE string_table( INIT strtab = VALUE string_table( )
                                       FOR workarea IN itab4reduce
                                       NEXT strtab = VALUE #( BASE strtab
                                        ( |The sum of { workarea-col2 } and { workarea-col3 } is { workarea-col2 + workarea-col3 }.| ) ) ).

    out->write( data = itstr name = `itstr` ).
    out->write( |\n| ).

    "More additions are possible, such as specifying a WHERE condition (which
    "must be specified in parentheses). The following example creates a new
    "internal table based on a WHERE condition.
    TYPES: BEGIN OF s3,
             num1 TYPE i,
             num2 TYPE i,
             sum  TYPE i,
           END OF s3.
    TYPES s3_tab_type TYPE TABLE OF s3 WITH EMPTY KEY.
    DATA(itred) = REDUCE s3_tab_type( INIT tab = VALUE s3_tab_type( )
                                      FOR workarea IN itab4reduce
                                      WHERE ( col2 < 3 )
                                      NEXT tab = VALUE #( BASE tab
                                       ( num1 = workarea-col2 num2 = workarea-col3 sum = workarea-col2 + workarea-col3 ) ) ).

    out->write( data = itred name = `itred` ).
    out->write( |\n| ).

    "---------- Conditional iterations ----------

    "UNTIL addition
    "Iteratively calculating the sum from 1 to 10
    DATA(reduce_until) = REDUCE i( INIT sum = 0
                                   FOR  int = 1 UNTIL int > 10
                                   NEXT sum += int ).

    out->write( data = reduce_until name = `reduce_until` ).
    out->write( |\n| ).

    "WHILE addition
    "The example corresponds to the previous one.
    DATA(reduce_while) = REDUCE i( INIT sum = 0
                                   FOR  int = 1 WHILE int <= 10
                                   NEXT sum += int ).

    out->write( data = reduce_while name = `reduce_while` ).
    out->write( |\n| ).

    "THEN addition
    "The following example constructs a text string. The THEN addition is used
    "to decrement the iteration variable. Additionally, a LET expression is used
    "to specify a helper variable.
    "Result: Counting downwards starting with 10: 10 9 8 7 6 5 4 3 2 1
    DATA(count) = REDUCE string( LET start = 10 IN
                                 INIT text = |Counting downwards starting with { start }:|
                                 FOR n = start THEN n - 1 WHILE n > 0
                                 NEXT text &&= | { n }| ).

    out->write( data = count name = `count` ).
    out->write( |\n| ).

    "Example similar to the previous one. Using UNTIL, a text string is enlarged until
    "it has reached a specific size.
    "Result: ab abap abapap abapapap abapapapap abapapapapap abapapapapapap
    DATA(abap_str) =  REDUCE string( INIT text = ``
                                     FOR t = `ab` THEN t && `ap` UNTIL strlen( t ) > 15
                                     NEXT text &&= |{ t } | ).

    out->write( data = abap_str name = `abap_str` ).
    out->write( |\n| ).

    "---------- Excursion: Grouping lines in internal tables with VALUE/REDUCE ----------

    "The following examples show equivalents of LOOP AT GROUP ... GROUP BY ... statements.
    "Find more information and examples about grouping in the ABAP Keyword Documentation.

    "Internal table to work with in the examples
    DATA(itab4grp) = VALUE tab_type( ( col1 = 'a' col2 = 1 col3 = 2 )
                                      ( col1 = 'a' col2 = 3 col3 = 4 )
                                      ( col1 = 'a' col2 = 5 col3 = 6 )
                                      ( col1 = 'b' col2 = 7 col3 = 8 )
                                      ( col1 = 'b' col2 = 9 col3 = 10 )
                                      ( col1 = 'c' col2 = 11 col3 = 12 ) ).


    "Constructing a result using VALUE
    "The following example returns the values of identified groups in an internal table
    "Table lines are evaluated by grouping all lines that meet the condition
    "specified in GROUP BY (group key binding). The group key is stored in the variable
    "after FOR GROUPS (gr). The constructed result just consists of the group keys in
    "the example. The content of the members is not relevant.
    DATA(it_val_1) = VALUE string_table( FOR GROUPS gr OF wr IN itab4grp
                                         GROUP BY wr-col1 ASCENDING
                                         WITHOUT MEMBERS
                                         ( |{ gr }| ) ).

    out->write( data = it_val_1 name = `it_val_1` ).
    out->write( |\n| ).


    "As above, the following example returns the values of identified groups in an internal table.
    "Additionally, a LET expression (that itself contains an iteration expression) is specified
    "to collect column values by group in an internal table. The lines of this (string) table
    "are concatenated and inserted in the target table.
    DATA(it_val_2) = VALUE string_table(
        FOR GROUPS grp OF wr IN itab4grp
        GROUP BY wr-col1 ASCENDING
        LET members = VALUE string_table(
        FOR grpd IN GROUP grp ( |{ grpd-col2 }, { grpd-col3 }| ) ) IN
        ( |{ grp }: { concat_lines_of( table = members sep = ` / ` ) }| ) ).

    out->write( data = it_val_2 name = `it_val_2` ).
    out->write( |\n| ).

    "Constructing a result using REDUCE
    "The example is similar to the previous one by filling a string table.
    "The example uses a group key expression specified after GROUP BY.
    "In the group key expression, additional components of a structured
    "group key are specified which return specific information (group size,
    "group index).
    DATA(it_reduced) = REDUCE string_table(
        INIT li = VALUE string_table( )
        FOR GROUPS group OF grt IN itab4grp
        GROUP BY ( grpkey = grt-col1
                    size = GROUP SIZE
                    index = GROUP INDEX ) ASCENDING
        LET mem = VALUE string_table( FOR grpr IN GROUP group ( |{ grpr-col2 }, { grpr-col3 }| ) ) IN
        NEXT li = VALUE string_table( BASE li ( |Group key: "{ group-grpkey }" \| | &&
                                                |group size: {  group-size  } \| | &&
                                                |group index: { group-index } \| members: | &&
                                                |{ concat_lines_of( table = mem sep = ` / ` ) }| ) ) ).

    out->write( data = it_reduced name = `it_reduced` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `40) LET Expressions` ) ).

    "Data type and object to work with in the example
    TYPES: BEGIN OF st_type,
             comp1 TYPE c LENGTH 5,
             comp2 TYPE i,
             comp3 TYPE i,
           END OF st_type.
    DATA it TYPE TABLE OF st_type WITH EMPTY KEY.
    it = VALUE #( ( comp1 = 'a' comp2 = 1 comp3 = 30 )
                  ( comp1 = 'bb' comp2 = 2 comp3 = 10 )
                  ( comp1 = 'ccc' comp2 = 3 comp3 = 20 ) ).

    "Constructing a data object with elementary data type using the CONV operator
    "One or more helper variables are possible specified after LET
    DATA(hi) = CONV string(
            LET name = cl_abap_context_info=>get_user_technical_name( )
                date = cl_abap_context_info=>get_system_date( )
            IN |Hi { name }. Today's date is { date DATE = ISO }.| ).

    out->write( data = hi name = `hi` ).
    out->write( |\n| ).

    "Construction similar to the previous example
    "Depending on the time, a string is created. In the example, a LET expression
    "is specified for each constructor expression.
    DATA(timeofday) = CONV string(
            LET time = cl_abap_context_info=>get_system_time( ) IN
            COND string( LET good = `Good` ending = `ing` IN
                        WHEN time BETWEEN '050001' AND '120000' THEN good && ` morn` && ending  "Good morning
                        WHEN time BETWEEN '120001' AND '180000' THEN good && ` afternoon`
                        WHEN time BETWEEN '180001' AND '220000' THEN good && ` even` && ending
                        ELSE good && ` night`  ) ).

    out->write( data = timeofday name = `timeofday` ).
    out->write( |\n| ).

    "Getting a particular column name of an existing internal table using RTTI
    "An internal table (it contains information on the table's structured type; the
    "component names, among others) is assigned to a data object that is declared
    "inline. This is an example of making code more concise with constructor expressions
    "and inline declarations. Assume you use extra declarations for the data objects, or
    "use the older ?= operator for the casts. Many more lines of code are required.
    DATA(components) = CAST cl_abap_structdescr( CAST cl_abap_tabledescr(
        cl_abap_typedescr=>describe_by_data( it ) )->get_table_line_type( ) )->components.
    DATA(comp2_a) = components[ 2 ]-name.

    out->write( data = comp2_a name = `comp2_a` ).
    out->write( |\n| ).

    "Achieving the result from above even in one statement using LET
    DATA(comp2_b) = CONV abap_compname(
        LET comps = CAST cl_abap_structdescr( CAST cl_abap_tabledescr(
                     cl_abap_typedescr=>describe_by_data( it ) )->get_table_line_type( ) )->components
        IN comps[ 2 ]-name ).

    out->write( data = comp2_b name = `comp2_b` ).
    out->write( |\n| ).

    "Constructing a structure using local variables
    "The example uses the NEW operator to create an anonymous data object
    DATA(new_struc) = NEW st_type( LET n = 2 ch = 'AP' IN
                                    comp1 = 'AB' && ch comp2 = 2 * n comp3 = 3 * n ).

    out->write( data = new_struc->* name = `new_struc->*` ).
    out->write( |\n| ).

    "Constructing an internal table using local variables
    "The example uses the VALUE operator.
    "Note the parentheses ( ... ) representing table lines.
    DATA(itab_value) = VALUE string_table( LET lin = 1 IN
                                            ( |Line { lin }| )
                                            ( |Line { lin + 1 }| )
                                            ( |Line { lin + 2 }| ) ).

    out->write( data = itab_value name = `itab_value` ).
    out->write( |\n| ).

    "Using a local field symbol in LET expressions
    "- The right-hand side value must be the result of a writable expression, i.e.
    "  an operand that can be written to
    "- This value is then assigned to the local field symbol (as if ASSIGN is used)
    "- In the examples above, a specification such as ... LET <a> = 1 IN ... is not
    "  possible as they are not writable expressions.
    "- Writable expressions:
    "  - Constructor expressions NEW class( ... )->attr and CAST type( ... )->dobj
    "  - Table expressions itab[ ... ] and their chainings, e.g. itab[ 1 ]-comp
    "In the following example, an internal table is looped over. A string is created
    "from the table line content. In the constructor expression, a LET expression is
    "specified that uses a field symbol. It is assigned the line of the internal table.
    "The sy-index value represents the table index value.
    DATA str_tab TYPE string_table.
    DO lines( it ) TIMES.
      DATA(concatenated_tab) = CONV string(
          LET <li>  = it[ sy-index ]
              comma =   `, `
          IN  |{ <li>-comp1 }{ comma }{ <li>-comp2 }{ comma }{ <li>-comp3 }| ).
      str_tab = VALUE #( BASE str_tab ( concatenated_tab ) ).
    ENDDO.

    out->write( data = str_tab name = `str_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `41) More LET Examples` ) ).

    "The examples demonstrate LET expressions in different contexts.

    "1) LET within a constructor expression with VALUE: The temporary
    "variable is assigned a value of type string and all lines of the
    "resulting table (a table of type string) receive the content of this
    "variable in the specified position.

    DATA(stringtable) = VALUE string_table( LET be = `be` IN
                      ( |To { be } is to do| )
                      ( |To { be } or not to { be }| )
                      ( |To do is to { be }| )
                      ( |Do { be } do { be } do| ) ).

    out->write( data = stringtable name = `stringtable` ).
    out->write( |\n| ).

    "2) LET within a constructor expression with COND: 12 o'clock is
    "specified as value for the LET expression. Based on this value, checks
    "are carried out and an appropriate result is returned.

    DATA(system_time) = cl_abap_context_info=>get_system_time( ).

    DATA(systime) =
      COND #( LET tm = '120000' IN
              WHEN system_time < tm THEN
                |{ system_time TIME = ISO } AM|
              WHEN system_time > tm AND system_time < '240000' THEN
                |{ CONV t( system_time - 12 * 3600 ) TIME = ISO } PM|
              WHEN system_time = tm THEN |High Noon|
              ELSE |?| ).

    out->write( data = systime name = `systime` ).
    out->write( |\n| ).

    "3) An internal table that includes three components is created and
    "filled. A loop across this table is carried out. The purpose of the
    "constructor expression is to construct a string by concatenating the
    "values in the table columns. Here, the LET expression includes a field
    "symbol representing the table line. The field symbol receives the
    "concatenation result which is then stored in the variable that is
    "declared inline. The content is then added to an internal table of type
    "string which is then output to show the result of the loop.

    TYPES:
      BEGIN OF date,
        year  TYPE c LENGTH 4,
        month TYPE c LENGTH 2,
        day   TYPE c LENGTH 2,
      END OF date,
      dates TYPE TABLE OF date WITH EMPTY KEY.

    DATA stringtab TYPE TABLE OF string WITH EMPTY KEY.

    DATA(dates) = VALUE dates(
      ( year = '2020' month = '07' day = '16' )
      ( year = '2021' month = '08' day = '31' )
      ( year = '2022' month = '09' day = '07' ) ).

    DO lines( dates ) TIMES.
      DATA(isodate) = CONV string(
        LET <date>  = dates[ sy-index ]
            separator   =   '-'
         IN  <date>-year && separator && <date>-month &&
             separator && <date>-day ).

      "Adding line to table
      stringtab = VALUE #( BASE stringtab ( isodate ) ).
    ENDDO.

    out->write( data = stringtab name = `stringtab` ).
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS local_class DEFINITION.
  PUBLIC SECTION.
    METHODS: constructor IMPORTING txt TYPE string,
      double IMPORTING int TYPE
          REF TO i RETURNING VALUE(res) TYPE i.

    DATA: timestamp TYPE string,
          text      TYPE string.

    CLASS-DATA: no_of_instances TYPE i READ-ONLY.
ENDCLASS.""",
    r"""CLASS local_class IMPLEMENTATION.
  METHOD constructor.
    "Number of instances of the class are counted.
    no_of_instances = no_of_instances + 1.
    "Set a time stamp.
    DATA: ts TYPE timestampl.
    GET TIME STAMP FIELD ts.
    timestamp = |{ ts TIMESTAMP = SPACE }|.

    text = |{ txt }, { sy-uname }.|.
  ENDMETHOD.
  METHOD double.
    res = int->* * 2.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_date_time DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_date_time IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Date, Time, and Time Stamp\n\n| ).

**********************************************************************

    out->write( |1) Retrieving the Time Zone\n\n| ).

    "Retrieving the time zone of a given user
    TRY.
        DATA(tz_user) = cl_abap_context_info=>get_user_time_zone( ).
      CATCH cx_abap_context_info_error.
    ENDTRY.

    "Using XCO
    "The reference created without '->value' is used in some XCO method calls,
    "as shown in some of the following code snippets.
    "User's time zone
    DATA(tz_user_xco) = xco_cp_time=>time_zone->user->value.
    "UTC
    DATA(tz_utc_xco) = xco_cp_time=>time_zone->utc->value.

    out->write( data = tz_user name = `tz_user` ).
    out->write( |\n| ).
    out->write( data = tz_user_xco name = `tz_user_xco` ).
    out->write( |\n| ).
    out->write( data = tz_utc_xco name = `tz_utc_xco` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Retrieving and Creating Dates` ) ).

    "--------------------- Retrieving the current date --------------------
    "Retrieving the current date with respect to UTC.
    "The result's base type is the DDIC type dats that is mapped to the
    "ABAP type d.
    DATA(utc_date) = cl_abap_context_info=>get_system_date( ).

    "Using XCO
    "Notes:
    "- The result of the following chained statement is of type string.
    "- With the 'as' method, a given format (available via xco_cp_time=>format)
    "  is applied to the time.
    "- The 'date' method has a parameter for specifying the time zone.
    "  By default, the user's time zone is used. For the specification, you
    "  can use xco_cp_time=>time_zone.
    "- The examples explore multiple formatting options that are specified in the
    "  'date' and 'as' methods.
    "Various formatting options
    DATA(date_xco_iso_basic) = xco_cp=>sy->date( )->as( xco_cp_time=>format->iso_8601_basic )->value.
    DATA(date_xco_iso_ext) = xco_cp=>sy->date( )->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(date_xco_abap) = xco_cp=>sy->date( )->as( xco_cp_time=>format->abap )->value.
    "Specifying the user time zone explicitly (it is the default value)
    DATA(date_xco_expl_user_tz) = xco_cp=>sy->date( xco_cp_time=>time_zone->user
                                   )->as( xco_cp_time=>format->iso_8601_extended
                                   )->value.
    "Specifying UTC explicitly
    DATA(date_xco_expl_utc) = xco_cp=>sy->date( xco_cp_time=>time_zone->utc
                                   )->as( xco_cp_time=>format->iso_8601_extended
                                   )->value.

    "--------------------- Retrieving current date values (XCO) --------------------
    DATA(this_day) = xco_cp=>sy->date( )->day.
    DATA(this_month) = xco_cp=>sy->date( )->month.
    DATA(this_year) = xco_cp=>sy->date( )->year.

    "--------------------- Creating dates --------------------
    DATA date_cr1 TYPE d.
    date_cr1 = '20240101'.
    DATA date_cr2 TYPE d VALUE '20240202'.
    DATA(date_cr3) = CONV d( '20240303' ).

    "Using XCO
    "The result contains a reference. It can be used for further processing
    "with the XCO library.
    DATA(date_w_xco) = xco_cp_time=>date( iv_year = 2024
                                          iv_month = 3
                                          iv_day = 3 ).

    "Examples
    DATA(date_cr4) = date_w_xco->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(day_from_date) = date_w_xco->day.
    DATA(month_from_date) = date_w_xco->month.

    out->write( data = utc_date name = `utc_date` ).
    out->write( |\n| ).
    out->write( data = date_xco_iso_basic name = `date_xco_iso_basic` ).
    out->write( |\n| ).
    out->write( data = date_xco_iso_ext name = `date_xco_iso_ext` ).
    out->write( |\n| ).
    out->write( data = date_xco_abap name = `date_xco_abap` ).
    out->write( |\n| ).
    out->write( data = date_xco_expl_user_tz name = `date_xco_expl_user_tz` ).
    out->write( |\n| ).
    out->write( data = date_xco_expl_utc name = `date_xco_expl_utc` ).
    out->write( |\n| ).
    out->write( data = this_day name = `this_day` ).
    out->write( |\n| ).
    out->write( data = this_month name = `this_month` ).
    out->write( |\n| ).
    out->write( data = this_year name = `this_year` ).
    out->write( |\n| ).
    out->write( data = date_cr4 name = `date_cr4` ).
    out->write( |\n| ).
    out->write( data = day_from_date name = `day_from_date` ).
    out->write( |\n| ).
    out->write( data = month_from_date name = `month_from_date` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Validity of Date Fields` ) ).
    "Before accessing date (or time) fields, ensure that the content of these
    "fields is valid to avoid unexpected results, such as incorrect calculations.
    "The ABAP runtime framework checks the validity of these fields in various
    "contexts, including lossless assignments and assignments to numeric fields.

    "Lossless assignements using the EXACT operator
    "Due to the invalid dates, an exception is raised.
    TRY.
        DATA(inv_date1) = EXACT d( '20240231' ).
      CATCH cx_sy_conversion_no_date INTO DATA(error1).
        out->write( data = error1->get_text( ) name = `error1->get_text( )` ).
        out->write( |\n| ).
    ENDTRY.

    TRY.
        DATA(inv_date2) = EXACT d( '2024XY31' ).
      CATCH cx_sy_conversion_no_date INTO DATA(error2).
        out->write( data = error2->get_text( ) name = `error2->get_text( )` ).
        out->write( |\n| ).
    ENDTRY.

    "Assignment of an invalid date of type d to type i; the initial value
    "is produced
    "In newer ABAP releases, the following statement shows a
    "syntax warning that the date (intentionally specified as
    "invalid date here) does not match the type. Therefore,
    "the example is provided differently to circumvent the
    "syntax warning.

    "DATA(inv_date3) = CONV i( CONV d( '20240231' ) ).

    TYPES c8 TYPE c LENGTH 8.
    DATA false_date TYPE c8 VALUE '20240231'.
    DATA(inv_date3) = CONV i( CONV d( false_date ) ).

    IF inv_date3 = 0.
      out->write( `inv_date3 = 0` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Character-Like Access to Date Fields` ) ).
    "Since the content is character-like, you can use string processing functionalities
    "to access date values. This also applies to time fields of type t.
    "The following examples show a selection.

    "Extracting date values using the string function substring.
    DATA some_date TYPE d VALUE '20240102'.
    DATA(year_sub) = substring( val = some_date off = 0 len = 4 ).
    DATA(month_sub) = substring( val = some_date off = 4 len = 2 ).
    DATA(day_sub) = substring( val = some_date off = 6 len = 2 ).

    "Replacing using the string function replace
    DATA(year_repl)  = replace( val = some_date off = 0 len = 4 with = `2025` ).

    "Offset and length specifications
    DATA(off_len_spec_day) = some_date+6(2).
    some_date+4(2) = '10'.

    out->write( data = year_sub name = `year_sub` ).
    out->write( |\n| ).
    out->write( data = month_sub name = `month_sub` ).
    out->write( |\n| ).
    out->write( data = day_sub name = `day_sub` ).
    out->write( |\n| ).
    out->write( data = year_repl name = `year_repl` ).
    out->write( |\n| ).
    out->write( data = off_len_spec_day name = `off_len_spec_day` ).
    out->write( |\n| ).
    out->write( data = some_date name = `some_date` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Numeric Access and Calculations` ) ).
    "When converting date fields to numeric values, the type d produces an integer
    "representing the number of days since 01.01.000
    "This is especially important when using date fields in calculations and converting
    "the values to numeric types.
    "The XCO library offers methods for performing calculations. In the code snippet,
    "examples use the value attribute. The return value of the method calls is of type
    "string.

    DATA date_calc_1 TYPE d VALUE '20240101'.
    DATA date_calc_2 TYPE d VALUE '20231227'.
    DATA date_calc_3 TYPE d VALUE '20231230'.
    DATA date_calc_4 TYPE d VALUE '20240220'.

    DATA(days_diff_1) = date_calc_1 - date_calc_2.
    DATA(days_diff_2) = date_calc_1 - date_calc_3.
    DATA(days_since_01_01_0001) = CONV i( date_calc_1 ).
    "Getting the weekday (1 = Monday, 2 = Tuesday, ...)
    DATA(weekday1) = ( 5 + date_calc_1  MOD 7 ) MOD 7 + 1.
    DATA(weekday2) = ( 5 + date_calc_3  MOD 7 ) MOD 7 + 1.
    DATA(date_w_first_day_of_month) =  CONV d( replace( val = `202403020` off = 6 len = 2 with = `01` ) ).
    DATA(date_w_last_day_of_prev_month) = CONV d( date_w_first_day_of_month - 1 ).

    "------------ Performing date additions and subtractions using the XCO library ------------

    "Adding days to the current date using the 'add' method
    DATA(xco_date_add_5days) = xco_cp=>sy->date( )->add( iv_day = 5
                                                 )->as( xco_cp_time=>format->iso_8601_extended
                                                 )->value.

    "The 'add' method has various parameters, adding 1 day/month/year
    DATA(xco_date_add_1_mult) = xco_cp=>sy->date( )->add( iv_day = 1 iv_month = 1 iv_year = 1
                                                  )->as( xco_cp_time=>format->iso_8601_extended
                                                  )->value.

    "Addition with a created date
    DATA(xco_date_add_1day_custom) = xco_cp_time=>date( iv_year = 2024 iv_month = 02 iv_day = 28
                                                      )->add( iv_day = 1
                                                      )->as( xco_cp_time=>format->iso_8601_extended
                                                      )->value.

    "Subtracting using the 'subtract' method
    DATA(xco_date_subtr_1_mult) = xco_cp=>sy->date( )->subtract( iv_day = 1 iv_month = 1 iv_year = 1
                                                    )->as( xco_cp_time=>format->iso_8601_extended
                                                    )->value.

    "Optional parameter io_calculation
    "io_calculation parameter: xco_cp_time=>date_calculation->preserving,
    "i.e. the date is calculated mathmatically and preserved. It is the
    "default.
    "In case of an invalid resulting date, an exception is raised.
    TRY.
        DATA(inv_date_a) = xco_cp_time=>date( iv_year  = '2024'
                                              iv_month = '08'
                                              iv_day   = '31'
                                            )->add( iv_month = 1
                                                    io_calculation = xco_cp_time=>date_calculation->preserving
                                            )->as( xco_cp_time=>format->iso_8601_extended
                                            )->value.
      CATCH cx_root INTO DATA(err_pre).
    ENDTRY.

    "io_calculation parameter: xco_cp_time=>date_calculation->ultimo,
    "Here, the actual last day of the month is considered. If the calculated
    "date is invalid, the ultimo is automatically used. In the example, one month is added to
    "the date. However, September does not have 31 days, so the result is adjusted to the actual
    "last day of September, which is 30 in this case.
    TRY.
        DATA(inv_date_b) = xco_cp_time=>date( iv_year  = '2024'
                                              iv_month = '08'
                                              iv_day   = '31'
                                            )->add( iv_month = 1
                                                    io_calculation = xco_cp_time=>date_calculation->ultimo
                                            )->as( xco_cp_time=>format->iso_8601_extended
                                            )->value.
      CATCH cx_root INTO DATA(err_ult).
    ENDTRY.

    out->write( data = days_diff_1 name = `days_diff_1` ).
    out->write( |\n| ).
    out->write( data = days_diff_2 name = `days_diff_2` ).
    out->write( |\n| ).
    out->write( data = days_since_01_01_0001 name = `days_since_01_01_0001` ).
    out->write( |\n| ).
    out->write( data = weekday1 name = `weekday1` ).
    out->write( |\n| ).
    out->write( data = weekday2 name = `weekday2` ).
    out->write( |\n| ).
    out->write( data = date_w_first_day_of_month name = `date_w_first_day_of_month` ).
    out->write( |\n| ).
    out->write( data = date_w_last_day_of_prev_month name = `date_w_last_day_of_prev_month` ).
    out->write( |\n| ).
    out->write( data = xco_date_add_5days name = `xco_date_add_5days` ).
    out->write( |\n| ).
    out->write( data = xco_date_add_1_mult name = `xco_date_add_1_mult` ).
    out->write( |\n| ).
    out->write( data = xco_date_add_1day_custom name = `xco_date_add_1day_custom` ).
    out->write( |\n| ).
    out->write( data = xco_date_subtr_1_mult name = `xco_date_subtr_1_mult` ).
    out->write( |\n| ).
    IF err_pre IS INITIAL.
      out->write( data = inv_date_a name = `inv_date_a` ).
    ELSE.
      out->write( data = err_pre->get_text( ) name = `err_pre->get_text( )` ).
    ENDIF.
    out->write( |\n| ).
    IF err_ult IS INITIAL.
      out->write( data = inv_date_b name = `inv_date_b` ).
    ELSE.
      out->write( data = err_ult->get_text( ) name = `err_ult->get_text( )` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) CL_ABAP_DATFM: Date Conversions` ) ).
    "Using the CL_ABAP_DATFM class, you can perform conversions with external
    "and internal representations of a time according to the date format, e.g.
    "the conversion of a date in a data object of type string to type d and vice
    "versa using a specific date format. Multiple methods are available, of which
    "two are covered in the example. For more information, refer to the class
    "documentation.
    "For the values of the date format for the conversion, see the fixed values
    "by exploring the F2 help for cl_abap_datfm=>ty_datfm.

    "Data type and obect declarations for the example. The example, explores
    "multiple date formats. For this purpose, each loop pass in a DO loop
    "uses a different date format. First, the internal time format is converted
    "to external time formats. In another loop, the conversions are performed
    "the other way round. The results are stored in an internal table.
    DATA(date4conversion) = CONV d( '20240202' ).
    DATA conv_date_str TYPE string.
    DATA conv_date_d TYPE d.
    DATA date_format TYPE cl_abap_datfm=>ty_datfm.
    TYPES: BEGIN OF date_ty_s,
             ext_date TYPE string,
             format   TYPE c LENGTH 1,
             int_date TYPE d,
           END OF date_ty_s.
    DATA date_tab TYPE TABLE OF date_ty_s WITH EMPTY KEY.

    "Conversion of d (internal) to string (external time format)
    DO 7 TIMES.
      TRY.
          cl_abap_datfm=>conv_date_int_to_ext(
            EXPORTING im_datint    = date4conversion
                      im_datfmdes  = SWITCH #( sy-index
                                               WHEN 1 THEN cl_abap_datfm=>get_datfm( )
                                               WHEN 2 THEN '1'
                                               WHEN 3 THEN '2'
                                               WHEN 4 THEN '3'
                                               WHEN 5 THEN '6'
                                               WHEN 6 THEN 'A'
                                               WHEN 7 THEN 'C' )
            IMPORTING ex_datext    = conv_date_str
                      ex_datfmused = date_format  ).
          date_tab = VALUE #( BASE date_tab ( ext_date = conv_date_str format = date_format ) ).
        CATCH cx_abap_datfm_format_unknown.
      ENDTRY.
    ENDDO.

    "Conversion of string (external) to d (internal time format)
    LOOP AT date_tab REFERENCE INTO DATA(ref_date).
      TRY.
          cl_abap_datfm=>conv_date_ext_to_int(
            EXPORTING im_datext    = ref_date->ext_date
                      im_datfmdes  = ref_date->format
            IMPORTING ex_datint    = conv_date_d
                      ex_datfmused = date_format ).
          ref_date->int_date = conv_date_d.
        CATCH cx_abap_datfm_no_date cx_abap_datfm_invalid_date
              cx_abap_datfm_format_unknown cx_abap_datfm_ambiguous.
      ENDTRY.
    ENDLOOP.

    "Note: When outputting the data object with the classrun,
    "20240202, which is of type d, is displayed as 2014-02-02 in
    "the console for better readability.
    out->write( data = date_tab name = `date_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Examples for Time Processing` ) ).
    "The code snippet below provides examples of time processing, such
    "as retrieving the current time, accessing time values, creating time
    "values, and performing time calculations. You can also utilize the
    "XCO library in different scenarios.

    "--------------------- Retrieving the current time --------------------

    "Retrieving the current time in UTC.
    DATA(utc_time) = cl_abap_context_info=>get_system_time( ).

    "Using XCO
    "Note the optional time zone specification.
    DATA(time_w_xco) = xco_cp=>sy->time( xco_cp_time=>time_zone->user
                                        )->as( xco_cp_time=>format->iso_8601_extended
                                        )->value.

    "--------------------- Accessing time values --------------------

    "Note: As mentioned in a previous section on dates, the access to time fields
    "works similar as date fields. As an example, seconds, minutes, and hours are
    "extracted from a time field.
    DATA some_time TYPE t VALUE '123456'.

    DATA(hour_extr) = substring( val = some_time off = 0 len = 2 ).
    DATA(minute_extr) = substring( val = some_time off = 2 len = 2 ).
    DATA(second_extr) = substring( val = some_time off = 4 len = 2 ).

    "Retrieving the current seconds, minutes, hours using XCO
    DATA(sec_w_xco) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->second.
    DATA(min_w_xco) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->minute.
    DATA(hour_w_xco) = xco_cp=>sy->time( xco_cp_time=>time_zone->user )->hour.

    "--------------------- Creating times --------------------

    DATA time_cr1 TYPE t.
    time_cr1 = '095812'.
    DATA time_cr2 TYPE t VALUE '112400'.
    DATA(time_cr3) = CONV t( '120000' ).

    "Using XCO
    "The result contains a reference. It can be used for further processing
    "with the XCO library.
    DATA(xco_time) = xco_cp_time=>time( iv_hour = '08'
                                        iv_minute = '34'
                                        iv_second = '05' ).

    "Examples
    DATA(time_cr4) = xco_time->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(hours_from_xco_time) = xco_time->hour.
    DATA(minutes_from_xco_time) = xco_time->minute.
    DATA(seconds_from_xco_time) = xco_time->second.

    "------------ Performing time calculations ------------

    "Retrieving seconds, minutes, and hours from a time value in a data object
    "of type t
    DATA time4calc TYPE t VALUE '115708'.
    DATA(seconds_total) = CONV i( time4calc ).
    DATA(calc_hours) = seconds_total DIV 3600.
    DATA(min_calc) = ( seconds_total - calc_hours * 3600 ) DIV 60.
    DATA(sec_calc) = ( seconds_total - calc_hours * 3600 ) - min_calc * 60.

    "Using the XCO library
    "See the snippet above in the date section as well as the class documentation.
    "Adding
    DATA(time_xco_add) = xco_cp=>sy->time( xco_cp_time=>time_zone->user
                                         )->add( iv_hour = 1 iv_minute = 1 iv_second = 1
                                         )->as( xco_cp_time=>format->iso_8601_extended
                                         )->value.
    "Subtracting
    DATA(time_xco_subtr) = xco_cp=>sy->time( xco_cp_time=>time_zone->user
                                           )->subtract( iv_hour = 1 iv_minute = 1 iv_second = 1
                                           )->as( xco_cp_time=>format->iso_8601_extended
                                           )->value.

    "------------ Conversions with the CL_ABAP_TIMEFM class ------------

    "Using the CL_ABAP_TIMEFM class, you can perform conversions with external
    "and internal representations of a time, e.g. conversion of a time in a data
    "object of type string to type t and vice versa. Multiple methods are available,
    "of which two are covered in the example. For more information, refer to the
    "class documentation.
    DATA(time4conversion) = CONV t( '123456' ).
    DATA conv_time_str TYPE string.
    DATA conv_time_t TYPE t.

    "Conversion of t (internal) to string (external time format)
    TRY.
        cl_abap_timefm=>conv_time_int_to_ext(
          EXPORTING time_int            = time4conversion
                    without_seconds     = abap_false
                    format_according_to = cl_abap_timefm=>iso "hh:mm:ss
          IMPORTING time_ext            = conv_time_str ).
      CATCH cx_parameter_invalid_range.
    ENDTRY.

    "Conversion of string (external) to t (internal time format)
    TRY.
        cl_abap_timefm=>conv_time_ext_to_int(
          EXPORTING time_ext = conv_time_str
          IMPORTING time_int = conv_time_t ).
      CATCH cx_abap_timefm_invalid.
    ENDTRY.

    out->write( data = utc_time name = `utc_time` ).
    out->write( |\n| ).
    out->write( data = time_w_xco name = `time_w_xco` ).
    out->write( |\n| ).
    out->write( data = hour_extr name = `hour_extr` ).
    out->write( |\n| ).
    out->write( data = minute_extr name = `minute_extr` ).
    out->write( |\n| ).
    out->write( data = second_extr name = `second_extr` ).
    out->write( |\n| ).
    out->write( data = sec_w_xco name = `sec_w_xco` ).
    out->write( |\n| ).
    out->write( data = min_w_xco name = `min_w_xco` ).
    out->write( |\n| ).
    out->write( data = hour_w_xco name = `hour_w_xco` ).
    out->write( |\n| ).
    out->write( data = time_cr4 name = `time_cr4` ).
    out->write( |\n| ).
    out->write( data = hours_from_xco_time name = `hours_from_xco_time` ).
    out->write( |\n| ).
    out->write( data = minutes_from_xco_time name = `minutes_from_xco_time` ).
    out->write( |\n| ).
    out->write( data = seconds_from_xco_time name = `seconds_from_xco_time` ).
    out->write( |\n| ).
    out->write( data = seconds_total name = `seconds_total` ).
    out->write( |\n| ).
    out->write( data = calc_hours name = `calc_hours` ).
    out->write( |\n| ).
    out->write( data = min_calc name = `min_calc` ).
    out->write( |\n| ).
    out->write( data = sec_calc name = `sec_calc` ).
    out->write( |\n| ).
    out->write( data = time_xco_add name = `time_xco_add` ).
    out->write( |\n| ).
    out->write( data = time_xco_subtr name = `time_xco_subtr` ).
    out->write( |\n| ).
    out->write( data = conv_time_str name = `conv_time_str` ).
    out->write( |\n| ).
    "Note: When outputting the data object of type t with the classrun,
    "it is displayed in the format hh:mm:ss in the console for better
    "readability.
    out->write( data = conv_time_t name = `conv_time_t` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Time Stamps of Type utclong` ) ).

    "Retrieving an UTC time stamp using the built-in function utclong_current
    "The return value has the type utclong.
    DATA(ts1) = utclong_current( ).

    "Using XCO
    "In the case of XCO, the return value is of type string.
    "Retrieving a time stamp in the user's time zone (which is the default)
    DATA(ts2) = xco_cp=>sy->moment( xco_cp_time=>time_zone->user
                                  )->as( xco_cp_time=>format->iso_8601_extended
                                  )->value.
    "Current time stamp in UTC
    DATA(ts3) = xco_cp=>sy->moment( xco_cp_time=>time_zone->utc
                                  )->as( xco_cp_time=>format->iso_8601_extended
                                  )->value.
    "Different formatting options
    DATA(ts_xco) = xco_cp=>sy->moment( xco_cp_time=>time_zone->utc ).
    DATA(ts4) = ts_xco->as( xco_cp_time=>format->abap )->value.
    DATA(ts5) = ts_xco->as( xco_cp_time=>format->iso_8601_basic )->value.
    DATA(ts6) = ts_xco->as( xco_cp_time=>format->iso_8601_extended )->value.

    out->write( data = ts1 name = `ts1` ).
    out->write( |\n| ).
    out->write( data = ts2 name = `ts2` ).
    out->write( |\n| ).
    out->write( data = ts3 name = `ts3` ).
    out->write( |\n| ).
    out->write( data = ts4 name = `ts4` ).
    out->write( |\n| ).
    out->write( data = ts5 name = `ts5` ).
    out->write( |\n| ).
    out->write( data = ts6 name = `ts6` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Creating/Modifying a Time Stamp` ) ).

    "--------------------- Creating time stamps --------------------

    DATA ts7 TYPE utclong.
    ts7 = utclong_current( ).
    DATA ts8 TYPE utclong VALUE '2024-11-05 15:30:00'.
    DATA(ts9) = CONV utclong( '2024-11-03 05:30:00' ).

    "Using XCO
    "As above, the return value is of type string. Various methods, formatting options,
    "etc. are available.
    DATA(ts10) = xco_cp_time=>moment( iv_year   = '2024'
                                      iv_month  = '01'
                                      iv_day    = '01'
                                      iv_hour   = '12'
                                      iv_minute = '34'
                                      iv_second = '55'
                                    )->as( xco_cp_time=>format->iso_8601_extended
                                    )->value.

    "--------------------- Modifying time stamps (XCO) --------------------

    "As covered for date and time types, you can modify time stamps using string
    "processing functionalities. They are not covered here. XCO provides, for
    "example, the 'overwrite' method. Optional parameters are available.
    DATA(ts11) = xco_cp_time=>moment( iv_year   = '2024'
                                      iv_month  = '03'
                                      iv_day    = '05'
                                      iv_hour   = '02'
                                      iv_minute = '54'
                                      iv_second = '12' ).

    DATA(ts12) = ts11->overwrite( iv_year = '2025'
                                  iv_month = '07'
                                  iv_day = '15'
                                  iv_hour = '01'
                                )->as( xco_cp_time=>format->iso_8601_extended
                                )->value.

    out->write( data = ts7 name = `ts7` ).
    out->write( |\n| ).
    out->write( data = ts8 name = `ts8` ).
    out->write( |\n| ).
    out->write( data = ts9 name = `ts9` ).
    out->write( |\n| ).
    out->write( data = ts10 name = `ts10` ).
    out->write( |\n| ).
    out->write( data = ts12 name = `ts12` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Time Stamp Calculations with the Built-In Function utclong_add` ) ).

    "With the built-in function utclong_add, at least one parameter must be specified
    "besides 'val'.
    "Note that there are no parameters for years and months.
    DATA(utc4calc) = CONV utclong( '2024-01-01 15:55:14.1173220' ).

    "Adding one hour
    DATA(ts13) = utclong_add( val = utc4calc
                              hours = 1 ).

    "Subtracting one hour by passing a negative integer value (no separate substract
    "function available)
    DATA(ts14) = utclong_add( val = utc4calc
                              hours = -1 ).

    "Using all parameters
    DATA(ts15) = utclong_add( val = utc4calc
                              days = 1
                              hours = 2
                              minutes = CONV int8( '13' )
                              seconds = CONV decfloat34( '53.12' ) ).

    out->write( data = ts13 name = `ts13` ).
    out->write( |\n| ).
    out->write( data = ts14 name = `ts14` ).
    out->write( |\n| ).
    out->write( data = ts15 name = `ts15` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Time Stamp Calculations with XCO` ) ).

    "Creating two time stamps with XCO
    DATA(ts_ref1) =  xco_cp_time=>moment( iv_year   = '2024'
                                          iv_month  = '01'
                                          iv_day    = '01'
                                          iv_hour   = '11'
                                          iv_minute = '37'
                                          iv_second = '54' ).

    DATA(ts_ref2) =  xco_cp_time=>moment( iv_year   = '2024'
                                          iv_month  = '02'
                                          iv_day    = '02'
                                          iv_hour   = '10'
                                          iv_minute = '28'
                                          iv_second = '59' ).

    "Additions; various optional parameters are available
    DATA(ts18) = ts_ref1->add( iv_day = 1 iv_month = 2 iv_year = 3
                              )->as( xco_cp_time=>format->iso_8601_extended
                              )->value.

    DATA(ts19) = ts_ref2->add( iv_hour = 1 iv_minute = 2 iv_second = 4
                              )->as( xco_cp_time=>format->iso_8601_extended
                              )->value.

    "Adding an hour to the current time stamp
    DATA(ts20) = xco_cp=>sy->moment( )->add( iv_hour = 1
                                      )->as( xco_cp_time=>format->iso_8601_extended
                                      )->value.

    "Substractions
    DATA(ts21) = ts_ref1->subtract( iv_day = 1 iv_month = 2 iv_year = 3
                                  )->as( xco_cp_time=>format->iso_8601_extended
                                  )->value.

    DATA(ts22) = ts_ref2->subtract( iv_hour = 1 iv_minute = 2 iv_second = 4
                                  )->as( xco_cp_time=>format->iso_8601_extended
                                  )->value.

    "Substracting 1 year/month/day/hour/minute/second from the curernt time stamp
    DATA(ts23) = xco_cp=>sy->moment( )->subtract( iv_day = 1 iv_month = 1 iv_year = 1
                                                  iv_hour = 1 iv_minute = 1 iv_second = 1
                                     )->as( xco_cp_time=>format->iso_8601_extended
                                     )->value.

    "---- Excursion: Defining a time interval and checking if ----
    "---- a time stamp is within that time interval --------------

    "In the following example, a time interval is defined from the current time stamp
    "retrieved with XCO to a specified one. Using the 'contains' method and providing
    "another time stamp reference, it is checked whether that time stamp is contained
    "in the time interval. The return value is of type abap_bool. Using the lower_bound
    "and upper_bound attributes, the low and high values are retrieved.
    DATA(ts_ref3) =  xco_cp_time=>moment( iv_year   = '2030'
                                          iv_month  = '01'
                                          iv_day    = '01'
                                          iv_hour   = '10'
                                          iv_minute = '00'
                                          iv_second = '00' ).

    DATA(ts_ref4) =  xco_cp_time=>moment( iv_year   = '2028'
                                          iv_month  = '01'
                                          iv_day    = '01'
                                          iv_hour   = '11'
                                          iv_minute = '00'
                                          iv_second = '00' ).

    DATA(ts_interval) = xco_cp=>sy->moment( )->interval_to( ts_ref3 ).
    DATA(ts_in) = ts_interval->contains( ts_ref4 ).
    DATA(ts_interval_low) = ts_interval->lower_bound->as( xco_cp_time=>format->iso_8601_extended )->value.
    DATA(ts_interval_high) = ts_interval->upper_bound->as( xco_cp_time=>format->iso_8601_extended )->value.

    out->write( data = ts18 name = `ts18` ).
    out->write( |\n| ).
    out->write( data = ts19 name = `ts19` ).
    out->write( |\n| ).
    out->write( data = ts20 name = `ts20` ).
    out->write( |\n| ).
    out->write( data = ts21 name = `ts21` ).
    out->write( |\n| ).
    out->write( data = ts22 name = `ts22` ).
    out->write( |\n| ).
    out->write( data = ts23 name = `ts23` ).
    out->write( |\n| ).
    out->write( data = ts_in name = `ts_in` ).
    out->write( |\n| ).
    out->write( data = ts_interval_low name = `ts_interval_low` ).
    out->write( |\n| ).
    out->write( data = ts_interval_high name = `ts_interval_high` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Calculating Time Stamp Differences Using the Built-In Function utclong_diff` ) ).

    DATA(ts16) = CONV utclong( '2024-01-01 05:30:00' ).
    DATA(ts17) = CONV utclong( '2024-01-01 06:30:00' ).
    "The return value has the type decfloat34. It contains the exact
    "difference in seconds.

    DATA(ts_diff1) = utclong_diff( high = ts17
                                   low = ts16 ).

    DATA(ts_diff2) = utclong_diff( high = ts16
                                   low = ts17 ).

    out->write( data = ts_diff1 name = `ts_diff1` ).
    out->write( |\n| ).
    out->write( data = ts_diff2 name = `ts_diff2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) CONVERT UTCLONG: Time Stamp (utclong) -> Local Date/Time` ) ).

    DATA ts_utc TYPE utclong VALUE '2024-11-03 05:30:00'.

    CONVERT UTCLONG ts_utc
            INTO DATE DATA(date_est)
                 TIME DATA(time_est)
                 TIME ZONE 'EST'.

    out->write( data = date_est name = `date_est` ).
    out->write( |\n| ).
    out->write( data = time_est name = `time_est` ).
    out->write( |\n| ).

    "More optional additions:
    "- FRACTIONAL SECONDS: Getting the fractions of seconds
    "- DAYLIGHT SAVING TIME: Determining if the time stamp is
    "  in a daylight saving time (the example uses time stamp
    "  in August)
    CONVERT UTCLONG CONV utclong( '2024-08-08 09:23:11.7681270' )
            INTO DATE date_est
                 TIME time_est
                 FRACTIONAL SECONDS DATA(sec_est)
                 DAYLIGHT SAVING TIME DATA(dsl_est)
                 TIME ZONE 'EST'.

    out->write( data = date_est name = `date_est` ).
    out->write( |\n| ).
    out->write( data = time_est name = `time_est` ).
    out->write( |\n| ).
    out->write( data = sec_est name = `sec_est` ).
    out->write( |\n| ).
    out->write( data = dsl_est name = `dsl_est` ).
    out->write( |\n| ).

    "If the time zone specified is initial, there is no conversion.
    CONVERT UTCLONG CONV utclong( '2024-08-08 09:23:11.7681270' )
            INTO DATE DATA(date_init)
                 TIME DATA(time_init)
                 TIME ZONE VALUE #( ).

    out->write( data = date_init name = `date_init` ).
    out->write( |\n| ).
    out->write( data = time_init name = `time_init` ).
    out->write( |\n| ).

    "Specifying a non-existent time zone raises a catchable exception.
    TRY.
        CONVERT UTCLONG CONV utclong( '2024-08-08 09:23:11.7681270' )
                INTO DATE DATA(date_nope)
                     TIME DATA(time_nope)
                     TIME ZONE 'NOPE'.
      CATCH cx_sy_conversion_no_date_time INTO DATA(err_conv).
    ENDTRY.

    IF err_conv IS INITIAL.
      out->write( data = date_nope name = `date_nope` ).
      out->write( |\n| ).
      out->write( data = time_nope name = `time_nope` ).
    ELSE.
      out->write( data = err_conv->get_text( ) name = `err_conv->get_text( )` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) CONVERT INTO UTCLONG: Local Date/Time -> Time Stamp (utclong)` ) ).

    DATA date2utcl TYPE d VALUE '20240101'.
    DATA time2utcl TYPE t VALUE '112458'.
    DATA utcl TYPE utclong.

    CONVERT DATE date2utcl
            TIME time2utcl
            TIME ZONE 'EST'
            INTO UTCLONG utcl.

    out->write( data = utcl name = `utcl` ).
    out->write( |\n| ).

    "Using optional additions
    "Check the details in the ABAP Keyword Documentation.
    "Specifying 'X' for DAYLIGHT SAVING TIME in the following
    "example raises a catchable exception.
    CONVERT DATE date2utcl
            TIME time2utcl
            FRACTIONAL SECONDS CONV decfloat34( '0.768127' )
            DAYLIGHT SAVING TIME ''
            TIME ZONE 'EST'
            INTO UTCLONG DATA(utcl_inl1).

    out->write( data = utcl_inl1 name = `utcl_inl1` ).
    out->write( |\n| ).


    "There is no time shift in case of an initial time zone specification.
    CONVERT DATE date2utcl
            TIME time2utcl
            TIME ZONE VALUE #( )
            INTO UTCLONG DATA(utcl_inl2).

    out->write( data = utcl_inl2 name = `utcl_inl2` ).
    out->write( |\n| ).

    "Ensure that valid values are passed
    "The following example explores ABAP statements with invalid values
    "that are passed. The valid time stamp, the exceptions raised and
    "the error messages are added to an internal table.
    DATA error_checks TYPE string_table.
    DATA date_test TYPE d.
    DATA time_test TYPE t.
    DATA frac_sec_test TYPE decfloat34.
    DATA dls_test TYPE abap_bool.
    DATA tz_test TYPE string.
    DO 6 TIMES.
      date_test = '20240101'.
      time_test = '112458'.
      frac_sec_test = '0.768127'.
      dls_test = abap_false.
      tz_test = `EST`.

      CASE sy-index.
        WHEN 1.
          "No data object change. The statement below should return a valid time stamp.
        WHEN 2.
          "Invalid date
          "In newer ABAP releases, the following statement shows a
          "syntax warning that the date (intentionally specified as
          "invalid date here) does not match the type. Therefore,
          "the example is provided differently to circumvent the
          "syntax warning.

          "date_test = '20249999'.

          TYPES c_l8 TYPE c LENGTH 8.
          DATA falsedate TYPE c_l8 VALUE '20240231'.
          date_test = falsedate.
        WHEN 3.
          "Invalid time
          "The following statement is commented out for the reasons
          "mentioned above.

          "time_test = '992458'.

          TYPES c_l6 TYPE c LENGTH 6.
          DATA falsetime TYPE c_l6 VALUE '992458'.
          time_test = falsetime.
        WHEN 4.
          "Invalid fractions of seconds
          frac_sec_test = '1'.
        WHEN 5.
          "Invalid specification for this particular example.
          dls_test = 'X'.
        WHEN 6.
          "Invalid time zone
          "The following statement is commented out for the reasons
          "mentioned above.

          "dls_test = `NOPE`.

          TYPES c_l4 TYPE c LENGTH 4.
          DATA falsetimezone TYPE c_l4 VALUE 'NOPE'.
          dls_test = falsetimezone.
      ENDCASE.

      TRY.
          CONVERT DATE date_test
                  TIME time_test
                  FRACTIONAL SECONDS frac_sec_test
                  DAYLIGHT SAVING TIME dls_test
                  TIME ZONE tz_test
                  INTO UTCLONG DATA(utcl_inl3).
          error_checks = VALUE #( BASE error_checks ( |({ sy-index }) Valid time stamp: { utcl_inl3 }| ) ).
        CATCH cx_root INTO DATA(err).
          error_checks = VALUE #( BASE error_checks
            ( |({ sy-index }) Exception | &&
              |{ replace( val = cl_abap_typedescr=>describe_by_object_ref( err )->absolute_name
                          sub = `\CLASS=`
                          with = `` ) } was raised: | &&
              |{ err->get_text( ) }| ) ).
      ENDTRY.
    ENDDO.

    out->write( data = error_checks name = `error_checks` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) CL_ABAP_UTCLONG: Utilities for Time Stamps (utclong)` ) ).

    "Check the class documentation. More methods are available.
    DATA(low_timestamp) = CONV utclong( '2024-01-01 05:30:00' ).
    DATA(high_timestamp) = CONV utclong( '2024-01-03 10:35:12' ).

    "'diff' method: Calculating time differences
    cl_abap_utclong=>diff( EXPORTING high    = high_timestamp
                                     low     = low_timestamp
                           IMPORTING days    = DATA(diff_days)
                                     hours   = DATA(diff_hours)
                                     minutes = DATA(diff_minutes)
                                     seconds = DATA(diff_seconds) ).

    "Converting a time stamp from a character-like format to utclong
    "Creating a time stamp in a string
    DATA(ts_string) = |{ utclong_current( ) TIMESTAMP = ENVIRONMENT TIMEZONE = 'UTC' }|.
    TRY.
        cl_abap_utclong=>read( EXPORTING string   = ts_string
                                         timezone = 'UTC'
                               IMPORTING value    = DATA(utc_ts) ).
      CATCH cx_abap_utclong_invalid.
    ENDTRY.

    out->write( data = diff_days name = `diff_days` ).
    out->write( |\n| ).
    out->write( data = diff_hours name = `diff_hours` ).
    out->write( |\n| ).
    out->write( data = diff_minutes name = `diff_minutes` ).
    out->write( |\n| ).
    out->write( data = diff_seconds name = `diff_seconds` ).
    out->write( |\n| ).
    out->write( data = utc_ts name = `utc_ts` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) GET TIME STAMP: Retrieving the Current Time Stamp` ) ).

    "Short form
    DATA ts_short TYPE timestamp.
    GET TIME STAMP FIELD ts_short.

    "Long form
    DATA ts_long TYPE timestampl.
    GET TIME STAMP FIELD ts_long.

    "Note: When declaring the target data object inline,
    "the short form (type timestamp) is automatically used.
    GET TIME STAMP FIELD DATA(ts_inl).

    out->write( data = ts_short name = `ts_short` ).
    out->write( |\n| ).
    out->write( data = ts_long name = `ts_long` ).
    out->write( |\n| ).
    out->write( data = ts_inl name = `ts_inl` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) CONVERT TIME STAMP: Time Stamp in Packed Numbers -> Local Date/Time` ) ).

    GET TIME STAMP FIELD DATA(tsf). "Type timestamp
    "Retrieving the time zone of a given user
    TRY.
        DATA(user_tz) = cl_abap_context_info=>get_user_time_zone( ).
      CATCH cx_abap_context_info_error.
    ENDTRY.

    CONVERT TIME STAMP tsf
            TIME ZONE user_tz
            INTO DATE DATA(dat)
                 TIME DATA(tim).

    out->write( data = dat name = `dat` ).
    out->write( |\n| ).
    out->write( data = tim name = `tim` ).
    out->write( |\n| ).

    "Specifying a data object of type timestampl instead of timestamp.
    "In this case, the fractions of seconds in the decimal places are ignored.
    "A time zone is specified for which information is retrieved below.
    CONVERT TIME STAMP CONV timestampl( '20240101081317.81011' )
            TIME ZONE 'EST'
            INTO DATE dat
                 TIME tim.

    out->write( data = dat name = `dat` ).
    out->write( |\n| ).
    out->write( data = tim name = `tim` ).
    out->write( |\n| ).

    "Excursion: Time zone information for EST
    "Regarding the DAYLIGHT SAVING TIME additions used in some snippets with this
    "particular time zone: Among others, the result shows that timezoneisactive
    "is true.
    SELECT SINGLE *
      FROM i_timezone
      WHERE TimeZoneID = 'EST'
      INTO @DATA(tz_info).

    out->write( data = tz_info name = `tz_info` ).
    out->write( |\n| ).

    "Addition DAYLIGHT SAVING TIME (using a time stamp in August)
    CONVERT TIME STAMP CONV timestamp( '20240808112458' )
            TIME ZONE 'EST'
            INTO DATE dat
                 TIME tim
                 DAYLIGHT SAVING TIME DATA(dst).

    out->write( data = dat name = `dat` ).
    out->write( |\n| ).
    out->write( data = tim name = `tim` ).
    out->write( |\n| ).
    out->write( data = dst name = `dst` ).
    out->write( |\n| ).

    "sy-subrc is set. Find more details in the ABAP Keyword Documentation.
    "Specified time zone is invalid -> sy-subrc = 8
    "Note that specifying all targets after INTO is not mandatory.
    CONVERT TIME STAMP CONV timestamp( '20240808112458' )
            TIME ZONE 'NOPE'
            INTO DATE dat.
    IF sy-subrc = 8.
      out->write( `sy-subrc = 8` ).
      out->write( |\n| ).
    ENDIF.

    "Specified time stamp is invalid -> sy-subrc = 12
    CONVERT TIME STAMP CONV timestamp( '20249999112458' )
            TIME ZONE 'NOPE'
            INTO DATE dat.
    IF sy-subrc = 12.
      out->write( `sy-subrc = 12` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) CONVERT INTO TIME STAMP: Local Date/Time -> Time Stamp in Packed Numbers` ) ).

    DATA date4conv TYPE d VALUE '20240101'.
    DATA time4conv TYPE t VALUE '112458'.
    DATA ts_conv TYPE timestamp.

    CONVERT DATE date4conv
            TIME time4conv
            INTO TIME STAMP ts_conv
            TIME ZONE 'EST'.

    out->write( data = ts_conv name = `ts_conv` ).
    out->write( |\n| ).

    "Using the long form with type timestampl as target type and
    "setting the daylight saving time explicitly using the
    "optional addition DAYLIGHT SAVING TIME. Find more
    "details in the ABAP Keyword Documentation.
    DATA tsl_conv TYPE timestampl.
    CONVERT DATE CONV d( '20240101' )
            TIME CONV t( '112458' )
            INTO TIME STAMP tsl_conv
            TIME ZONE 'EST'.

    out->write( data = tsl_conv name = `tsl_conv` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) CL_ABAP_TSTMP: Calculating and Converting Time Stamps in Packed Numbers` ) ).

    "The following code snippets show a selection of methods available.

    "Creating a time stamp of type timestamp
    GET TIME STAMP FIELD DATA(ts4tstmp).

    "Calculations for time stamps in packed numbers
    "Adding 1 hour
    DATA(ts_add1h) = cl_abap_tstmp=>add( tstmp = ts4tstmp
                                    secs  = 3600 ).

    "Subtracting 2 hours
    DATA(ts_subtr2h) = cl_abap_tstmp=>subtractsecs( tstmp = ts4tstmp
                                             secs  = 7200 ).

    "Type timestampl
    DATA tsl TYPE timestampl.
    GET TIME STAMP FIELD tsl.

    "Converting type timestampl to timestamp
    DATA(long2short) = cl_abap_tstmp=>move_to_short( tsl ).

    "Converting types timestamp/timestampl to UTCLONG
    DATA(ts2utcl) = cl_abap_tstmp=>tstmp2utclong( tsl ).

    "Converting type utclong to timestamp
    DATA(utcl2ts) = cl_abap_tstmp=>utclong2tstmp_short( ts2utcl ).

    "Converting type utclong to timestampl
    DATA(utcl2tsl) = cl_abap_tstmp=>utclong2tstmp( ts2utcl ).

    out->write( data = ts_add1h name = `ts_add1h` ).
    out->write( |\n| ).
    out->write( data = ts_subtr2h name = `ts_subtr2h` ).
    out->write( |\n| ).
    out->write( data = long2short name = `long2short` ).
    out->write( |\n| ).
    out->write( data = ts2utcl name = `ts2utcl` ).
    out->write( |\n| ).
    out->write( data = utcl2ts name = `utcl2ts` ).
    out->write( |\n| ).
    out->write( data = utcl2tsl name = `utcl2tsl` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) Excursion: Unix Time Stamps` ) ).
    "Unix time stamp: Seconds passed since 1970-01-01 00:00:00 (UTC).

    "Getting the current UNIX time stamp using XCO
    DATA(unix_tstmp) = xco_cp=>sy->unix_timestamp( )->value.

    "Getting the UNIX time stamp from a custom time stamp
    DATA(unix_custom) = xco_cp_time=>moment( iv_year   = '2024'
                                             iv_month  = '11'
                                             iv_day    = '03'
                                             iv_hour   = '07'
                                             iv_minute = '12'
                                             iv_second = '30'
                                           )->get_unix_timestamp( )->value.

    "Using the unix time stamp with the utclong_add function to calculate
    "the actual date
    DATA(ts_from_unix1) = utclong_add( val = CONV utclong( '1970-01-01 00:00:00' )
                                       seconds = unix_tstmp ).

    DATA(ts_from_unix2) = utclong_add( val = CONV utclong( '1970-01-01 00:00:00' )
                                       seconds = unix_custom ).


    "1704102123 (corresponds to Jan 01 2024 09:42:03, UTC)
    DATA(ts_from_unix3) = utclong_add( val = CONV utclong( '1970-01-01 00:00:00' )
                                       seconds = 1704102123 ).

    out->write( data = unix_tstmp name = `unix_tstmp` ).
    out->write( |\n| ).
    out->write( data = unix_custom name = `unix_custom` ).
    out->write( |\n| ).
    out->write( data = ts_from_unix1 name = `ts_from_unix1` ).
    out->write( |\n| ).
    out->write( data = ts_from_unix2 name = `ts_from_unix2` ).
    out->write( |\n| ).
    out->write( data = ts_from_unix3 name = `ts_from_unix3` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) Date, Time, and Time Stamp in String Templates` ) ).

    "DATE: Defining the format of a date
    "The output is just an example and depends on your settings.
    DATA(d_str1) = |The date is { cl_abap_context_info=>get_system_date( ) DATE = USER }.|.
    DATA(d_str2) = |{ cl_abap_context_info=>get_system_date( ) DATE = RAW }|.
    DATA(d_str3) = |{ cl_abap_context_info=>get_system_date( ) DATE = ISO }|.
    DATA(d_str4) = |{ cl_abap_context_info=>get_system_date( ) DATE = ENVIRONMENT }|.

    "TIME: Defining the format of a time
    "The output is just an example and depends on your settings.
    DATA(tm_str1) = |The time is { cl_abap_context_info=>get_system_time( ) TIME = ISO }.|.
    DATA(tm_str2) = |{ cl_abap_context_info=>get_system_time( ) TIME = RAW }|.
    DATA(tm_str3) = |{ cl_abap_context_info=>get_system_time( ) TIME = USER }|.
    DATA(tm_str4) = |{ cl_abap_context_info=>get_system_time( ) TIME = ENVIRONMENT }|.

    "TIMESTAMP: Defining the format of a time stamp
    "The output is just an example and depends on your settings.
    DATA(ts_str1) = |{ utclong_current( ) TIMESTAMP = SPACE }|.
    DATA(ts_str2) = |{ utclong_current( ) TIMESTAMP = ISO }|.
    DATA(ts_str3) = |{ utclong_current( ) TIMESTAMP = USER }|.
    DATA(ts_str4) = |{ utclong_current( ) TIMESTAMP = ENVIRONMENT }|.
    DATA(ts_str5) = |{ utclong_current( ) }|.

    "TIMEZONE: Defining the format of a time stamp using the rules for time zones
    DATA(tz_str1) = |{ utclong_current( ) TIMEZONE = 'UTC' }|.
    DATA(tz_str2) = |{ utclong_current( ) TIMEZONE = 'CET' COUNTRY = 'DE ' }|.
    DATA(tz_str3) = |{ utclong_current( ) TIMEZONE = 'EST' COUNTRY = 'US ' }|.

    out->write( data = d_str1 name = `d_str1` ).
    out->write( |\n| ).
    out->write( data = d_str2 name = `d_str2` ).
    out->write( |\n| ).
    out->write( data = d_str3 name = `d_str3` ).
    out->write( |\n| ).
    out->write( data = d_str4 name = `d_str4` ).
    out->write( |\n| ).
    out->write( data = tm_str1 name = `tm_str1` ).
    out->write( |\n| ).
    out->write( data = tm_str2 name = `tm_str2` ).
    out->write( |\n| ).
    out->write( data = tm_str3 name = `tm_str3` ).
    out->write( |\n| ).
    out->write( data = tm_str4 name = `tm_str4` ).
    out->write( |\n| ).
    out->write( data = ts_str1 name = `ts_str1` ).
    out->write( |\n| ).
    out->write( data = ts_str2 name = `ts_str2` ).
    out->write( |\n| ).
    out->write( data = ts_str3 name = `ts_str3` ).
    out->write( |\n| ).
    out->write( data = ts_str4 name = `ts_str4` ).
    out->write( |\n| ).
    out->write( data = ts_str5 name = `ts_str5` ).
    out->write( |\n| ).
    out->write( data = tz_str1 name = `tz_str1` ).
    out->write( |\n| ).
    out->write( data = tz_str2 name = `tz_str2` ).
    out->write( |\n| ).
    out->write( data = tz_str3 name = `tz_str3` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Excursion: Typed Literals in ABAP SQL` ) ).

    SELECT SINGLE
      FROM i_timezone
      FIELDS *
      WHERE TimeZoneID = char`EST`
      INTO @DATA(wa_typed_literal).

    "Cast with a typed literal to cover a specification true to the
    "actually expected type. In the case of the example, the data type
    "char(6) is expected.
    SELECT SINGLE
      FROM i_timezone
      FIELDS *
      WHERE TimeZoneID = CAST( char`EST` AS CHAR( 6 ) )
      INTO @DATA(wa_typed_literal_cast).

    "Untyped literal
    SELECT SINGLE
      FROM i_timezone
      FIELDS *
      WHERE TimeZoneID = 'EST'
      INTO @DATA(wa_untyped_literal).

    "Various typed literals
    DATA(tmstamp) = CONV timestamp( '20240808112517' ).
    SELECT SINGLE
      FROM i_timezone
      FIELDS
        char`X` AS flag,
        int8`32984723948723` AS int8,
        raw`11` AS raw,
        numc`1234` AS numc,
        utclong`2024-01-01T10:01:02,2` AS utc,
        tims`101507` AS tims,
        curr`173.95` AS curr,
        "Multiple cast expressions splitting a time stamp into date and time parts
        CAST( CAST( div( @tmstamp, 1000000 ) AS CHAR ) AS DATS ) AS date,
        CAST( substring( CAST( @tmstamp AS CHAR ), 9, 6 ) AS TIMS ) AS time,
        'ABAP' AS txt "Untyped literal
      WHERE TimeZoneID = CAST( char`EST` AS CHAR( 6 ) )
      INTO @DATA(wa_some_typed_literals).

    out->write( data = wa_typed_literal name = `wa_typed_literal` ).
    out->write( |\n| ).
    out->write( data = wa_typed_literal_cast name = `wa_typed_literal_cast` ).
    out->write( |\n| ).
    out->write( data = wa_untyped_literal name = `wa_untyped_literal` ).
    out->write( |\n| ).
    out->write( data = wa_some_typed_literals name = `wa_some_typed_literals` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Date and Time Functions in ABAP SQL` ) ).

    "The following demo ABAP SQL SELECT statement selects from a
    "CDS view. The FIELDS list contains many functions related to
    "date, time, and time stamp processing. For more details,
    "see the ABAP Keyword Documentation.
    "Some of the parameters are assigned typed literals.
    DATA da TYPE d VALUE '20240122'.
    DATA ti TYPE t VALUE '123456'.
    DATA utc TYPE utclong VALUE '2024-02-15 05:30:00'.
    DATA tmst TYPE timestamp VALUE '20240808112458'.
    DATA tmstlong TYPE timestampl VALUE '20240101081317.81011'.

    SELECT SINGLE FROM i_timezone
    FIELDS
      "---------------------- Date ----------------------
      "Generic date functions (types d, utclong)
      is_valid( @ti ) AS isvalid, "type t also possible
      "In the following examples in this 'section', d and utclong are possible.
      extract_year( @utc ) AS extr_year,
      extract_month( @da ) AS extr_month,
      extract_day( @utc ) AS extr_day,
      dayname( @da ) AS day_name,
      monthname( @utc ) AS month_name,
      weekday( @utc ) AS week_day,
      days_between( @utc,utclong`2024-02-25 08:14:26` ) AS days_bw,
      add_days( @da,2 ) AS add_days,
      add_months( @utc,3 ) AS add_months,

      "Functions for the type datn
      datn_days_between( datn`20240111`,datn`20240212` ) AS days_datn_bw,
      datn_add_days( datn`20240111`,4 ) AS days_datn_add,
      datn_add_months( datn`20240111`,5 ) AS months_datn_add,

      "Functions for the type dats
      dats_is_valid( dats`20240812` ) AS dats_valid,
      dats_days_between( dats`20240812`,dats`20240817` ) AS days_dats_bw,
      dats_add_days( dats`20240812`,4 ) AS days_dats_add,
      dats_add_months( dats`20240812`,3 ) AS months_dats_add,

      "---------------------- Time ----------------------
      "Generic time functions (types t and utclong)
      is_valid( @ti ) AS time_is_valid, "As above, types d and utclong also possible
      extract_hour( @utc ) AS extr_hour,
      extract_minute( @ti ) AS extr_min,
      extract_second( @utc ) AS extr_sec,

      "Function for the type tims
      tims_is_valid( tims`231256` ) AS tims_is_valid,

      "---------------------- Time Stamp ----------------------
      "Note: The type utclong can be used in the generic functions above.
      "Functions specific to the type utclong
      utcl_current( ) AS utcl_current, "generates a UTC time stamp
      utcl_add_seconds( @utc,5 ) AS sec_add_utc,
      utcl_seconds_between( utclong`2024-02-25 08:14:26`,utclong`2024-02-25 08:15:17` ) AS sec_bw_utc,

      "Functions specific to the type timetamp
      tstmp_is_valid( @tmst ) AS ts_is_valid,
      tstmp_current_utctimestamp( ) AS ts_current,
      "The following two functions have an optional parameter on_error.
      "Check the ABAP Keyword Documentation
      tstmp_seconds_between( tstmp1 = @tmst,
                              tstmp2 = CAST( dec`20240808112517` AS DEC( 15,0 ) ) ) AS sec_bw_ts,
      tstmp_add_seconds( tstmp    = @tmst,
                          seconds  = CAST( dec`10` AS DEC( 15,0 ) ) ) AS sec_add_ts,

      "---------------------- Functions for conversions ----------------------
      "Note: For the following functions, optional parameters are possible.
      "For more details, check the ABAP Keyword Documentation.
      tstmp_to_dats( tstmp = @tmst,
                      tzone =  CAST( char`EST` AS CHAR( 6 ) ) ) AS tstmp_to_dats,
      tstmp_to_tims( tstmp = @tmst,
                      tzone = CAST( char`EST` AS CHAR( 6 ) ) ) AS tstmp_to_tims,
      tstmp_to_dst( tstmp = @tmst,
                    tzone = CAST( char`EST` AS CHAR( 6 ) ) ) AS tstmp_to_dst,
      dats_tims_to_tstmp( date = @da,
                          time = @ti,
                          tzone = CAST( char`EST` AS CHAR( 6 ) ) ) AS dats_tims_to_tstmp,
      tstmpl_to_utcl( tstmpl = @tmstlong ) AS tstmpl_to_utcl,
      tstmpl_from_utcl( utcl = @utc ) AS tstmpl_from_utcl,
      dats_to_datn( dats = dats`20240812` ) AS dats_to_datn,
      dats_from_datn( datn = datn`20240111` ) AS dats_from_datn,
      tims_to_timn( tims = tims`231256` ) AS tims_to_timn,
      tims_from_timn( timn = timn`155432` ) AS tims_from_timn

    WHERE TimeZoneID = char`EST`
    INTO @DATA(wa).

    out->write( data = wa name = `wa` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) Excursion: ABAP Stopwatch` ) ).
    "This excursion example demonstrates an ABAP stopwatch. This stopwatch
    "is represented by a local class implemented in the CCIMP include of the
    "class ('Local Types' tab in ADT). With the stopwatch, the elapsed
    "runtime can be stored and ouput. The example is intended to be a
    "playground for exploring time-related functions, and does not claim
    "to be a runtime timer for non-demo use cases.
    "To start the stopwatch, an instance of the stopwatch class must be
    "created. This is done using the 'create' method that returns an
    "instance of the (local) stopwatch class. To start the stopwatch,
    "the 'start' method must be called. To stop it, call the 'stop' method.
    "The elapsed time can then be retrieved using the 'get_time' method.
    "To get the time after starting the stopwatch, you can also directly
    "call the 'get_time' method without explicitly stopping since it
    "includes the stop call.
    "The stopwatch also enables the storage of multiple time intervals. You
    "can use the 'store' method. The resulting time intervals can be
    "retrieved using the 'get_stored_times' method. It returns an internal
    "table that includes the times of each interval since the start and the
    "delta to previous time intervals.

    out->write( |----------- Starting and stopping -----------\n| ).

    "Creating a stopwatch instance
    DATA(stopwatch) = lcl_stopwatch=>create( ).
    "Starting stopwatch
    stopwatch->start( ).

    "Do something
    DO 100000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    "Stopping stopwatch
    stopwatch->stop( ).
    "Getting the time
    DATA(sw_time1) = stopwatch->get_time( ).
    out->write( sw_time1 ).

    "More stopwatch runs
    stopwatch->start( ).

    DO 1000000 TIMES.
      ASSERT 1 = 1.
    ENDDO.
    stopwatch->stop( ).

    DATA(sw_time2) = stopwatch->get_time( ).
    out->write( sw_time2 ).

    stopwatch->start( ).

    DO 10000000 TIMES.
      ASSERT 1 = 1.
    ENDDO.
    stopwatch->stop( ).

    DATA(sw_time3) = stopwatch->get_time( ).
    out->write( sw_time3 ).

    out->write( |\n--- Testing read performance with secondary table keys ---\n| ).

    "The following example creates two demo internal tables. One without a secondary table
    "key and the other with a secondary table key. Consider a scenario where you have an
    "internal table without a secondary table key, and you want to add a secondary table
    "key later to improve read performance. The tables are populated with a lot of data.
    "Then, in a DO loop, many reads are performed on the internal tables. One example uses
    "a free key for the read, the other uses a secondary table key. Using the stopwatch,
    "the elapsed times are retrieved. There should be a significant delta of the elapsed
    "time, showing that the access using the secondary table key is faster.
    TYPES: BEGIN OF demo_struc,
             idx TYPE i,
             str TYPE string,
             num TYPE i,
           END OF demo_struc.

    DATA itab TYPE HASHED TABLE OF demo_struc WITH UNIQUE KEY idx.
    DATA itab_sec TYPE HASHED TABLE OF demo_struc
                  WITH UNIQUE KEY idx
                  WITH NON-UNIQUE SORTED KEY sk
                       COMPONENTS str num.

    DO 500 TIMES.
      INSERT VALUE #( idx = sy-index
                      str = |INDEX{ sy-index }|
                      num = sy-index ) INTO TABLE itab.
    ENDDO.
    itab_sec = itab.

    stopwatch->start( ).
    DO 500 TIMES.
      "Reading into a data reference variable using using a free key.
      "This free key corresponds to the secondary table key specified
      "for the table in the second example.
      DATA(dref) = REF #( itab[ str = `INDEX250` num = 250 ] ).
    ENDDO.
    stopwatch->stop( ).
    DATA(time_free_key) = stopwatch->get_time( ).
    out->write( |{ time_free_key } (free key)| ).

    stopwatch->start( ).
    DO 500 TIMES.
      "Reading from an internal table using the secondary table key
      dref = REF #( itab_sec[ KEY sk str = `INDEX250` num = 250 ] ).
    ENDDO.
    stopwatch->stop( ).
    DATA(time_secondary_key) = stopwatch->get_time( ).
    out->write( |{ time_secondary_key } (secondary key)| ).

    out->write( |\n----------- Another demo run -----------\n| ).
    "In this demo run, the stopwatch is not explicitly stopped.
    "This is done implicitly when calling the get_time method.

    stopwatch->start( ).

    DO 100000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    DATA(sw_time4) = stopwatch->get_time( ).
    out->write( sw_time4 ).

    stopwatch->start( ).

    DO 1000000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    DATA(sw_time5) = stopwatch->get_time( ).
    out->write( sw_time5 ).
    stopwatch->start( ).

    DO 10000000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    DATA(sw_time6) = stopwatch->get_time( ).
    out->write( sw_time6 ).

    out->write( |\n----------- Storing multiple intervals -----------\n\n| ).
    stopwatch->start( ).

    DO 100000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    "Storing interval 1
    stopwatch->store( ).

    DO 1000000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    "Storing interval 2
    stopwatch->store( ).

    DO 10000000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    "Storing interval 3
    stopwatch->store( ).

    DO 100 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    "Storing interval 4
    stopwatch->store( ).

    DO 10000 TIMES.
      ASSERT 1 = 1.
    ENDDO.

    ""Storing interval 5
    stopwatch->store( ).
    stopwatch->stop( ).

    "Getting stored times
    DATA(stored_times) = stopwatch->get_stored_times( ).
    out->write( stored_times ).
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS lcl_stopwatch DEFINITION.
  PUBLIC SECTION.
 CLASS-METHODS create
      RETURNING
        VALUE(sw_inst) TYPE REF TO lcl_stopwatch.

    METHODS stop.
    METHODS start.
    METHODS store.

    TYPES: BEGIN OF stored_times_struc,
             interval TYPE i,
             time_since_start TYPE string,
             time_delta  TYPE string,
           END OF stored_times_struc.
    TYPES stored_times_type TYPE SORTED TABLE OF stored_times_struc WITH UNIQUE KEY interval.
    METHODS get_stored_times RETURNING VALUE(time) TYPE stored_times_type .
    METHODS get_time RETURNING VALUE(time) TYPE string .

  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA time_start TYPE utclong.
    DATA time_stop TYPE utclong.
    DATA stopwatch_is_on TYPE abap_bool.
    DATA interval_timer_is_on TYPE abap_bool.
    TYPES: BEGIN OF time_struc,
             days    TYPE i,
             hours   TYPE i,
             minutes TYPE int8,
             seconds TYPE decfloat34,
           END OF time_struc.
    DATA time_elapsed TYPE time_struc.
    TYPES cl2 TYPE c LENGTH 2.
    DATA storage TYPE TABLE OF utclong WITH EMPTY KEY.

    METHODS reset.
    METHODS get_elapsed_time
      IMPORTING start        TYPE utclong
                stop         TYPE utclong
      RETURNING VALUE(delta) TYPE time_struc.

    METHODS time_output_prep
      IMPORTING time       TYPE time_struc
      RETURNING VALUE(res) TYPE string.
ENDCLASS.

CLASS lcl_stopwatch IMPLEMENTATION.
  METHOD create.
    sw_inst = NEW #( ).
    sw_inst->reset( ).
  ENDMETHOD.

  METHOD start.
    "No multiple starts allowed
    ASSERT stopwatch_is_on = abap_false.
    ASSERT interval_timer_is_on = abap_false.
    reset( ).
    stopwatch_is_on = abap_true.
    time_start = utclong_current( ).
  ENDMETHOD.

  METHOD stop.
    ASSERT stopwatch_is_on = abap_true.
    time_stop = utclong_current( ).
    stopwatch_is_on = abap_false.
    interval_timer_is_on = abap_false.
    time_elapsed = get_elapsed_time( start = time_start
                                     stop = time_stop ).
  ENDMETHOD.

  METHOD reset.
    CLEAR: time_start,
           time_stop,
           time_elapsed,
           stopwatch_is_on,
           interval_timer_is_on,
           storage.
  ENDMETHOD.

  METHOD get_elapsed_time.
    cl_abap_utclong=>diff( EXPORTING high     = stop
                                     low      = start
                            IMPORTING days    = delta-days
                                      hours   = delta-hours
                                      minutes = delta-minutes
                                      seconds = delta-seconds ).
  ENDMETHOD.

  METHOD get_time.
    "When the interval timer is on, it is not allowed to
    "get the time. The get_stored_times method is to be used.
    ASSERT interval_timer_is_on = abap_false.
    IF stopwatch_is_on = abap_true.
      stop( ).
    ENDIF.
    time = time_output_prep( time_elapsed ).
  ENDMETHOD.

  METHOD time_output_prep.
    res = |{ COND #( WHEN time-days IS NOT INITIAL THEN time-days && ` days, ` ) }| &&
          |{ COND #( WHEN numofchar( CONV cl2( time-hours ) ) = 1 THEN `0` && time-hours ELSE time-hours ) }:| &&
          |{ COND #( WHEN numofchar( CONV cl2( time-minutes ) ) = 1 THEN `0` && time-minutes ELSE time-minutes ) }:| &&
          |{ COND #( WHEN find( val = CONV string( time-seconds ) sub = `.` ) = 1 THEN `0` && time-seconds ELSE time-seconds ) }|.
  ENDMETHOD.

  METHOD store.
    ASSERT stopwatch_is_on = abap_true.
    interval_timer_is_on = abap_true.
    APPEND utclong_current( ) TO storage.
  ENDMETHOD.

  METHOD get_stored_times.
    IF interval_timer_is_on = abap_true.
      stop( ).
    ENDIF.

    if lines( storage ) > 0.
    LOOP AT storage REFERENCE INTO DATA(ref).
      DATA(tabix) = sy-tabix.
      DATA(time_since_start) = get_elapsed_time( start = time_start stop = ref->* ).
      DATA(prep_time_since_start) = time_output_prep( time_since_start ).
      DATA(time_delta) = get_elapsed_time( start = COND #( WHEN tabix = 1 THEN time_start ELSE storage[ tabix - 1 ] ) stop = ref->* ).
      DATA(prep_time_delta) = time_output_prep( time_delta ).
      INSERT VALUE #( interval = tabix
                      time_since_start = prep_time_since_start
                      time_delta = prep_time_delta ) INTO TABLE time.
    ENDLOOP.
    endif.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_dtype_dobj DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.
    CLASS-METHODS:
      class_constructor.

    TYPES t_pub_text_c30 TYPE c LENGTH 30.
    CONSTANTS: comma TYPE string VALUE `, `.
    CLASS-DATA: read_only_attribute TYPE string VALUE `Hallo` READ-ONLY.

  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES t_prv_text_c30 TYPE c LENGTH 30.
    CLASS-DATA cl_text TYPE t_prv_text_c30.
    DATA text TYPE t_pub_text_c30 VALUE '!!!'.

    METHODS adapt_text RETURNING VALUE(str) TYPE string.

    METHODS addition_with_generic_num IMPORTING num1          TYPE numeric
                                                num2          TYPE numeric
                                      RETURNING VALUE(result) TYPE decfloat34.

**********************************************************************

    "Types and methods for demonstrating enumerated types and objects

    "The definition of an enumerated type in ABAP declares its enumerated constants (these are special enumerated objects).
    "a) In the case below, no explicit base type is specified. Then, the standard base type of the constants is i. The
    "   enumerated values are counted up starting with 0 (a -> 0, b -> 1 ...).

    TYPES: BEGIN OF ENUM t_enum,
             a,
             b,
             c,
             d,
           END OF ENUM t_enum.

    "b) For the following enumerated type, an explicit base type is specified and start values provided using the VALUE addition
    "   Note that one value must be initial.

    TYPES: basetype TYPE c LENGTH 2,
           BEGIN OF ENUM t_enum_base BASE TYPE basetype,
             "If VALUE is specified explicitly, VALUE IS INITIAL must be used exactly once.
             e VALUE IS INITIAL,
             f VALUE 'u',
             g VALUE 'v',
             h VALUE 'wx',
             i VALUE 'yz',
           END OF ENUM t_enum_base.

    "c) Optionally an enumerated structure can be declared in the context of the type declaration.
    "Use case: If you have more than one enumerated type within one context. In doing so, you declare a constant enumeration structure.
    "The components of the structure are the enumeration constants of the enumerated type.
    TYPES: BEGIN OF ENUM t_enum_struc STRUCTURE en_struc BASE TYPE basetype,
             j VALUE IS INITIAL,
             k VALUE 'hi',
             l VALUE 'ab',
             m VALUE 'ap',
           END OF ENUM t_enum_struc STRUCTURE en_struc.


    METHODS enum_meth_params IMPORTING char          TYPE t_enum
                             RETURNING VALUE(output) TYPE string.
    METHODS enum_processing RETURNING VALUE(output) TYPE string_table.
    METHODS rtti_enum RETURNING VALUE(output) TYPE string_table.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_dtype_dobj IMPLEMENTATION.


  METHOD adapt_text.
    DATA text TYPE t_pub_text_c30.

    text = cl_text && comma && sy-uname && me->text.

    str = text && | (Note: The value of me->text is "{ me->text }")|.
  ENDMETHOD.


  METHOD addition_with_generic_num.
    result = num1 + num2.
  ENDMETHOD.


  METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.


  METHOD enum_meth_params.

    CASE char.
      WHEN a.
        output = a.
      WHEN b.
        output = b.
      WHEN OTHERS.
        output = `Either c or d: ` && char.
    ENDCASE.

  ENDMETHOD.


  METHOD enum_processing.

    "Read and write positions of enumerated objects
    "Enumerated objects can be used in all read positions in which the operand
    "type is their enumerated type.
    "Likewise, enumerated variables can only be used in write positions in which
    "the operand type is the enumerated type and only the associated enumerated
    "values can be written.
    "So, assignments are possible only from one enumerated type to the same (with one
    "exception -> assignment to character-like variables of the types c and string)
    DATA do_enum TYPE t_enum.
    do_enum = a.
    APPEND |do_enum: { do_enum }| TO output.

    DATA do_enum_2 LIKE do_enum.
    do_enum_2 = do_enum.
    APPEND |do_enum_2: { do_enum_2 }| TO output.

    "Assignment to character-like variables of the types c and string.
    "In this case, the target field is assigned the name of the enumerated constant or
    "the component of the enumerated structure under which the enumerated value of the
    "source field is defined in the enumerated type.
    DATA do_a_string TYPE string.
    do_a_string = do_enum.
    APPEND |do_a_string: { do_a_string }| TO output.

    "Or using the CONV operator as follows
    DATA(do_next_string) = CONV string( do_enum ).
    APPEND |do_next_string: { do_next_string }| TO output.

    "Enumerated constants are converted implicitly to the type string
    "before the concatenation in the string template.
    DATA(str_from_enum) = |{ a }{ b }{ c }{ d }|.
    APPEND |str_from_enum: { str_from_enum }| TO output.

    "Note that only the enumerated type itself is relevant. Usually, the content
    "of an enumerated object is not of interest.
    "The enumerated value in the base type can be accessed using the constructor
    "operators CONV and EXACT only. The base type is i in this case.
    DATA(conv_value) = CONV i( do_enum ).
    APPEND |conv_value: { conv_value }| TO output.

    "Converting the other way round.
    DATA(another_conv) = CONV t_enum( 3 ).
    APPEND |another_conv: { another_conv }| TO output.

    "If known statically, an attempt to assign a value other than a valid enumerated value
    "to an enumerated variable produces a syntax error.
    "If not known statically, an exception is raised.
    "The following produces a syntax error
    "do_enum = f.

    "The following example shows raising an exception.
    DATA dobj TYPE t_enum.

    TYPES t_int_tab TYPE TABLE OF i WITH EMPTY KEY.
    DATA(int_tab) = VALUE t_int_tab( ( 0 ) ( 1 ) ( 2 ) ( 3 ) ( 4 ) ).

    DATA str_tab TYPE TABLE OF string.
    LOOP AT int_tab INTO DATA(wa_en).
      TRY.
          dobj = CONV t_enum( wa_en ).
          APPEND dobj TO str_tab.
        CATCH cx_sy_conversion_no_enum_value INTO DATA(error_enum).
          APPEND error_enum->get_text( ) TO str_tab.
      ENDTRY.
    ENDLOOP.

    APPEND `------------- START: Output for str_tab -------------` TO output.
    APPEND LINES OF str_tab TO output.
    APPEND `^^^^^^^^^^^^^ END: Output for str_tab ^^^^^^^^^^^^^` TO output.

    "An enumerated variable can be set to the initial value of its base type
    "using CLEAR.
    CLEAR do_enum.
    APPEND |do_enum: { do_enum }| TO output.

    "Enumerated structures
    DATA do_enum_s TYPE t_enum_struc.

    "The enumerated structure en_struc was decalred in the public section.
    "Using the addition LIKE, a second structure is created referring to the enumerated structure.
    "Note that the second structure is not a constant structure.
    "The components of the constant structure contain the enumerated values of the enumerated type.
    "All the components of the variable structure declared by LIKE contain the initial values.
    DATA do_s LIKE en_struc.
    APPEND |do_s: { do_s-j } / { do_s-k } / { do_s-l } / { do_s-m }| TO output.

    DATA(do_en) = en_struc.
    APPEND |do_en: { do_en-j } / { do_en-k } / { do_en-l } / { do_en-m }| TO output.

    "Accessing structure components using the component selector
    DATA(do_en_k) = en_struc-k.
    APPEND |do_en_k: { do_en_k }| TO output.

    DATA(do_s_m) = do_s-m.
    APPEND |do_s_m: { do_s_m }| TO output.
    "Assigning enumerated constants to the variable structure
    do_s = en_struc.
    APPEND |do_s: { do_s-j } / { do_s-k } / { do_s-l } / { do_s-m }| TO output.

  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Data Types and Data Objects\n\n| ).

**********************************************************************

    out->write( |Declaring data types\n\n| ).

    "The following examples deal with the declaration of data types.
    "They show how data types can be declared locally in an ABAP program.
    "Note:
    "- Data types can also be declared in the ABAP Dictionary (DDIC) or as a
    "  CDS entity, which is not covered in this demo example.
    "- In ADT and because of the many type declarations, you may want to press
    "  F2 on the types to get more information.
    "- The examples show a selection.
    "- Only non-generic types can be used.

    out->write( |1) Declaring data types based on elementary types\n\n| ).

    "See the ABAP Keyword Documentation for the value ranges that are
    "accepted by these types.

    "Data type declarations based on built-in ABAP types

    "Numeric types
    TYPES te_i TYPE i.
    TYPES te_int8 TYPE int8.
    TYPES te_decfl16 TYPE decfloat16.
    TYPES te_decfl34 TYPE decfloat34.
    TYPES te_f TYPE f.
    TYPES te_p_l4_d2 TYPE p LENGTH 4 DECIMALS 2.
    "Note: LENGTH/DECIMALS must be specified when using the types c, p, n, x
    "in ABAP Objects contexts as it is the case here in the example class.

    "Character-like types
    "To combine TYPES statements, you can use chained statements,
    "i.e. TYPES followed by a colon and then listing the type declarations separated
    "by a comma.
    TYPES: te_c5  TYPE c LENGTH 5,
           te_n4  TYPE n LENGTH 4,
           te_str TYPE string.

    "Byte-like types
    TYPES te_do_string TYPE x LENGTH 2.
    TYPES te_xstr TYPE xstring.

    "Types for date and time
    TYPES te_d TYPE d.
    TYPES te_t TYPE t.
    TYPES te_utc TYPE utclong.

    "You might also stumble on a length specification in parentheses following the
    "data type name. It is recommended that you use addition LENGTH instead of the
    "parentheses.
    TYPES te_cfour(4) TYPE c.

    "**** Data type declarations based on existing types or data objects ****

    "Type declaration based on an existing type visible at this location;
    "all properties of the specified data type are inherited.
    TYPES te_another_i TYPE te_i.

    "Anticipating the data object declaration needed to demonstrate the LIKE addition
    DATA do_num TYPE i.

    "LIKE addition:
    "Type declaration based on an existing data object visible at this location;
    "all properties of the type of the specified data object are inherited.
    TYPES te_from_int LIKE do_num.

    "**** Data type declarations based on globally available types or data objects ****

    "DDIC Types
    "Note that the built-in types b and s cannot be specified for type
    "declarations. However, the value range for these types can be obtained by
    "referencing the built-in DDIC types INT1 and INT2. These are data elements.
    "In ADT, you can check out the data elements by forward navigation (hold CTRL
    "and click on the type). You can also use F2 Information (click F2 when on
    "the type) to get information.
    TYPES te_int1 TYPE int1.
    TYPES te_int2 TYPE int2.

    "Referring to types in global classes
    "Also here, check out the forward navigation or F2 information for the types.
    "In the example, the type exists in a global interface.
    TYPES te_elem_from_itf TYPE zdemo_abap_get_data_itf=>occ_rate.

    "Referring to a data object that exists in a global interface
    TYPES te_dobj_from_itf LIKE zdemo_abap_objects_interface=>stat_str.

    "Referring to a data object that exists in the public visibility section of
    "a global class
    TYPES te_dobj_from_cl LIKE zcl_demo_abap_objects=>public_string.

    "Referring to a component of a DDIC table (also possible for views;
    "the components have elementary types)
    TYPES te_comp_ddic_tab TYPE zdemo_abap_carr-carrid.

    "Type pools (ABAP program, administrated by the ABAP Dictionary; may only be
    "created in standard ABAP; but is considered obsolete).
    "However, the following example is accessible in ABAP for Cloud Development.
    "The type pool contains the definitions of globally visible data types and
    "constants. Check it out using the forward navigation and the F2 information.
    TYPES te_tp TYPE abap_bool.
    TYPES te_const_in_tp LIKE abap_true.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Declaring data types based on complex types` ) ).

    "Structure and internal table types as examples for complex types

    "Structure type, can contain any type
    TYPES: BEGIN OF ts_misc_comps,
             comp1 TYPE i,
             comp2 TYPE string,
             comp3 TYPE te_i,                                    "Existing type
             comp4 LIKE do_num,                                  "Referring to existing data object
             comp5 TYPE string_table,                            "Internal table type (available in DDIC)
             comp6 TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY, "Internal table type (based on database table)
             comp7 TYPE REF TO i,                                "Reference type
           END OF ts_misc_comps.

    "Internal table types
    "Note: The examples only use the implicit STANDARD for standard tables.
    "Internal table type declaration based on a local structure type
    TYPES tt_local_ts TYPE TABLE OF ts_misc_comps WITH EMPTY KEY.

    "Internal table type declaration based on an elementary data type
    TYPES tt_int TYPE TABLE OF i.

    "Referring to existing types and data objects

    "Anticipating the creation of structured data objects for the LIKE addition
    DATA struc_local_ts TYPE ts_misc_comps.

    "Structure type creation based on an existing structured data object
    TYPES ts_w_like LIKE struc_local_ts.

    "Anticipating the creation of an internal table for the LIKE addition
    DATA itab_local_ts TYPE TABLE OF ts_misc_comps WITH EMPTY KEY.

    "Internal table type declaration based on an existing internal table
    TYPES tt_w_like LIKE itab_local_ts.

    "Internal table type declaration based on the existing internal table type
    TYPES tt_another_type TYPE tt_w_like.

    "Structured types based on an internal table's line type
    TYPES ts_type_line TYPE LINE OF tt_w_like.
    TYPES ts_like_line LIKE LINE OF itab_local_ts.

    "Internal table typed with internal table as line type
    TYPES tt_like_table LIKE TABLE OF itab_local_ts.

    "Referring to global types

    "Structure type based on DDIC type
    "In this case, a database table is specified whose line type is used as data type
    "in this type declaration. You may also use a CDS view (or classic DDIC view in
    "standard ABAP) or a dedicated structured type defined in the DDIC.
    TYPES ts_ddic_tab TYPE zdemo_abap_carr.

    "Internal table type based on internal type that exists in a gloabl interface
    TYPES tt_tab_type_from_itf TYPE zdemo_abap_get_data_itf=>carr_tab.

    "Internal table types with an elementary line type based on globally available types
    "Elementary table type
    TYPES tt_strtab TYPE string_table.
    "Elementary line type; the type is available in a global interface
    TYPES tt_elem_type_from_itf TYPE TABLE OF zdemo_abap_get_data_itf=>occ_rate.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Declaring reference types` ) ).

    "Declaring reference types with static types
    TYPES tr_i TYPE REF TO i.
    TYPES tr_str TYPE REF TO string.
    TYPES tr_ddic_tab TYPE REF TO zdemo_abap_carr.
    "Using the generic type data as static type
    TYPES tr_data TYPE REF TO data.

    "Referring to an existing reference type
    TYPES tr_ref_i TYPE tr_i.

    "Anticipating the creation of a data reference variable for showing
    "the LIKE addition
    DATA dref_i TYPE REF TO i.

    "Creating a reference type based on a data reference variable
    TYPES tr_like_ref_i LIKE dref_i.

    "Creating a data object for the LIKE REF TO addition
    DATA str TYPE string.

    "Creating a reference type whose static type is inherited from the data
    "type of the specified data object
    TYPES tr_like_ref2str LIKE REF TO str.

    "Reference table types
    TYPES tr_tab_ref_i TYPE TABLE OF REF TO i.
    DATA itab_str TYPE TABLE OF string.
    TYPES tr_like_table_ref LIKE TABLE OF REF TO itab_str.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Declaring data objects` ) ).

    "The following examples deal with the declaration of data ojects.
    "They show how data objects can be declared locally in an ABAP program.
    "Note:
    "- With the exception of two additions (VALUE and READ-ONLY), the syntax
    "  follows the pattern as for TYPES statements.
    "- A data type defined using DATA, which is not derived from an existing type,
    "  is available only as a property of the
    "  declared data object and not on its own. This kind of data type is bound to
    "  its data object.
    "- The examples show the creation of named data objects. Anonymous data objects
    "  are covered below.
    "- In ADT and because of the many type declarations, you may want to press F2 on
    "  the types to get more information.
    "- The examples show a selection. For more information, check out the ABAP
    "  Keyword Documentation.

    out->write( |4) Declaring data objects based on elementary data types\n\n| ).

    "The elementary, built-in data types can be used as shown for data type
    " declarations. Chained statements are also possible with DATA.
    "Note that not all types as shown above are used here.
    DATA: do_i       TYPE i,
          do_c_l5    TYPE c LENGTH 5,
          do_p_l3_d2 TYPE p LENGTH 3 DECIMALS 2,
          do_decfl16 TYPE decfloat16,
          do_str     TYPE string,
          "Specifying the length in parantheses instead of using the
          "LENGTH addition is not recommended
          do_ctwo(2) TYPE c.

    "Referring to locally declared data types
    TYPES te_string TYPE string.
    DATA do_another_str TYPE te_string.

    "Referring to other data objects
    DATA do_like_dobj LIKE do_i.

    "If the length is not specified explicitly for the ABAP types c, n, p, and x,
    "the standard length is defined implicitly. Check the F2 information.
    DATA do_c_std TYPE c.
    DATA do_p_std TYPE p.

    "If neither TYPE nor LIKE is specified, a data object with the bound
    "data type 'c LENGTH 1' is created.
    DATA do_c.

    "VALUE addition
    "Start values can be set for the data objects when they are declared.
    "Without the addition VALUE, data objects are filled with their type-specific
    "initial values. The start value can either be specified as a literal or as a
    "predefined constant.
    "Note: The VALUE addition is not to be confused with the VALUE operator that
    "can be used to construct the content of complex data objects as shown below.
    DATA do_c_l2 TYPE c LENGTH 2 VALUE 'hi'.
    DATA do_i_val TYPE i VALUE 123.
    DATA do_like_val LIKE do_i VALUE 9.

    "Specifying a constant (data object that cannot be changed at runtime) after
    "the VALUE addition
    CONSTANTS con TYPE string VALUE `abcdef`.
    DATA do_val_con TYPE string VALUE con.

    "VALUE IS INITIAL addition: Explicitly specifying the type-specific initial value
    DATA do_i_init TYPE i VALUE IS INITIAL.
    DATA do_i_like_init LIKE do_i VALUE IS INITIAL.

    "Data objects can also be created in the declaration part of classes and
    "interfaces. There you can use the READ-ONLY addition for data object
    "declarations in the public visibility section. In doing so, an attribute
    "declared using CLASS-DATA or DATA can be read from outside of the class but
    "can only be changed using methods of the class or its subclasses.
    "The following attribute is taken from this executable example. It shows a
    "read access in a control structure. If you wanted to assign a new value to
    "the attribute outside of the class, a syntax error would be displayed.
    "Note that when you are in the class itself, there is no need to specify the
    "class name.
    "read_only_attribute = ... would be sufficient. And changing the value would
    "be possible within the class, too.
    "Declaration in the example:
    "CLASS-DATA: read_only_attribute TYPE string VALUE `Hallo` READ-ONLY.
    IF zcl_demo_abap_dtype_dobj=>read_only_attribute = `adapt read only attribute`.
      ...
      "Since we are here in the very class of this example attribute, a changing
      "of the value would be possible. And the class name can, in that case, be
      "ommitted.
      read_only_attribute = `changed`.
    ELSE.
      ...
    ENDIF.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Declaring structures and internal tables as examples for complex types` ) ).

    "Note: See more details and examples in the ABAP Keyword Documentations and in the
    "respective ABAP cheat sheets.

    "Creating a structure with DATA and providing start values with the VALUE addition.
    "If not specified, then the components have their type-specific initial value.
    DATA: BEGIN OF a_structure,
            comp1 TYPE i VALUE 1,
            comp2 TYPE string VALUE `hi`,
            comp3 TYPE string,
          END OF a_structure.

    "Creating a structure based on a global type. In this case, it is a DDIC database
    "table whose line type is used. You can also use a CDS view or a dedicated structured type
    "from the DDIC, for example.
    DATA struc_ddic_tab TYPE zdemo_abap_carr.

    "Creating a structure as a constant. Providing values is mandatory.
    CONSTANTS: BEGIN OF con_struc,
                 comp1 TYPE i VALUE 1,
                 comp2 TYPE string VALUE `hallo`,
                 comp3 TYPE string VALUE `salut`,
               END OF con_struc.

    "Using the constant as start value for a structure declaration.
    DATA struc_w_val LIKE con_struc VALUE con_struc.

    "Declaring a structure and explicitly specifying the type-specific
    "initial values of the structure components as start values.
    DATA struc_init_val LIKE con_struc VALUE IS INITIAL.

    "Creating internal tables ...
    "Based on a globally available DDIC database table whose line type is used
    DATA itab_ddic_tab TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.
    "Based on an elementary type
    DATA itab_tab_i TYPE TABLE OF i.
    "The table type is declared in a global interface
    DATA itab_tab_type_from_itf TYPE zdemo_abap_get_data_itf=>carr_tab.
    "Based on globally available DDIC internal table type; explicitly specifying as initial
    DATA itab_ddic_tab_type TYPE string_table VALUE IS INITIAL.
    "Based on locally available structured data object
    DATA itab_like_struc LIKE TABLE OF struc_w_val WITH EMPTY KEY.
    "Based on locally available internal table
    DATA itab_like_another_itab LIKE itab_tab_i.

    "Creating an internal table type locally
    TYPES tt_ddic_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY.
    "... and an internal table based on it.
    DATA itab_w_itab_type TYPE tt_ddic_tab.

    "Creating a structure based on the line of an internal table (type)
    DATA struc_from_itab_type TYPE LINE OF tt_ddic_tab.
    DATA struc_like_line LIKE LINE OF itab_ddic_tab.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Declaring data reference variables` ) ).

    "Declaring data reference variables types with static types
    DATA dref_int TYPE REF TO i.
    DATA dref_str TYPE REF TO string.
    DATA dref_ddic_tab TYPE REF TO zdemo_abap_carr.
    "Using the generic type data as static type
    DATA dref_8_dataa TYPE REF TO data.

    "Referring to an existing reference type
    TYPES tr_int TYPE REF TO i.
    DATA dref_tr_int TYPE tr_int.

    "Creating a data reference variable based on a data reference variable
    DATA dref_like LIKE dref_int.

    "Creating a data object for the LIKE REF TO addition
    DATA do_some_string TYPE string.

    "Reference type is created whose static type is inherited from the data type of
    "the specified data object
    DATA dref_like_ref_str LIKE REF TO do_some_string.

    "Reference tables
    DATA dref_tab_i TYPE TABLE OF REF TO i.
    DATA dref_tab_str LIKE TABLE OF REF TO do_some_string.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Assigning values to data objects` ) ).

    "An assignment passes the content of a source to a target data object.
    "Note:
    "- There are conversion rules when assigning a source to a target data object
    "  that have different types. See further down.
    "- In old ABAP code, you may see MOVE ... TO ... statements for value
    "  assignments. These statements are obsolete. This is not to be confused
    "  with MOVE-CORRESPONDING statements for complex types. They are not obsolete.

    "As mentioned, a start value can be directly assigned when declaring a data object.
    DATA some_int TYPE i VALUE 123.

    "Assignment using the assignement operator =
    "The source of the assigment on the right side (also known as general
    "expressions posisiton) can be specified with many things.

    "Single data object as source of the assignment
    "In the following cases, the literal and data object have the exact type
    "as the data object on the left side.

    some_int = 456.
    DATA num TYPE i.
    num = some_int.

    DATA str_a1 TYPE string VALUE `hallo`.
    DATA str_a2 TYPE string.
    str_a2 = str_a1.

    "Functional method as source of the assignment
    "In the following example, the method get_next of the class cl_abap_random_int
    "returns an integer. Check the F2 information for get_next (return value of type i).
    "A random integer that is in the specified value range is assigned to the data object
    "on the left side.
    num = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( )
      min  = 1
      max  = 10 )->get_next( ).

    "Built-in functions as source of the assignment
    "There are plenty of functions available.

    "Built-in numeric function
    "The following built-in function calculates 2 to the power of 4. The
    "result is assigned to the data object on the left side.
    num = ipow( base = 2 exp = 4 ).

    "Built-in string function
    "The following function transforms the specified data object to upper case letters.
    "The result is assigned to the data object on the left side.
    str_a1 = to_upper( str_a2 ).

    "Constructor expressions as source of the assignment
    "There are various options and expressions available (with many additions).
    "Check the ABAP Keyword Documentation and the cheat sheet. Here, taking the VALUE
    "operator as an example. This operator is very handy especially for complex types.

    "Creating a structure
    DATA some_struc TYPE zdemo_abap_carr.

    "Assignment using the VALUE operator
    "Note the # character that stands for the type. Here, the structure type can be
    "derived from the context. Hence, the explicit name can but need not be specified.
    some_struc = VALUE #( carrid = 'XY' carrname = 'XY Airways' ).

    "Creating an internal table and assigning values
    "Note that components that are not specified and assigned a value retain their
    "type-specific ininial value.
    DATA some_itab TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.
    some_itab = VALUE #( ( carrid = 'XY' carrname = 'XY Airways' )
                         ( carrid = 'ZZ' carrname = 'ZZ Airlines' ) ).

    "Table expressions as source of the assignment
    "A structure is assigned an internal table line
    some_struc = some_itab[ 2 ].

    "Calculation expressions as source of the assignment
    "Arithmetic expressions
    num = 1 + 2.
    "A calculation assignment as follows
    num += 1.
    "is the short form of
    num = num + 1.
    "Syntax options: +=, -=, *= and /=

    "String expressions as source of the assignment
    str_a2 = str_a1 && ` blabla`. "Strings are appended using the && operator
    str_a2 = |{ str_a1 } some more bla.|. "String templates
    "Note: Data objects are specified in curly brackets. The content is converted to type string.
    "      It must be convertible to type string.

    "An elementary data object is assigned a component of a specific table line using
    "a table expression. Note: In the following case, the types of source and target are not
    "the same (type c versus type string). As shown further down, such an assignment can lead
    "to unexpected or undesired results. Type-dependent conversions are made in accordance
    "with the conversion rules.
    str_a2 = some_itab[ 2 ]-carrname.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Creating data objects by inline declaration` ) ).

    "The declaration operator DATA can be specified in any designated declaration position.
    "The data type of the variable is determined by the operand type. It must be possible
    "to derive this type completely statically.
    "Note:
    "- The FINAL declaration operator is available for creating
    "  immutable variables as shon below.
    "- As shown in the previous section, there are many options for what can be placed on
    "  the right side.

    "Data object declarations and assignements as shown above.
    DATA str_b1 TYPE string VALUE `abc`.

    DATA str_b2 TYPE string.
    str_b2 = `def`.

    "Using a declaration expression with the declaration operator DATA, a data object
    "can be declared inline.
    "The data type of the declared variable is determined by the right side.
    "In doing so, a data object is assigned a value in one go.
    "In the following case, it is a string literal with backquotes on the right side.
    "The data type is derived and, hence, the data object is of type string.
    DATA(str_b3) = `ghi`.

    "In the following case, it is a text field literal with quotes. Type c is derived.
    "The length is derived from the number of characters.
    DATA(c_l3) = 'jkl'. "type c length 3
    DATA(c_l4) = 'mnop'. "type c length 4
    "Note the type conversion implications when making an assignment with these two
    "data objects.
    c_l3 = c_l4. "c_l3: 'mno'

    "Structures and internal tables
    "In declaration expressions, structures and internal tables can be declared inline
    "and filled with, for example, the help of the VALUE operator.

    "Structured data type
    TYPES: BEGIN OF ts_struc,
             comp1 TYPE i,
             comp2 TYPE string,
           END OF ts_struc.

    "In the following examples, structures are created. The structured data type is
    "derived from the type specified before the parentheses.
    DATA(struc_b1) = VALUE ts_struc( comp1 = 1 comp2 = `A` ).
    "No components specified and values assigned means an initial structure.
    "This syntax is also possible for declaring data objects with elementary types
    "and explicitly specifiying initial values, but only for initial values.
    "See the CONV operator below.
    DATA(struc_b2) = VALUE ts_struc( ).
    DATA(elem_init) = VALUE i( ).
    "Note that components that are not specified and assigned a value remain initial.
    DATA(struc_b3) = VALUE zdemo_abap_carr( carrid = 'AB' carrname = 'AB Airlines' ).
    "An entire structure is assigned.
    DATA(struc_b4) = struc_b1.

    "Note: When the structure has already been declared, and you want to assign values,
    "you can use the VALUE operator followed by the # character instead of the explicit
    "type name. In that case, it is possible to derive the type from the context.
    struc_b4 = VALUE #( comp1 = 2 comp2 = `b` ).

    "Internal tables
    "The internal table type is specified before the parentheses after the VALUE operator.
    "The following example uses a table type that is globally available in the DDIC.
    DATA(itab_b1) = VALUE string_table( ( `a` )
                                        ( `b` )
                                        ( `c` ) ).

    "Using a local internal table type
    TYPES tt_b1 TYPE TABLE OF ts_struc WITH EMPTY KEY.
    DATA(itab_b2) = VALUE tt_b1( ( comp1 = 1 comp2 = `a` )
                                 ( comp1 = 2 comp2 = `b` )
                                 ( comp1 = 3 comp2 = `c` ) ).

    "In the context of other ABAP statements such as LOOP, READ TABLE or ABAP SQL
    "SELECT statements, inline declarations are useful for creating target variables with
    "appropriate data types in place. This includes data reference variables and field
    "symbols. Field symbols are not covered below.

    "A work area/structure to hold the current internal table line is created inline.
    LOOP AT itab_b2 INTO DATA(wa_b1).
      wa_b1-comp1 = 12345.
      ...
    ENDLOOP.

    "Using the REFERENCE addition, a data reference variable can be created inline.
    LOOP AT itab_b2 REFERENCE INTO DATA(wa_ref_b1).
      wa_ref_b1->comp1 = 67890.
      ...
    ENDLOOP.

    "A structure to hold the internal table line read is created inline.
    READ TABLE itab_b2 INTO DATA(wa_b2) INDEX 2.
    "Data reference variable
    READ TABLE itab_b2 REFERENCE INTO DATA(wa_ref_b2) INDEX 2.

    "ABAP SQL statements
    "A structure as target data object is created inline.
    SELECT SINGLE * FROM zdemo_abap_carr INTO @DATA(struc_b5).
    "NEW addition of the INTO clause creates a data reference variable
    SELECT SINGLE * FROM zdemo_abap_carr INTO NEW @DATA(struc_ref).

    "Internal table as target data object is created inline.
    SELECT * FROM zdemo_abap_carr INTO TABLE @DATA(itab_b3).
    "NEW addition
    SELECT * FROM zdemo_abap_carr INTO TABLE NEW @DATA(itab_ref).

    "Inline declaration is useful for specifying data objects as actual
    "parameters in method calls
    "The following method calculates the difference in days, hours, minutes,
    "and seconds of two time stamps.
    "Check the F2 information of the 'diff' method. It has 4 exporting parameters.
    "3 different types are involved. Using the inline declarations, the data
    "objects receive the suitable types automatically. Extra variable declarations
    "with suitable types can be avoided.
    cl_abap_utclong=>diff( EXPORTING high     = CONV utclong( '2024-01-01 15:30:00' )
                                     low      = CONV utclong( '2023-12-24 14:20:40' )
                           IMPORTING days    = DATA(days)
                                     hours   = DATA(hours)
                                     minutes = DATA(minutes)
                                     seconds = DATA(seconds) ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Assigning references to data reference variables` ) ).

    "Note:
    "- As is true for other data object and types, there are special assignment rules
    "  for data reference variables. Check out the ABAP Keyword Documentation.
    "- An initial reference variable contains the null reference, which does not point
    "  to any objects. This means that it does not have a data type or a class as
    "  a dynamic type.

    "Declaring data reference variables with static types
    "At this stage, initial reference variables contain null references.
    DATA dref_1_i TYPE REF TO i.
    DATA dref_2_str TYPE REF TO string.
    "Generic type as static type
    DATA dref_3_data TYPE REF TO data.

    "References in data reference variables can point to existing data objects.
    "For assigning the reference, you can use the REF operator.
    "There is also an ABAP statement available doing the same: GET REFERENCE.
    "It should not be used anymore, especially in ABAP for Cloud development.

    "Creating data objects to refer to and providing a start value
    DATA do_number TYPE i VALUE 987.
    DATA do_string TYPE string VALUE `abc`.

    "After the assignment, the data reference variable points to the values.
    "The data type is derived (dynamic type).
    dref_1_i = REF #( do_number ). "Dynamic type is the same as the static type in this case
    dref_2_str = REF #( do_string ). "Dynamic type is the same as the static type in this case
    "Dynamic types of the followig examples are more specific than static type,
    "which is a generic type in this case.
    dref_3_data = REF #( do_number ).
    dref_3_data = REF #( do_string ).

    "Note: Table expressions can be also specified within the parentheses.

    "Inline declarations are also possible to create data reference variables
    "and assigning values in one go. Check the F2 information.
    DATA(dref_4_data) = dref_3_data.
    DATA(dref_5_str) = REF #( `hi` ).
    DATA(dref_6_i) = REF #( do_number ).

    "Assignments between two data reference variables mean that references are copied.
    "The concepts of upcast and downcast enter the picture here.
    "Two different assignment operators are used, as well as the casting operator CAST.

    "Upcast is possible for elementary data types
    "- The static type of the target variable is more general or identical to the static
    "  type of the source variable.
    "- Assignment operator used: =
    "- Note that the operators for downcasts can also be used explicitly here, but it is
    "  usually not needed.
    "- In this example, elementary data types are covered. An upcast works ...
    "  - if the data types have identical type properties (i.e. the built-in type match
    "    as well as length and decimal places).
    "  - the static type of the source variable is completely typed, and the static type
    "    of the target variable is generic.

    "The following upcasts work. Both point to data objects of type i or string.
    dref_1_i = dref_6_i.
    "The source on the right side is completely typed (type i),
    "the target on the left side is a generic type (type data).
    dref_3_data = dref_1_i.

    "Downcasts
    "- The static type of the target variable is more specific than the static type of the
    "  source variable.
    "- The assignability is not checked until runtime.
    "- Must always be performed explicitly using the casting operator ?= or the more
    "  modern casting operator CAST.

    "The following example would result in a syntax error due to type incompatibility.
    "dref_1_i = dref_3_data.

    "In the following example, the source has a generic static type (data). The target type
    "has a more specific type (type i).
    "To suppress the syntax error, the CAST operator is needed.
    "Note:
    "- The assignability is still not checked. This is done at runtime.
    "  In this example, it works since the dynamic type of the source is also of type i.
    "- An advantage of the CAST operator compared to ?= is that the operator enables downcasts
    "  in operand positions, which helps reduce helper variables.
    dref_1_i = CAST #( dref_3_data ).

    "If not caught, the following would result in a runtime error.
    "dref_3_data points to a data object of type i, the static type of dref_2_str is string.
    "So, the downcast does not work.
    TRY.
        dref_2_str = CAST #( dref_3_data ).
      CATCH cx_sy_move_cast_error INTO DATA(e).
        out->write( data = e->get_text( ) name = `e->get_text( )` ).
    ENDTRY.

    "Old syntax using the ?= operator
    dref_1_i ?= dref_3_data.

    "For upcasts, the operators can be used, too, but they are usually not necessary.
    "So, an assignment as follows is possible but not needed. Only using = is sufficient.
    dref_1_i = CAST #( dref_6_i ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Creating anonymous data objects` ) ).

    "Anonymous data objects are a topic related to data reference variables.
    "These data objects are unnamed data objects.
    "Most of the data objects above are named data objects, i.e. they can be addressed
    "by a dedicated name.
    "Unnamed data objects are literals and anonymous data objects. Anonymous data objects
    "can be addressed using data reference variables.
    "Note: Unlike data objects created with the statement DATA, anonymous data objects
    "are created at runtime. Data objects declared using DATA are created when the
    "program is loaded.

    "Options to create anonymous data objects
    "- CREATE DATA statements
    "- Using the instance operator NEW
    "- Addition NEW of the INTO clause in ABAP SQL SELECT statements

    "CREATE DATA statements
    "Note that there are many additions available. The examples show a selection.

    "Creating an anonymous data object with an implicit type.
    "If neither of the additions TYPE or LIKE are specified, the data reference variable
    "must be completely typed.
    DATA dref_7_str TYPE REF TO string.
    CREATE DATA dref_7_str.

    "Note: If you want to assign a value to the data object, this can't be done directly.
    "The data reference variable must be dereferenced first using the dereferencing operator.
    dref_7_str->* = `hi`.

    "Creating an anonymous data object with an explicitly specified data type
    DATA dref_8_data TYPE REF TO data.
    CREATE DATA dref_8_data TYPE p LENGTH 8 DECIMALS 3.
    dref_8_data->* = 1 / 3.

    "Creating a named data object
    DATA it TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.

    "Creating an anomyous internal table.
    "Using the LIKE addition to refer to an existing internal table
    CREATE DATA dref_8_data LIKE it.

    "Using the anonymous data object as target in the INTO clause of a SELECT statement.
    "As above, note the dereferencing.
    SELECT *
      FROM zdemo_abap_carr
      INTO TABLE @dref_8_data->*.

    "Creating an anonymous hashed table by specifying the entire table type
    CREATE DATA dref_8_data TYPE HASHED TABLE OF zdemo_abap_carr WITH UNIQUE KEY carrid.

    "Using the anonymous data object as target in the INTO clause of a SELECT statement
    SELECT *
       FROM zdemo_abap_carr
       INTO TABLE @dref_8_data->*.

    "Creating an anonymous structure
    CREATE DATA dref_8_data TYPE zdemo_abap_fli.

    "Using the anonymous data object as target in the INTO clause of a SELECT statement
    SELECT SINGLE *
       FROM zdemo_abap_fli
       INTO @dref_8_data->*.

    "NEW operator
    "- Works like CREATE DATA dref TYPE type statements and can be used in general
    "  expression positions.
    "- Allows to assign values to the new anonymous data objects in parentheses

    "Creating data reference variables
    DATA: dref_9_data TYPE REF TO data,
          dref_10_i   TYPE REF TO i.

    "Assining a value to an anonymous data object of the type i
    dref_9_data = NEW i( 555 ).

    "The # character can be used instead of the complete type spefication
    "when the type can be derived from the context.
    dref_10_i = NEW #( 653 ).

    "Inline declarations are handy.
    "Creating a suitable anonymous data object in place. Here, the type must be specificed
    "explicitly.
    DATA(dref_11_i) = NEW i( 32 ).

    "Creating an anonymous structure
    DATA(dref_12_ddic_tab) = NEW zdemo_abap_carr( carrid = 'AB' carrname = 'AB Airlines'  ).

    "The # character can be omitted when they type can be derived.
    DATA dref_13_ddic_tab TYPE REF TO zdemo_abap_carr.
    dref_13_ddic_tab = NEW #( carrid = 'AB' carrname = 'AB Airlines'  ).

    "ABAP SQL SELECT statement
    "As shown above, using the NEW addition in the INTO clause, an anonymous data
    "object can be created in place.
    SELECT *
      FROM zdemo_abap_carr
      INTO TABLE NEW @DATA(dref_14_inline).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Excursions: Elementary types and type conversions` ) ).

    out->write( |11) Implicit and explicit conversion\n\n| ).

    "Implicit conversions are performed in assignments using the assignment operator =
    "The content of a data object is converted according to the associated conversion rules.
    "The following examples demonstrate implicit type conversions and their consequences
    "that might be undesired.

    "Conversions with the types c and string
    DATA do_1_str TYPE string VALUE `abcedf`.
    DATA do_2_c3 TYPE c LENGTH 3.
    do_2_c3 = do_1_str.

    out->write( data = do_2_c3 name = `do_2_c3` ).
    out->write( |\n| ).

    "Conversions with the types i and decfloat34
    DATA do_4_i TYPE i.
    DATA do_5_dcfl34 TYPE decfloat34 VALUE '4.56'.
    do_4_i = do_5_dcfl34.

    out->write( data = do_4_i name = `do_4_i` ).
    out->write( |\n| ).

    "Conversions with the types i and string
    do_4_i = -5.
    do_1_str = do_4_i.

    out->write( data = do_1_str name = `do_1_str` ).
    out->write( |\n| ).

    "Explicit type conversions can be performed with the CONV operator
    "It converts the value specified within the parentheses to the data type specified
    "before the parentheses and and creates an appropriate result.
    "Note:
    "- CONV closes the gap where the value operator VALUE cannot be used to construct
    "  values for elementary data objects except for the initial value.
    "- The conversion is performed in accordance with the associated conversion rule.

    "Explicitly converting decfloat34 to i
    DATA do_6_dcfl34 TYPE decfloat34 VALUE '2.78'.
    DATA(do_7_i) = CONV i( do_6_dcfl34 ).

    out->write( data = do_7_i name = `do_7_i` ).
    out->write( |\n| ).

    "# character when the type can be derived
    DATA do_8_i TYPE i.
    do_8_i = CONV #( do_6_dcfl34 ).

    out->write( data = do_8_i name = `do_8_i` ).
    out->write( |\n| ).

    "The following two calculations yield different results
    do_8_i = sqrt( 5 ) + sqrt( 6 ).

    out->write( data = do_8_i name = `do_8_i` ).
    out->write( |\n| ).

    do_8_i = CONV i( sqrt( 5 ) ) + CONV i( sqrt( 6 ) ).

    out->write( data = do_8_i name = `do_8_i` ).

    "CONV operator for creating data objects inline with elementary data types
    "Assume, you want a data object typed with decfloat34.
    "The following example assigns a text field literal to the left side.
    DATA(do_9_c4) = '4.56'. "It is type c

    "Using the CONV operator and explicitly specifing the type, you can contruct a
    "data object with an appropriate elementary data type.
    DATA(do_10_dcfl34) = CONV decfloat34( '4.56' ).
    "It corresponds to the following
    DATA do_11_dcfl34 TYPE decfloat34 VALUE '4.56'.

    "Note that the EXACT operator is available for lossless assignments.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Character strings and text field strings` ) ).

    "The following example shows the difference between text field strings
    "of type c and character strings of type string when it comes to trailing
    "blanks.

    DATA: text_space   TYPE c LENGTH 1 VALUE ' ',
          string_space TYPE string VALUE ` `,
          result3      TYPE string,
          result4      TYPE string.
    result3 = '-->' && text_space && '<--'.
    result4 = '-->' && string_space && '<--'.

    out->write( |{ result3 }\n{ result4 }| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Floating point numbers` ) ).

    "The following example shows the difference between binary and decimal
    "floating point numbers.

    DATA: result1 TYPE f,
          result2 TYPE decfloat34.
    result1 = 815 / 1000.
    result2 = 815 / 1000.

    out->write( |Binary floating point: { result1 }\n| &&
    |Decimal floating point: { result2 }\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) Byte-like types` ) ).

    "The following example shows byte-like types x and xstring.

    "A byte string is filled with binary data created from a string
    "using the convert_out method of the cl_abap_codepage class.
    "The result is the UTF-8 representation of the string (type xstring)
    "which is displayed at first.
    "Using the create_in method, the data object of type xstring is converted
    "back to string.
    "Without knowing how it was created or what it is supposed to mean, you can
    "hardly do anything with a byte string.
    "The second part of the example deals with type x.
    "The binary representation of a new line feed (0A) is converted to string.
    "The result is compared to the actual means of previding a new line feed
    "(string template with \n and the older cl_abap_char_utilities=>newline).
    "The same is done using the binary representation of a blank (20).

    DATA(some_string) = `Hi there!`.

    DATA(xstr) =
      cl_abap_conv_codepage=>create_out(
      codepage = `UTF-8`
                 )->convert( source = some_string ).

    out->write( data = xstr name = `xstr` ).
    out->write( |\n| ).

    DATA(xstring2string) = cl_abap_conv_codepage=>create_in( codepage = `UTF-8`
                                                                        )->convert( source = xstr ).

    out->write( data = xstring2string name = `xstring2string` ).
    out->write( |\n| ).

    DATA line_feed_hex TYPE x LENGTH 1 VALUE '0A'.

    DATA(line_feed_str) = cl_abap_conv_codepage=>create_in( codepage = `UTF-8`
        )->convert( source = CONV xstring( line_feed_hex ) ).

    ASSERT line_feed_str = |\n|.
    ASSERT line_feed_str = cl_abap_char_utilities=>newline.

    out->write( `Y-->` && line_feed_str && `<--` ).
    out->write( |\n| ).
    out->write( `Y-->` && |\n| && `<--` ).
    out->write( |\n| ).

    DATA a_blank_x TYPE x LENGTH 1 VALUE '20'.

    DATA(blank) = cl_abap_conv_codepage=>create_in( codepage = `UTF-8`
        )->convert( source = CONV xstring( a_blank_x ) ).

    ASSERT blank =  ` `.

    out->write( `-->` && blank && `<--` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Date and time` ) ).

    "In the example, a date field is assigned the current values
    "using the cl_abap_context_info class. A calculation follows. The date of next
    "day is calculated.
    "Note: The data types behave like numeric values in the context of calculations.
    "In assignments and in the output, they behave like character-like types.
    "The second example shows an undesired result for a conversion of type i to d.
    "The number is interpreted as number of days since 0001-01-01 of the Gregorian
    "calendar. In this case, the date would exceeed the maximum value '99991231'.
    "In such a case, the date field is assigned the invalid value '00000000'.

    DATA: today    TYPE d,
          tomorrow TYPE d.
    today = cl_abap_context_info=>get_system_date( ).
    tomorrow = today + 1.
    out->write( data = today name = `today` ).
    out->write( |\n| ).
    out->write( data = tomorrow name = `tomorrow` ).
    out->write( |\n| ).

    DATA date TYPE d.
    date = '20240101'.
    out->write( data = date name = `date` ).
    out->write( |\n| ).

    "In newer ABAP releases, the following statement shows a syntax
    "warning that the value of the the data object (intentionally
    "specified here like this) is not an admissable value for the
    "target type. Therefore, the example is provided differently to
    "circumvent the syntax warning.

    "date = 20240101.
    DATA falsedate TYPE i VALUE 20240101.
    date = falsedate.
    out->write( data = date name = `date` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Type conversion rules` ) ).

    "The purpose of this example is to emphasize the conversion rules
    "that should be noted when performing conversions. The example
    "uses only a selection of elementary data types.
    "The result of the conversion may be unexpected or surprising.
    "For all the details, check the ABAP Keyword Documentation.
    "In the following example, a structured type is created.
    "The components are as follows:
    "- A data object having a specific data type is to be converted.
    "- The conversion results are reflected in the other components.
    "- If there is a conversion error, the conv_err* components hold
    "  the error message.
    "An internal table is created based on this structured type.
    "Several data objects are inserted into the internal table, on the
    "basis of which a conversion is performed. The table is looped over.
    "Implicit conversions are performed using the assignment operator.

    "Some noteworthy type conversions:
    "Conversion of d to decfloat34 and i:
    "  If the source field contains a valid date in the format yyyymmdd,
    "  it is used to calculate the number of days since 01.01.0001, and
    "  this value is then converted to the internal representation of the
    "  corresponding integer. If the source field contains an invalid date,
    "  the target field is assigned the value 0.
    "Conversion of t to decfloat34 and i:
    "  If the source field contains only digits, the content is interpreted
    "  as a time specification in the format hhmmss from which the value
    "  hh*3600+mm*60+ss is calculated and then converted to the internal
    "  representation of the corresponding integer.
    "Conversion of type i to c:
    "  The value is passed right-aligned. If the target field is too short,
    "  it is truncated on the left and the carachter * is set in the first
    "  position.
    "Conversion of type i to t:
    "  The value of the integer is divided by the number of seconds in a day
    "  (86,400) and the integer remainder of the division is interpreted as
    "  the number of seconds since midnight. The resulting time is placed in
    "  the target field in the format hhmmss.
    "Conversion of type i to string:
    "  The character - is set in the last position for a negative value and
    "  a blank is set in the last position for a positive value.
    "Conversion of type decfloat34 to t:
    "  The content of the source field is first converted to data type i
    "  and then to type t.

    TYPES: BEGIN OF ts_conv_struc,
             to_be_converted  TYPE REF TO data,
             type             TYPE string,
             conv_c_len2      TYPE c LENGTH 2,
             conv_err_c_len2  TYPE string,
             conv_d           TYPE d,
             conv_err_d       TYPE string,
             conv_n_len3      TYPE n LENGTH 3,
             conv_err_n_len3  TYPE string,
             conv_t           TYPE t,
             conv_err_t       TYPE string,
             conv_decfl34     TYPE decfloat34,
             conv_err_decfl34 TYPE string,
             conv_i           TYPE i,
             conv_err_i       TYPE string,
             conv_str         TYPE string,
             conv_err_str     TYPE string,
           END OF ts_conv_struc.

    DATA tt_conv_tab TYPE TABLE OF ts_conv_struc WITH EMPTY KEY.
    DATA err TYPE REF TO cx_root.

    DATA d_to_conv TYPE d VALUE '20230101'.
    DATA t_to_conv TYPE t VALUE '120000'.
    DATA dec34_to_conv TYPE decfloat34 VALUE '36000.999'.

    "Filling internal table
    tt_conv_tab = VALUE #(
    "c
    ( to_be_converted = REF #( 'abc' )         type = `C LENGTH 3` )
    ( to_be_converted = REF #( '11111111' )    type = `C LENGTH 8` )
    "d
    ( to_be_converted = REF #( d_to_conv )     type = `D` )
    "t
    ( to_be_converted = REF #( t_to_conv )     type = `T` )
    "decfloat34
    ( to_be_converted = REF #( dec34_to_conv ) type = `DECFLOAT34` )
    "i
    ( to_be_converted = REF #( 12345678 )      type = `I` )
    ( to_be_converted = REF #( -321 )          type = `I` )
    "string
    ( to_be_converted = REF #( `hello abap` )  type = `STRING` )
    ( to_be_converted = REF #( `12345` )       type = `STRING` )
    ).

    LOOP AT tt_conv_tab REFERENCE INTO DATA(wa_ref_con).
      TRY.
          wa_ref_con->conv_c_len2 = wa_ref_con->to_be_converted->*.
          wa_ref_con->conv_err_c_len2 = `-`.
        CATCH cx_root INTO err.
          wa_ref_con->conv_err_c_len2 = err->get_text( ).
      ENDTRY.

      IF wa_ref_con->type = `T`.
        wa_ref_con->conv_err_d = `T to D not possible.`.
      ELSE.
        TRY.
            wa_ref_con->conv_d = wa_ref_con->to_be_converted->*.
            wa_ref_con->conv_err_d = `-`.
          CATCH cx_root INTO err.
            wa_ref_con->conv_err_d = err->get_text( ).
        ENDTRY.
      ENDIF.

      TRY.
          wa_ref_con->conv_n_len3 = wa_ref_con->to_be_converted->*.
          wa_ref_con->conv_err_n_len3 = `-`.
        CATCH cx_root INTO err.
          wa_ref_con->conv_err_n_len3 = err->get_text( ).
      ENDTRY.

      IF wa_ref_con->type = `D`.
        wa_ref_con->conv_err_t = `D to T not possible.`.
      ELSE.
        TRY.
            wa_ref_con->conv_t = wa_ref_con->to_be_converted->*.
            wa_ref_con->conv_err_t = `-`.
          CATCH cx_root INTO err.
            wa_ref_con->conv_err_t = err->get_text( ).
        ENDTRY.
      ENDIF.

      TRY.
          wa_ref_con->conv_decfl34 = wa_ref_con->to_be_converted->*.
          wa_ref_con->conv_err_decfl34 = `-`.
        CATCH cx_root INTO err.
          wa_ref_con->conv_err_decfl34 = err->get_text( ).
      ENDTRY.

      TRY.
          wa_ref_con->conv_i = wa_ref_con->to_be_converted->*.
          wa_ref_con->conv_err_i = `-`.
        CATCH cx_root INTO err.
          wa_ref_con->conv_err_i = err->get_text( ).
      ENDTRY.

      TRY.
          wa_ref_con->conv_str = wa_ref_con->to_be_converted->*.
          wa_ref_con->conv_err_str = `-`.
        CATCH cx_root INTO err.
          wa_ref_con->conv_err_str = err->get_text( ).
      ENDTRY.

    ENDLOOP.

    out->write( data = tt_conv_tab name = `tt_conv_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) Excursion: RTTI` ) ).

    "Using RTTI to check type compatibility
    "In the following example the applies_to_data method of the RTTI class
    "cl_abap_datadescr is used to check the compatibility of generically typed
    "data reference variables pointing to different data objects.
    "An assignment of ref1->* to ref3->* would raise an uncatchable exception.

    DATA num1 TYPE i.
    DATA num2 TYPE i.
    DATA itab_i TYPE TABLE OF i WITH EMPTY KEY.

    DATA ref1 TYPE REF TO data.
    DATA ref2 TYPE REF TO data.
    DATA ref3 TYPE REF TO data.

    ref1 = REF #( num1 ).
    ref2 = REF #( num2 ).
    ref3 = REF #( itab_i ).

    IF CAST cl_abap_datadescr( cl_abap_typedescr=>describe_by_data( ref1->* )
        )->applies_to_data( ref2->* ).
      ref1->* = ref2->*.
      out->write( `The types of ref1->* and ref2->* are compatible.` ).
    ELSE.
      out->write( `The types of ref1->* and ref2->* are not compatible.` ).
    ENDIF.

    out->write( |\n| ).

    IF CAST cl_abap_datadescr( cl_abap_typedescr=>describe_by_data( ref1->* )
        )->applies_to_data( ref3->* ).
      ref1->* = ref3->*.
      out->write( `The types of ref1->* and ref3->* are compatible.` ).
    ELSE.
      out->write( `The types of ref1->* and ref3->* are not compatible.` ).
    ENDIF.

    out->write( |\n| ).
    out->write( |\n| ).

    "Using RTTI to get type descriptions
    "In the following example, an internal table that has been filled in
    "a previous example is looped over. It contains references to various types
    "for whom specific type descriptions are retrieved.
    "You may want to set a break-point and check out the variety of information
    "contained in the the data reference variable 'rtti'.

    TYPES: BEGIN OF ts_rtti,
             absolute_name TYPE string,
             kind          TYPE string,
             type_kind     TYPE string,
           END OF ts_rtti.

    DATA rtti_tab TYPE TABLE OF ts_rtti WITH EMPTY KEY.

    LOOP AT tt_conv_tab REFERENCE INTO DATA(wa_ref).

      DATA(rtti) = CAST cl_abap_datadescr(
          cl_abap_typedescr=>describe_by_data( wa_ref->to_be_converted->* ) ).

      APPEND VALUE #( absolute_name = rtti->absolute_name
                      kind          = rtti->kind
                      type_kind     = rtti->type_kind ) TO rtti_tab.

    ENDLOOP.

    out->write( data = rtti_tab name = `rtti_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) Constants and immutable variables` ) ).

    "As mentioned above, constants cannot be changed at runtime.
    CONSTANTS con_str TYPE string VALUE `hallo`.

    "Constants as start values for dobj declarations following value
    CONSTANTS con_underscores TYPE string VALUE `__________`.
    DATA str_w_con_as_start_value TYPE string VALUE con_underscores.

    "Immutable variables
    FINAL(do_final_inl) = 1.
    DATA(do_data_inl) = 1 + do_final_inl.
    "not possible
    "do_final_inl = 2.

    SELECT * FROM zdemo_abap_carr INTO TABLE @DATA(itab_data_inl).

    DATA itab_like_inline LIKE itab_data_inl.

    "Using an inline declaration as target of a LOOP statement
    "A value is assigned multiple times, but it cannot be changed in any other
    "write positions.
    LOOP AT itab_data_inl INTO FINAL(wa_final).

      "The following is not possible
      "wa_final-carrid = 'd'.
      "only read access
      APPEND wa_final TO itab_like_inline.
    ENDLOOP.

    "SELECT statement with a an immutable target table declared inline
    SELECT * FROM zdemo_abap_carr INTO TABLE @FINAL(itab_final_inl).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) Various ABAP glossary terms on data types and objects in a nutshell` ) ).

    "Standalone and bound data types
    "Standalone: Data type that is defined using the statement TYPES in an ABAP program, as
    "            a data type of the ABAP Dictionary or as an CDS entity.
    "Bound: Data type that only exists as a property of a data object.

    "Standalone data type
    TYPES te_a_c10 TYPE c LENGTH 10.

    "Bound data types
    DATA do_a_c20 TYPE c LENGTH 20.
    DATA do_b_like LIKE do_a_c20.
    TYPES te_b_like LIKE do_a_c20.

**********************************************************************

    "Complex and elementary data type/object
    "Elementary: Data type of fixed or variable length that is neither structured, nor a
    "            table type or a reference type.
    "Complex: Made up of other data types, for example structured data type/objects, a
    "         table type/internal tables

    "Elementary
    DATA do_c_i TYPE i.

    "Complex
    DATA: BEGIN OF struc_a,
            comp1 TYPE i,
            comp2 TYPE string,
            comp3 TYPE zdemo_abap_carr, "structure
            comp4 TYPE string_table, "internal table
            comp5 TYPE REF TO i, "reference type
          END OF struc_a.

**********************************************************************

    "Complete and generic data types
    "Complete: Non-generic data type
    "Generic:
    "- Data type that does not set all properties of a data object.
    "- Can only be used for the typing of formal parameters and field symbols.

    "Complete data type
    DATA do_d_i TYPE i.

    "Field symbols typed with generic data types
    "Note: A field symbol is a symbolic name for a data object to which actual
    "memory can be assigned at runtime. A field symbol can be used as a placeholder
    "for a data object at an operand position. For more information, see the ABAP
    "Cheat Sheet on dynamic programming. Field symbols are used in this example
    "to demonstrate generic types other than just data with which data reference
    "variables can be typed.
    "As the name implies, clike expects character-like data types. data can
    "expect any data type. This is shown in the example. Apart from the
    "character-like types, internal table types are also accepted.
    FIELD-SYMBOLS <fs_a> TYPE clike.
    FIELD-SYMBOLS <fs_b> TYPE data.

    "Data object declarations
    DATA do_e_c5 TYPE c LENGTH 5 VALUE 'abcde'.
    DATA do_f_str TYPE string VALUE `Hallo, how are you?`.
    DATA(itab_a) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ).

    "Generic type clike
    "Field symbols with generic data types can be assigned appropriate values
    ASSIGN do_e_c5 TO <fs_a>.

    out->write( data = <fs_a> name = `<fs_a>` ).
    out->write( |\n| ).

    ASSIGN do_f_str TO <fs_a>.

    out->write( data = <fs_a> name = `<fs_a>` ).
    out->write( |\n| ).

    "Generic type data
    ASSIGN do_e_c5 TO <fs_b>.

    out->write( data = <fs_b> name = `<fs_b>` ).
    out->write( |\n| ).

    ASSIGN do_f_str TO <fs_b>.

    out->write( data = <fs_b> name = `<fs_b>` ).
    out->write( |\n| ).

    ASSIGN itab_a TO <fs_b>.

    out->write( data = <fs_b> name = `<fs_b>` ).
    out->write( |\n| ).

**********************************************************************

    "Variable and constant data objects
    "Variable: Named data object whose value can be changed during the runtime
    "          of an ABAP program.
    "Constant: Named data object whose value cannot be changed at runtime.

    "Variable
    DATA do_g_i TYPE i VALUE 123.
    do_g_i = 456.

    CONSTANTS con_a_i TYPE i VALUE 789.
    "An assignment as follows is not possible. The data object cannot be
    "modified.
    "con_a_i = 321.

**********************************************************************

    "Static and dynamic data objects
    "Static:
    "- Data object for which all attributes, including memory use, are specified
    "  statically by the data type.
    "- Apart from reference variables, all static data objects are flat.
    "Dynamic:
    "- Data object for which all properties apart from the memory consumption are
    "  statically determined by the data type.
    "- Dynamic data objects are strings and internal tables. They belong to the
    "  deep data objects. Structures that contain dynamic components are also
    "  dynamic data objects.

    "Static data object
    DATA do_h_c5 TYPE c LENGTH 3.
    "Dynamic data object
    DATA do_i_str TYPE string.

    "Assignments
    do_h_c5 = 'abc'.

    "In newer ABAP releases, the following statement shows a syntax
    "warning that the value of the literal (intentionally specified
    "here like this) is not an admissable value for the target type.
    "Therefore, the example is provided differently to circumvent the
    "syntax warning.

    "do_h_c5 = 'defghi'.

    TYPES c_l6 TYPE c LENGTH 6.
    DATA some_char TYPE c_l6 VALUE 'defghi'.
    "only 'def' assigned -> length and memory use do not change
    do_h_c5 = some_char.



    "Memory consumption changes for dynamic data objects
    do_i_str = `abc`.
    do_i_str = `d`.
    do_i_str = `efghijklmnopqrstuvwxyz`.

**********************************************************************

    "Static type and dynamic type
    "Both are data types of a reference variable (reference type) that determine
    "the objects a reference variable can point to.
    "Static type: For data reference variables, the static type is a data type that
    "             is always more general than or the same as the dynamic type.
    "Dynamic type: For a reference variable, the dynamic type is always more special
    "              than or equal to the static type.

    "Static type
    DATA dref_a_i TYPE REF TO i. "Static type is i
    DATA dref_b_data TYPE REF TO data. "Static type can also be generic

    "Creating data objects to refer to
    DATA do_j_i TYPE i VALUE 3.
    DATA do_k_str TYPE string VALUE `hallo`.

    "Dynamic types
    "Set a breakpoint here and check the Variables tab in ADT how the value and
    "the information changes.
    dref_a_i = REF #( do_j_i ). "Only type i possible; the dynamic type is the same

    "The dynamic type is more special than the static type (which is the generic
    "type data in this case)
    dref_b_data  = REF #( do_j_i ).
    dref_b_data  = REF #( do_k_str ).
    dref_b_data  = REF #( dref_a_i ).

**********************************************************************

    "Flat and deep data objects
    "Flat:
    "- Property of a data type, where the content of its data objects represents
    "  the actual work data.
    "- All elementary data types except string and xstring are flat
    "Deep:
    "- Dynamic data objects and reference variables are deep, and they contain
    "  references that refer to the actual content.
    "- The handling of references is implicit for dynamic data objects (strings
    "  and internal tables), and explicit for reference variables.
    "- Structures that do not contain any deep components are flat structures.
    "  Structures that contain at least one deep component are deep structures.

    "Flat data object
    DATA do_l_i TYPE i.

    "Flat structure
    DATA: BEGIN OF struc_b_flat,
            comp1 TYPE i,
            comp2 TYPE c LENGTH 3,
          END OF struc_b_flat.

    "Deep data object
    DATA do_m_str TYPE string.

    "Deep structure
    DATA: BEGIN OF struc_c_deep,
            comp1 TYPE i,
            comp2 TYPE c LENGTH 3,
            comp3 TYPE string,  "string as deep data object
            comp4 TYPE string_table, "internal table as deep data object
          END OF struc_c_deep.

**********************************************************************

    "Named and unnamed data object
    "Named: Data object that can be identified via a name.
    "Unnamed: Data object that cannot be addressed by a name. Unnamed data
    "         objects are literals and anonymous data objects.

    "Named data objects
    DATA do_n_i TYPE i.
    CONSTANTS con_b_str TYPE string VALUE `hi`.

    "Unnamed data objects
    "Literal that is output. It cannot be addressed via a dedicated name.
    out->write( `I'm a literal...` ).
    out->write( |\n| ).

    "Anonymous data object created using the NEW operator
    "Can be addressed using reference variables or field symbols.

    DATA(dref_c_str) = NEW string( `hi` ).

    out->write( data = dref_c_str->* name = `dref_c_str->*` ).
    out->write( |\n| ).

    "Anonymous data object created inline using the NEW addition to the INTO
    "clause of a SELECT statement
    SELECT *
      FROM zdemo_abap_carr
      INTO TABLE NEW @DATA(dref_d_tab)
      UP TO 3 ROWS.

    out->write( data = dref_d_tab->* name = `dref_d_tab->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20a) Generic ABAP types for formal parameters of methods` ) ).

    "Generic data types have already been covered above.
    "A generic data type is an incomplete type specification that covers multiple
    "complete type specifications.
    "This example demonstrates generic ABAP types in the context of formal parameters
    "of methods.
    "Unlike data objects, where the data type has a specific property and is always
    "completely known, formal parameters and field symbols that are generically typed
    "receive their complete data type only when an actual parameter is passed in a method
    "call, or, regarding field symbols, when a memory area is assigned.
    "In the following example, a method is called that has two importing parameters typed
    "with the generic type numeric. An internal table is filled with values on whose basis
    "the method is provided with actual parameters. Intentionally, various numeric values
    "are included as well as values that will not work.

    TYPES: BEGIN OF str_num,
             num1   TYPE REF TO data,
             num2   TYPE REF TO data,
             result TYPE decfloat34,
           END OF str_num.

    DATA tab_num TYPE TABLE OF str_num WITH EMPTY KEY.

    tab_num = VALUE #( ( num1 = NEW i( 1 )                  num2 = NEW i( 2 ) )
                       ( num1 = NEW decfloat34( '1.74' )    num2 = NEW decfloat34( '4.04' ) )
                       ( num1 = NEW i( 11 )                 num2 = NEW decfloat34( '10.621' ) )
                       ( num1 = NEW string( `Some string` ) num2 = NEW i( 2 ) ) ).

    LOOP AT tab_num REFERENCE INTO DATA(fp_ref).
      TRY.
          fp_ref->result = addition_with_generic_num( num1 = fp_ref->num1->* num2 = fp_ref->num2->* ).
        CATCH cx_sy_dyn_call_illegal_type INTO DATA(error).
      ENDTRY.
    ENDLOOP.

    out->write( data = tab_num name = `tab_num` ).
    out->write( |\n| ).
    out->write( data = error->get_text( ) name = `error->get_text( )` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20b) Overview of generic ABAP types using field symbols` ) ).

    FIELD-SYMBOLS:
      "Any data type
      <data>           TYPE data,
      <any>            TYPE any,
      "Any data type can be assigned. Restrictions for formal parameters and 'data': no
      "numeric functions, no description functions, and no arithmetic expressions can be
      "passed to these parameters. However, you can bypass the restriction by applying the
      "CONV operator for the actual parameter.

      "Character-like types
      <c>              TYPE c,         "Text field with a generic length
      <clike>          TYPE clike,     "Character-like (c, n, string, d, t and character-like flat structures)
      <csequence>      TYPE csequence, "Text-like (c, string)
      <n>              TYPE n,         "Numeric text with generic length
      <x>              TYPE x,         "Byte field with generic length
      <xsequence>      TYPE xsequence, "Byte-like (x, xstring)

      "Numeric types
      <decfloat>       TYPE decfloat, "decfloat16, decfloat34
      <numeric>        TYPE numeric,  "Numeric ((b, s), i, int8, p, decfloat16, decfloat34, f)
      <p>              TYPE p,        "Packed number (generic length and number of decimal places)

      "Internal table types
      <any_table>      TYPE ANY TABLE,      "Internal table with any table type
      <hashed_table>   TYPE HASHED TABLE,
      <index_table>    TYPE INDEX TABLE,
      <sorted_table>   TYPE SORTED TABLE,
      <standard_table> TYPE STANDARD TABLE,
      <table>          TYPE table,          "Standard table

      "Other types
      <simple>         TYPE simple. "Elementary data type including enumerated types and
    "structured types with exclusively character-like flat components

    "Data objects to work with
    DATA: BEGIN OF s,
            c3        TYPE c LENGTH 3,
            c10       TYPE c LENGTH 10,
            n4        TYPE n LENGTH 4,
            str       TYPE string,
            time      TYPE t,
            date      TYPE d,
            dec16     TYPE decfloat16,
            dec34     TYPE decfloat34,
            int       TYPE i,
            pl4d2     TYPE p LENGTH 4 DECIMALS 2,
            tab_std   TYPE STANDARD TABLE OF string WITH EMPTY KEY,
            tab_so    TYPE SORTED TABLE OF string WITH NON-UNIQUE KEY table_line,
            tab_ha    TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line,
            xl1       TYPE x LENGTH 1,
            xstr      TYPE xstring,
            structure TYPE zdemo_abap_carr, "character-like flat structure
          END OF s.

    "The following static ASSIGN statements demonstrate various assignments
    "Note:
    "- The statements commented out show impossible assignments.
    "- If a static assignment is not successful, sy-subrc is not set and no
    "  memory area is assigned. Dynamic assignments, however, set the value.

    "----- Any data type -----
    ASSIGN s-c3 TO <data>.
    ASSIGN s-time TO <data>.
    ASSIGN s-tab_std TO <data>.
    ASSIGN s-xstr TO <any>.
    ASSIGN s-pl4d2 TO <any>.
    ASSIGN s-date TO <any>.
    ASSIGN s TO <any>.

    "----- Character-like types -----
    ASSIGN s-c3 TO <c>.
    ASSIGN s-c10 TO <c>.
    "ASSIGN s-str TO <c>.

    ASSIGN s-c10 TO <clike>.
    ASSIGN s-str TO <clike>.
    ASSIGN s-n4 TO <clike>.
    ASSIGN s-date TO <clike>.
    ASSIGN s-time TO <clike>.
    ASSIGN s-structure TO <clike>.

    ASSIGN s-c10 TO <csequence>.
    ASSIGN s-str TO <csequence>.
    "ASSIGN s-n4 TO <csequence>.

    ASSIGN s-n4 TO <n>.
    "ASSIGN s-int TO <n>.
    "ASSIGN s-time TO <n>.

    ASSIGN s-xl1 TO <x>.
    "ASSIGN s-xstr TO <x>.

    ASSIGN s-xl1 TO <xsequence>.
    ASSIGN s-xstr TO <xsequence>.

    "----- Numeric types -----
    ASSIGN s-dec16 TO <numeric>.
    ASSIGN s-dec34 TO <numeric>.
    ASSIGN s-int TO <numeric>.
    ASSIGN s-pl4d2 TO <numeric>.
    "ASSIGN s-n4 TO <numeric>.

    ASSIGN s-dec16 TO <decfloat>.
    ASSIGN s-dec34 TO <decfloat>.

    ASSIGN s-pl4d2 TO <p>.
    "ASSIGN s-dec34 TO <p>.

    "----- Internal table types -----
    ASSIGN s-tab_std TO <any_table>.
    ASSIGN s-tab_so TO <any_table>.
    ASSIGN s-tab_ha TO <any_table>.

    ASSIGN s-tab_std TO <index_table>.
    ASSIGN s-tab_so TO <index_table>.
    "ASSIGN s-tab_ha TO <index_table>.

    "ASSIGN s-tab_std TO <sorted_table>.
    ASSIGN s-tab_so TO <sorted_table>.
    "ASSIGN s-tab_ha TO <sorted_table>.

    ASSIGN s-tab_std TO <standard_table>.
    ASSIGN s-tab_std TO <table>.
    "ASSIGN s-tab_so TO <standard_table>.
    "ASSIGN s-tab_so TO <table>.
    "ASSIGN s-tab_ha TO <standard_table>.
    "ASSIGN s-tab_ha TO <table>.

    "ASSIGN s-tab_std TO <hashed_table>.
    "ASSIGN s-tab_so TO <hashed_table>.
    ASSIGN s-tab_ha TO <hashed_table>.

    "----- Other types -----
    ASSIGN s-c10 TO <simple>.
    ASSIGN s-str TO <simple>.
    ASSIGN s-dec34 TO <simple>.
    ASSIGN s-date TO <simple>.
    ASSIGN s-structure TO <simple>.
    ASSIGN s-xl1 TO <simple>.
    "ASSIGN s-tab_ha TO <simple>.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21a) Built-in data objects (1)` ) ).

    "This example demonstrates the availability of built-in data objects in ABAP.

    "System fields are filled by the ABAP runtime framework and can be used in an ABAP
    "program to query various things.
    "The following example covers the values provided with sy-index and sy-tabix.
    "Check both loops in the debugger and insert sy-index/sy-tabix in the
    "Variables tab to see the value change.

    DATA syidx LIKE TABLE OF sy-index.

    "In DO and WHILE loops, sy-index contains the number of previous loop passes,
    "including the current pass.
    DO 5 TIMES.
      APPEND sy-index TO syidx.
    ENDDO.

    out->write( data = syidx name = `syidx` ).
    out->write( |\n| ).

    DATA str_tab TYPE TABLE OF string.

    "In loops with LOOP AT, sy-tabix contains the line number in the table
    "index of an index table.
    LOOP AT syidx INTO DATA(wa_sy1).
      APPEND |Value of processed table line: { wa_sy1 } / Table index { sy-tabix }| TO str_tab.
    ENDLOOP.

    out->write( data = str_tab name = `str_tab` ).
    out->write( |\n| ).

    "sy-subrc contains a return code that is set by many ABAP statements.
    "In general, the value 0 means that the statement was executed without problems.

    READ TABLE syidx INDEX 6 INTO DATA(wa_sy2).

    IF sy-subrc = 0.
      out->write( |Yes, the table line was found. sy-subrc value that was returned is { sy-subrc }.| ).
    ELSE.
      out->write( |No, the table line was not found. sy-subrc value that was returned is { sy-subrc }.| ).
    ENDIF.

    out->write( |\n| ).
    out->write( |\n| ).

    "The program-global constant space has the data type c, length 1, and contains a blank character.
    "In the following example, the table lines are concatenated into a string, separated by a blank.

    DATA ctab TYPE TABLE OF c.

    ctab = VALUE #( ( 'a' ) ( 'b' ) ( 'c' ) ).

    DATA c_f TYPE c LENGTH 10.

    CONCATENATE LINES OF ctab INTO c_f SEPARATED BY space.

    out->write( data = c_f name = `c_f` ).
    out->write( |\n| ).

    "Self-reference me
    "Within the implementation of each instance method, an implicitly created local
    "reference variable called me is available at runtime, which points to the instance
    "in which the method is currently being executed.
    "me is handled like a local constant, which means that the value of me cannot be
    "changed in an instance method. The static type of me is the class in which the
    "instance method is implemented.
    "In the following example, an instance of this class is created. Then a method is
    "called, and a string is returned. The method implementation includes a data object
    "that is (intentionally) declared with the same name of the instance attribute
    "available in the private section of the class (text). Using the self-reference me
    "(me->text), you can explicitly refer to the instance attribute. Just 'text' means
    "referring to the data object locally declared in the method.

    DATA(oref) = NEW zcl_demo_abap_dtype_dobj( ).

    cl_text = 'Hallo'.

    DATA(res_str) = oref->adapt_text( ).

    out->write( data = res_str name = `res_str` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21b) Built-in data objects (2)` ) ).

    "This sections is an addition to the previous one.

    "------------------------------------------------------------------------------
    "------------------ sy-subrc: Return code of ABAP statements ------------------
    "------------------------------------------------------------------------------

    "Many ABAP statements set a sy-subrc value. Check the ABAP Keyword Documentation
    "for individual statements. Usually, the value 0 indicates a successful execution.

    DATA(test_string) = `ABAP`.

    "FIND statements
    "Found
    FIND `P` IN test_string.
    ASSERT sy-subrc = 0.

    "Not found
    FIND `p` IN test_string RESPECTING CASE.
    ASSERT sy-subrc = 4.

    DATA(test_tab) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ).

    "READ TABLE statements
    "Entry available
    READ TABLE test_tab INTO DATA(wa1) INDEX 3.
    ASSERT sy-subrc = 0.

    "Entry not available
    READ TABLE test_tab INTO DATA(wa2) INDEX 7.
    ASSERT sy-subrc = 4.

    "ABAP SQL statements
    DELETE FROM zdemo_abap_tab1.
    IF sy-subrc = 0.
      out->write( `DELETE: All rows were deleted.` ).
    ELSE.
      out->write( `DELETE: No row was deleted because it was already empty.` ).
    ENDIF.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 ) ( key_field = 2 ) ) ).
    IF sy-subrc = 0.
      out->write( `INSERT: All rows of the internal table were inserted.` ).
    ENDIF.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 3 ) ( key_field = 3 ) ) ) ACCEPTING DUPLICATE KEYS.
    IF sy-subrc = 4.
      out->write( `INSERT ... ACCEPTING DUPLICATE KEYS: sy-subrc has the value 4 in this case. Not all rows of the ` &&
                  `internal table were inserted because a row with the key already exists.` ).
    ENDIF.

    DELETE FROM zdemo_abap_tab1 WHERE key_field = 3.
    IF sy-subrc = 0.
      out->write( `DELETE: The row matching the WHERE condition was deleted.` ).
    ELSE.
      out->write( `DELETE: No match according to the WHERE condition.` ).
    ENDIF.

    DELETE FROM zdemo_abap_tab1 WHERE key_field = 3.
    IF sy-subrc = 0.
      out->write( `DELETE: The row matching the WHERE condition was deleted.` ).
    ELSE.
      out->write( `DELETE: No match according to the WHERE condition.` ).
    ENDIF.

    CLEAR test_string.

    "DO loops
    DO 5 TIMES.
      test_string = test_string && sy-index.
    ENDDO.

    ASSERT test_string = `12345`.

    CLEAR test_string.

    DO 10 TIMES.
      test_string = test_string && sy-index.
      IF sy-index = 7.
        EXIT.
      ENDIF.
    ENDDO.

    ASSERT test_string = `1234567`.

    CLEAR test_string.

    DATA test_number TYPE i.

    "WHILE loop
    WHILE test_number < 9.
      test_number = sy-index.
      test_string = test_string && test_number.
    ENDWHILE.

    ASSERT test_string = `123456789`.

    "Demo standard internal table with 5 entries
    DATA(std_itab) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ( `e` ) ).

    "READ TABLE statement using a free key
    READ TABLE std_itab INTO DATA(wa3) WITH KEY table_line = `b`.
    ASSERT sy-tabix = 2.

    "Demo hashed internal table with 5 entries
    DATA(hashed_itab) = VALUE string_hashed_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ( `e` ) ).

    "READ TABLE statement using a free key
    READ TABLE hashed_itab INTO DATA(wa4) WITH KEY table_line = `b`.
    "Hashed tables do not have a primary table index.
    ASSERT sy-tabix = 0.

    CLEAR test_string.

    "LOOP statements
    LOOP AT std_itab INTO DATA(wa5).
      test_string = test_string && sy-tabix.
    ENDLOOP.
    ASSERT test_string = `12345`.

    CLEAR test_string.
    LOOP AT std_itab INTO DATA(wa6) STEP -1.
      test_string = test_string && sy-tabix.
    ENDLOOP.
    ASSERT test_string = `54321`.

    CLEAR test_string.
    "Forward loop, step size = 2
    LOOP AT std_itab INTO DATA(wa7) STEP 2.
      test_string = test_string && sy-tabix.
    ENDLOOP.
    ASSERT test_string = `135`.

    CLEAR test_string.
    "FROM/TO additions
    LOOP AT std_itab INTO DATA(wa8) FROM 2 TO 4.
      test_string = test_string && sy-tabix.
    ENDLOOP.
    ASSERT test_string = `234`.

    CLEAR test_string.
    "STEP/FROM additions
    LOOP AT std_itab INTO DATA(wa9) STEP 2 FROM 2.
      test_string = test_string && sy-tabix.
    ENDLOOP.
    ASSERT test_string = `24`.

    CLEAR test_string.
    "Hashed table
    LOOP AT hashed_itab INTO DATA(wa10).
      test_string = test_string && sy-tabix.
    ENDLOOP.
    ASSERT test_string = `00000`.

    DELETE FROM zdemo_abap_tab1.
    DATA(dbcnt) = sy-dbcnt.

    out->write( |Dbtab rows deleted: { dbcnt }| ).

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 ) ( key_field = 2 ) ) ).
    ASSERT sy-dbcnt = 2.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 3 ) ( key_field = 3 ) ) ) ACCEPTING DUPLICATE KEYS.
    ASSERT sy-dbcnt = 1.

    MODIFY zdemo_abap_tab1 FROM @( VALUE #( key_field = 1 char1 = 'aaa' ) ).
    ASSERT sy-dbcnt = 1.

    UPDATE zdemo_abap_tab1 SET char2 = 'bbb'.
    ASSERT sy-dbcnt = 3.

    DELETE FROM zdemo_abap_tab1 WHERE num1 IS INITIAL.
    ASSERT sy-dbcnt = 3.

    test_string = `###abap###`.

    IF test_string CS `p`.
      out->write( |The substring is found. Offset of first finding: { sy-fdpos }| ).
    ELSE.
      out->write( |The substring is not found. Length of searched string: { sy-fdpos }| ).
      ASSERT sy-fdpos = strlen( test_string ).
    ENDIF.

    IF test_string CS `#`.
      out->write( |The substring is found. Offset of first finding: { sy-fdpos }| ).
    ELSE.
      out->write( |The substring is not found. Length of searched string: { sy-fdpos }| ).
      ASSERT sy-fdpos = strlen( test_string ).
    ENDIF.

    IF test_string CS `Y`.
      out->write( |The substring is found. Offset of first finding: { sy-fdpos }| ).
    ELSE.
      out->write( |The substring is not found. Length of searched string: { sy-fdpos }| ).
      ASSERT sy-fdpos = strlen( test_string ).
    ENDIF.

    test_string = |{ space }{ space }|.
    ASSERT test_string = ``.

    test_string = `#` && space && space && space && space && space && `#`.
    ASSERT test_string = `##`.

    CONCATENATE space space INTO test_string SEPARATED BY space.
    ASSERT test_string = ` `.

    DATA test_char TYPE c LENGTH 5.
    CONCATENATE '#' space space '#' INTO test_char.
    ASSERT test_char = '##'.

    CONCATENATE space space '#' space '#' INTO test_char.
    ASSERT test_char = '##'.

    DATA text TYPE string VALUE `Local data object 'text'`.

    "Demo assignments
    "dobj1 contains the value of the locally declared data object
    DATA(dobj1) = text.
    "dobj2 contains the value of the class attribute
    DATA(dobj2) = me->text.

    out->write( data = dobj1 name = `dobj1` ).
    out->write( data = dobj2 name = `dobj2` ).

    out->write( zcl_demo_abap_aux=>heading( `22) Declaration context` ) ).

    DO 10 TIMES.
      DATA number TYPE i VALUE 10.
      number = number + 1.
    ENDDO.

    out->write( data = number name = `number` ).
    out->write( |\n| ).

    DO 10 TIMES.
      number = number + 1.
    ENDDO.

    out->write( data = number name = `number` ).
    out->write( |\n| ).

    DO 10 TIMES.
      DATA(number_B) = 10.
      number_B = number_B + 1.
    ENDDO.

    out->write( data = number_b name = `number_b` ).
    out->write( |\n| ).

    DO 10 TIMES.
      number_b = number_b + 1.
    ENDDO.
    out->write( data = number_b name = `number_b` ).
    out->write( |\n| ).

    out->write( zcl_demo_abap_aux=>heading( `23) Enumerated Types and Objects` ) ).
    DATA enum_var1 TYPE t_enum VALUE a.
    DATA(output_for_enum_var1) = enum_meth_params( enum_var1 ).
    out->write( data = output_for_enum_var1 name = `output_for_enum_var1` ).
    out->write( |\n| ).

    DATA enum_var2 TYPE t_enum VALUE b.
    DATA(output_for_enum_var2) = enum_meth_params( enum_var2 ).
    out->write( data = output_for_enum_var2 name = `output_for_enum_var2` ).
    out->write( |\n| ).

    DATA enum_var3 TYPE t_enum VALUE d.
    DATA(output_for_enum_var3) = enum_meth_params( enum_var3 ).
    out->write( data = output_for_enum_var3 name = `output_for_enum_var3` ).
    out->write( |\n| ).

    DATA(output_for_enum_processing) = enum_processing(  ).
    out->write( data = output_for_enum_processing name = `output_for_enum_processing` ).
    out->write( |\n| ).

    DATA(output_for_rtti_enum) = rtti_enum( ).
    out->write( data = output_for_rtti_enum name = `output_for_rtti_enum` ).

    out->write( zcl_demo_abap_aux=>heading( `24) Typed literals` ) ).

    DATA(tmstamp) = CONV timestamp( '20240808112517' ).
    some_string = `Some string`.
    SELECT SINGLE
      FROM zdemo_abap_fli
      FIELDS
        carrid,
        @some_string AS host_var,
        char`X` AS flag,
        int8`32984723948723` AS int8,
        raw`11` AS raw,
        numc`1234` AS numc,
        utclong`2024-01-01T10:01:02,2` AS utc,
        tims`101507` AS tims,
        curr`173.95` AS curr,
        "Multiple cast expressions splitting a time stamp into date and time parts
        CAST( CAST( div( @tmstamp, 1000000 ) AS CHAR ) AS DATS ) AS date,
        CAST( substring( CAST( @tmstamp AS CHAR ), 9, 6 ) AS TIMS ) AS time,
        "Untyped literal
        'ABAP' AS txt
      WHERE fldate = datn`20240102`
      INTO @DATA(wa_misc_typed_literals).

    out->write( data = wa_misc_typed_literals name = `wa_misc_typed_literals` ).

  ENDMETHOD.

  METHOD rtti_enum.

    DATA enum1 TYPE t_enum.
    enum1 = d.

    DATA enum2 TYPE t_enum_base.
    enum2 = f.

    "Return type information
    DATA(enum_descr) = CAST cl_abap_enumdescr(
          cl_abap_typedescr=>describe_by_data( enum1 ) ).

    APPEND `------ Properties for enum1 ------` TO output.

    APPEND ` kind: ` && enum_descr->kind TO output.
    APPEND ` type_kind: ` && enum_descr->type_kind TO output.
    APPEND ` base_type_kind: ` && enum_descr->base_type_kind TO output.

    DATA mem_string TYPE string.

    "For output purposes, the table content is put in a string.
    "Note the object component selector -> when reading into data reference variables
    "and accessing componts. You can also use the dereferencing operator followed by the
    "structure component selector ref->*-comp.
    LOOP AT enum_descr->members REFERENCE INTO DATA(ref_en1).
      mem_string = mem_string && ` / Name: ` && ref_en1->name && `; Value: ` && ref_en1->*-value.
    ENDLOOP.

    REPLACE FIRST OCCURRENCE OF PCRE `/\s` IN mem_string WITH ``.
    APPEND ` members:` && mem_string TO output.
    CLEAR mem_string.

    enum_descr = CAST cl_abap_enumdescr(
         cl_abap_typedescr=>describe_by_data( enum2 ) ).

    APPEND `------ Properties for enum2 ------` TO output.
    APPEND ` kind: ` && enum_descr->kind TO output.
    APPEND ` type_kind: ` && enum_descr->type_kind TO output.
    APPEND ` base_type_kind: ` && enum_descr->base_type_kind TO output.

    "For output purposes, the table content is put in a string.
    LOOP AT enum_descr->members REFERENCE INTO DATA(ref_en2).
      mem_string = mem_string && ` / Name: ` && ref_en2->name && `; Value: ` && ref_en2->value.
    ENDLOOP.

    REPLACE FIRST OCCURRENCE OF PCRE `/\s` IN mem_string WITH ``.
    APPEND ` members:` && mem_string TO output.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_dynamic_prog DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS:
      class_constructor.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS inst_meth1.
    METHODS inst_meth2 IMPORTING text          TYPE string
                       RETURNING VALUE(result) TYPE string.
    CLASS-METHODS stat_meth1.
    CLASS-METHODS stat_meth2 IMPORTING text   TYPE string
                             EXPORTING result TYPE string.
ENDCLASS.""",
    r"""METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.""",
    r"""METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Dynamic Programming\n\n| ).

**********************************************************************

    out->write( |Excursion: Field Symbols\n\n| ).
    out->write( |1) Declaring Field Symbols\n\n| ).

    "Some data declarations and type definitions used further down
    DATA: str TYPE string.

    TYPES: BEGIN OF struc, "Structured data type
             num1 TYPE i,
             num2 TYPE i,
           END OF struc,
           tab_type TYPE TABLE OF struc. "Internal table type

    "Field symbol declarations
    "- Name of the field symbol goes between angle brackets
    "- Type: either a complete data type or a generic type.

    "Complete types
    "Here, a chained statement with a colon is used.
    FIELD-SYMBOLS: <fs_i>        TYPE i,
                   <fs_flsch>    TYPE zdemo_abap_flsch,
                   <fs_tab_type> TYPE LINE OF tab_type,
                   <fs_like>     LIKE str.

    "Generic types
    "There are plenty of options for generic ABAP types. Check the
    "keyword docu.
    FIELD-SYMBOLS <fs_c>         TYPE c.           "Text field with a generic length
    FIELD-SYMBOLS <fs_cseq>      TYPE csequence.   "Text-like (c, string)
    FIELD-SYMBOLS <fs_data>      TYPE data.        "Any data type
    FIELD-SYMBOLS <fs_any_table> TYPE ANY TABLE.   "Internal table with any table type

    "Declaring field symbols inline
    "Prominent use case: Inline declaration of a field symbol for an internal table
    "following ASSIGNING.
    DATA demo_itab TYPE TABLE OF zdemo_abap_flsch WITH EMPTY KEY.

    LOOP AT demo_itab ASSIGNING FIELD-SYMBOL(<line>).
      ...
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Assigning Data Objects to Field Symbols` ) ).

    "ASSIGN statements assigns the memory area of a data object to a field symbol.
    "Once the memory area is assigned, you can work with the content.
    "You can also assign a particular component of a structure. Either you
    "specify the position of the component or the name of the component.

    "Data objects.
    DATA: num_a   TYPE i,
          struc_a TYPE zdemo_abap_fli,
          tab_a   TYPE string_table.

    "Field symbols with complete types
    FIELD-SYMBOLS: <fs_i_a>     TYPE i,
                   <fs_struc_a> TYPE zdemo_abap_fli,
                   <fs_tab_a>   TYPE string_table.

    "Field symbols with generic types, see more examples bwloe
    FIELD-SYMBOLS <fs_data_a>   TYPE data.
    FIELD-SYMBOLS <fs_anytab_a> TYPE ANY TABLE.

    "Assigning data objects to field symbols
    ASSIGN num_a    TO <fs_i_a>.
    ASSIGN struc_a  TO <fs_struc_a>.
    ASSIGN tab_a    TO <fs_tab_a>.
    ASSIGN: num_a   TO <fs_data_a>,
            struc_a TO <fs_data_a>,
            tab_a   TO <fs_data_a>,
            tab_a   TO <fs_anytab_a>.

    "Inline declaration is possible, too. The field symbol is implicitly typed
    "with the generic type data.
    ASSIGN num_a TO FIELD-SYMBOL(<fs_inl>).

    "Generic typing
    "- Generic types are available with which formal parameters of methods or field symbols
    "  can be specified.
    "- At runtime, the actual data type is copied from the assigned actual parameter or
    "  memory area, i.e. they receive the complete data type only when an actual parameter
    "  is passed or a memory area is assigned.

    FIELD-SYMBOLS:
      "Any data type
      <data>           TYPE data,
      <any>            TYPE any,
      "Any data type can be assigned. Restrictions for formal parameters and 'data': no
      "numeric functions, no description functions, and no arithmetic expressions can be
      "passed to these parameters. However, you can bypass the restriction by applying the
      "CONV operator for the actual parameter.

      "Character-like types
      <c>              TYPE c,         "Text field with a generic length
      <clike>          TYPE clike,     "Character-like (c, n, string, d, t and character-like flat structures)
      <csequence>      TYPE csequence, "Text-like (c, string)
      <n>              TYPE n,         "Numeric text with generic length
      <x>              TYPE x,         "Byte field with generic length
      <xsequence>      TYPE xsequence, "Byte-like (x, xstring)

      "Numeric types
      <decfloat>       TYPE decfloat, "decfloat16, decfloat34)
      <numeric>        TYPE numeric,  "Numeric ((b, s), i, int8, p, decfloat16, decfloat34, f)
      <p>              TYPE p,        "Packed number (generic length and number of decimal places)

      "Internal table types
      <any_table>      TYPE ANY TABLE,      "Internal table with any table type
      <hashed_table>   TYPE HASHED TABLE,
      <index_table>    TYPE INDEX TABLE,
      <sorted_table>   TYPE SORTED TABLE,
      <standard_table> TYPE STANDARD TABLE,
      <table>          TYPE table,          "Standard table

      "Other types
      <simple>         TYPE simple, "Elementary data type including enumerated types and
      "structured types with exclusively character-like flat components
      <object>         TYPE REF TO object. "object can only be specified after REF TO; can point to any object

    "Data objects to work with
    DATA: BEGIN OF s,
            c3        TYPE c LENGTH 3,
            c10       TYPE c LENGTH 10,
            n4        TYPE n LENGTH 4,
            str       TYPE string,
            time      TYPE t,
            date      TYPE d,
            dec16     TYPE decfloat16,
            dec34     TYPE decfloat34,
            int       TYPE i,
            pl4d2     TYPE p LENGTH 4 DECIMALS 2,
            tab_std   TYPE STANDARD TABLE OF string WITH EMPTY KEY,
            tab_so    TYPE SORTED TABLE OF string WITH NON-UNIQUE KEY table_line,
            tab_ha    TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line,
            xl1       TYPE x LENGTH 1,
            xstr      TYPE xstring,
            structure TYPE zdemo_abap_carr, "character-like flat structure
            oref      TYPE REF TO object,
          END OF s.

    "The following static ASSIGN statements demonstrate various assignments
    "Note:
    "- The statements commented out show impossible assignments.
    "- If a static assignment is not successful, sy-subrc is not set and no
    "  memory area is assigned. Dynamic assignments, however, set the value.

    "----- Any data type -----
    ASSIGN s-c3 TO <data>.
    ASSIGN s-time TO <data>.
    ASSIGN s-tab_std TO <data>.
    ASSIGN s-xstr TO <any>.
    ASSIGN s-pl4d2 TO <any>.
    ASSIGN s-date TO <any>.

    "----- Character-like types -----
    ASSIGN s-c3 TO <c>.
    ASSIGN s-c10 TO <c>.
    "ASSIGN s-str TO <c>.

    ASSIGN s-c10 TO <clike>.
    ASSIGN s-str TO <clike>.
    ASSIGN s-n4 TO <clike>.
    ASSIGN s-date TO <clike>.
    ASSIGN s-time TO <clike>.
    ASSIGN s-structure TO <clike>.

    ASSIGN s-c10 TO <csequence>.
    ASSIGN s-str TO <csequence>.
    "ASSIGN s-n4 TO <csequence>.

    ASSIGN s-n4 TO <n>.
    "ASSIGN s-int TO <n>.
    "ASSIGN s-time TO <n>.

    ASSIGN s-xl1 TO <x>.
    "ASSIGN s-xstr TO <x>.

    ASSIGN s-xl1 TO <xsequence>.
    ASSIGN s-xstr TO <xsequence>.

    "----- Numeric types -----
    ASSIGN s-dec16 TO <numeric>.
    ASSIGN s-dec34 TO <numeric>.
    ASSIGN s-int TO <numeric>.
    ASSIGN s-pl4d2 TO <numeric>.
    "ASSIGN s-n4 TO <numeric>.

    ASSIGN s-dec16 TO <decfloat>.
    ASSIGN s-dec34 TO <decfloat>.

    ASSIGN s-pl4d2 TO <p>.
    "ASSIGN s-dec34 TO <p>.

    "----- Internal table types -----
    ASSIGN s-tab_std TO <any_table>.
    ASSIGN s-tab_so TO <any_table>.
    ASSIGN s-tab_ha TO <any_table>.

    ASSIGN s-tab_std TO <index_table>.
    ASSIGN s-tab_so TO <index_table>.
    "ASSIGN s-tab_ha TO <index_table>.

    "ASSIGN s-tab_std TO <sorted_table>.
    ASSIGN s-tab_so TO <sorted_table>.
    "ASSIGN s-tab_ha TO <sorted_table>.

    ASSIGN s-tab_std TO <standard_table>.
    ASSIGN s-tab_std TO <table>.
    "ASSIGN s-tab_so TO <standard_table>.
    "ASSIGN s-tab_so TO <table>.
    "ASSIGN s-tab_ha TO <standard_table>.
    "ASSIGN s-tab_ha TO <table>.

    "ASSIGN s-tab_std TO <hashed_table>.
    "ASSIGN s-tab_so TO <hashed_table>.
    ASSIGN s-tab_ha TO <hashed_table>.

    "----- Other types -----
    ASSIGN s-c10 TO <simple>.
    ASSIGN s-str TO <simple>.
    ASSIGN s-dec34 TO <simple>.
    ASSIGN s-date TO <simple>.
    ASSIGN s-structure TO <simple>.
    ASSIGN s-xl1 TO <simple>.
    "ASSIGN s-tab_ha TO <simple>.

    ASSIGN s-oref TO <object>.
    s-oref = NEW zcl_demo_abap_objects( ).
    ASSIGN s-oref TO <object>.
    s-oref = cl_abap_random_int=>create( ).
    ASSIGN s-oref TO <object>.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Checking Field Symbol Assignment` ) ).

    "When working with field symbols, you should make sure that they are
    "assigned. Otherwise, a runtime error occurs.
    "You can make use of a logical expression with IS [NOT] ASSIGNED.
    "The example includes data object declarations. One data object is
    "assigned, the other is not. Consequently, the expression is
    "true for the one and false for the other.

    DATA num_b TYPE i VALUE 123.

    FIELD-SYMBOLS: <fs_i_b>   TYPE i,
                   <fs_str_b> TYPE string.

    ASSIGN num_b TO <fs_i_b>.

    IF <fs_i_b> IS ASSIGNED.
      out->write( `Field symbol <fs_i_b> is assigned.` ).
    ELSE.
      out->write( `Field symbol <fs_i_b is> not assigned.` ).
    ENDIF.

    out->write( |\n| ).

    IF <fs_str_b> IS ASSIGNED.
      out->write( `Field symbol <fs_str_b> is assigned.` ).
    ELSE.
      out->write( `Field symbol <fs_str_b> is not assigned.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Unassigning Data Objects from Field Symbols` ) ).

    "If you use an unassigned field symbol, an exception is raised. Before
    "using it, you can check the assignment with the following logical
    "expression. The statement is true if the field symbol is assigned.
    "Using the statement UNASSIGN, you can explicitly remove the assignment
    "of the field symbol.

    DATA num_c TYPE i VALUE 123.

    FIELD-SYMBOLS: <fs_i_c> TYPE i.

    ASSIGN num_c TO <fs_i_c>.

    IF <fs_i_c> IS ASSIGNED.
      out->write( `1. Field symbol <fs_i_c> is assigned.` ).
    ELSE.
      out->write( `1. Field symbol <fs_i_c> is not assigned.` ).
    ENDIF.

    out->write( |\n| ).

    UNASSIGN <fs_i_c>.

    IF <fs_i_c> IS ASSIGNED.
      out->write( `2. Field symbol <fs_i_c> is assigned.` ).
    ELSE.
      out->write( `2. Field symbol <fs_i_c> is not assigned.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Type Casting with Field Symbols` ) ).

    "The example demonstrates the CASTING addition. Various additions after
    "CASTING are possible.

    TYPES type_d_l9 TYPE c LENGTH 9.

    DATA: dobj_d_l5   TYPE c LENGTH 5,
          dobj_d_l10  TYPE c LENGTH 10 VALUE '1234567890',
          type_name_d TYPE string VALUE 'TYPE_D_L9'.

    FIELD-SYMBOLS: <fs_d1> TYPE data,
                   <fs_d2> TYPE type_d_l9.

    "Casting to a statically, completely specified type
    "CASTING addition without any more additions: Field symbol inherits
    "the data type of the data object. The field symbol must be either
    "completely typed or with one of the generic built-in ABAP types
    "c, n, p, or x. The other field symbol declared in the example
    "cannot be used.
    ASSIGN dobj_d_l10 TO <fs_d2> CASTING.

    out->write( data = <fs_d2> name = `<fs_d2>` ).
    out->write( |\n| ).

    ASSIGN dobj_d_l10 TO <fs_d1> CASTING TYPE type_d_l9.

    out->write( data = <fs_d1> name = `<fs_d1>` ).
    out->write( |\n| ).

    "Casting to a generic type
    ASSIGN dobj_d_l10 TO <fs_d1> CASTING TYPE c.

    out->write( data = <fs_d1> name = `<fs_d1>` ).
    out->write( |\n| ).

    "Casting to a static field type
    ASSIGN dobj_d_l10 TO <fs_d1> CASTING LIKE dobj_d_l5.

    out->write( data = <fs_d1> name = `<fs_d1>` ).
    out->write( |\n| ).

    "Casting to a dynamic field type
    ASSIGN dobj_d_l10 TO <fs_d1> CASTING LIKE <fs_d1>.

    out->write( data = <fs_d1> name = `<fs_d1>` ).
    out->write( |\n| ).

    "Anticipating dynamic specification of data types
    "for the CASTING addition.
    "The type name is specified as a character-like data
    "object within parentheses.
    ASSIGN dobj_d_l10 TO <fs_d1> CASTING TYPE (type_name_d).

    out->write( data = <fs_d1> name = `<fs_d1>` ).
    out->write( |\n| ).

    "Anticipating RTTS
    "A type description object is created which can be
    "specified after the TYPE HANDLE additions.
    DATA(sometype) = CAST cl_abap_datadescr(
      cl_abap_typedescr=>describe_by_name( 'TYPE_D_L9' ) ).
    ASSIGN dobj_d_l10 TO <fs_d1> CASTING TYPE HANDLE sometype.

    out->write( data = <fs_d1> name = `<fs_d1>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Addressing Field Symbols` ) ).

    "The example includes multiple data objects that are assigned to field
    "symbols. It is demonstrated that field symbols are addressed in various
    "occasions. Among them: Changing the value of data objects assigned to
    "field symbols, the use of field symbols in expressions, structures, and
    "internal tables.

    DATA: num_e   TYPE i VALUE 456,
          struc_e TYPE zdemo_abap_carr,
          tab_e   TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.

    SELECT SINGLE *
      FROM zdemo_abap_carr
      WHERE carrid = 'LH'
      INTO @struc_e.

    FIELD-SYMBOLS: <fs_i_e>      TYPE i,
                   <fs_struc_e>  TYPE zdemo_abap_carr,
                   <fs_tab_e>    LIKE tab_e,
                   <fs_anytab_e> TYPE ANY TABLE.

    "Without an assignment, this would result in a runtime error:
    "<fs_i_e> = 1.

    ASSIGN num_e   TO <fs_i_e>.
    ASSIGN struc_e TO <fs_struc_e>.
    ASSIGN tab_e   TO <fs_tab_e>.
    ASSIGN tab_e   TO <fs_anytab_e>.

    "Changing values
    <fs_i_e> = 789.

    out->write( data = <fs_i_e> name = `<fs_i_e>` ).
    out->write( |\n| ).
    out->write( data = num_e name = `num_e` ).
    out->write( |\n| ).

    "Use in expressions
    DATA(calc_e) = <fs_i_e> + 211.

    out->write( data = calc_e name = `calc_e` ).
    out->write( |\n| ).

    IF <fs_i_e> < 1000.
      out->write( `The value of <fs_i_e> is less than 1000` ).
    ELSE.
      out->write( `The value of <fs_i_e> is greater than 1000` ).
    ENDIF.

    out->write( |\n| ).
    out->write( |\n| ).

    "Structure
    out->write( data = <fs_struc_e> name = `<fs_struc_e>` ).
    out->write( |\n| ).

    DATA(comp_e1) = <fs_struc_e>-carrid.

    out->write( data = comp_e1 name = `comp_e1` ).
    out->write( |\n| ).

    <fs_struc_e>-url = 'www.lh.com'.

    out->write( data = <fs_struc_e>-url name = `<fs_struc_e>-url` ).
    out->write( |\n| ).

    "Internal table
    SELECT *
      FROM zdemo_abap_carr
      ORDER BY carrid
      INTO TABLE @<fs_tab_e>
      UP TO 3 ROWS.

    out->write( data = <fs_tab_e> name = `<fs_tab_e>` ).
    out->write( |\n| ).

    TRY.
        DATA(comp_e2) = <fs_tab_e>[ 2 ]-carrname.
        out->write( data = comp_e2 name = `comp_e2` ).
      CATCH cx_sy_itab_line_not_found INTO DATA(error_e).
    ENDTRY.

    out->write( |\n| ).

    SELECT *
      FROM zdemo_abap_carr
      ORDER BY carrid
      INTO TABLE @<fs_anytab_e>
      UP TO 3 ROWS.

    out->write( data = <fs_anytab_e> name = `<fs_anytab_e>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Using Field Symbols when Processing Internal Tables` ) ).

    "By using field symbols in the context of loops across internal tables,
    "you can avoid an actual copying of content to a work area during
    "the loop.
    "The example includes multiple loops. First, internal tables are
    "declared. One of them is filled. Then, field symbols are declared to
    "which data objects are assigned. In the first loop, a previously
    "declared field symbol is used as target area to hold the table line
    "that is processed. In the course of the loop, some values are changed. The
    "components are accessed using the component selector '-'. At the end of
    "the loop, another internal table is filled using the currently
    "processed line for the second loop. The second loop (the loop is
    "carried out based on
    "an internal table a field symbol points to) uses a directly declared
    "field symbol using ASSIGNING FIELD-SYMBOL(<...>). Also here, some
    "values are changed and another internal table is filled. This table
    "is of a generic type. At the end, this internal table is output, too.

    DATA: tab_f1 TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
          tab_f2 LIKE tab_f1,
          tab_f3 LIKE tab_f1.

    SELECT *
      FROM zdemo_abap_fli
      ORDER BY carrid
      INTO TABLE @tab_f1
      UP TO 3 ROWS.

    FIELD-SYMBOLS: <fs_struc_f>  LIKE LINE OF tab_f1,
                   <fs_tab_f>    LIKE tab_f1,
                   <fs_anytab_f> TYPE ANY TABLE.

    ASSIGN tab_f2 TO <fs_tab_f>.
    ASSIGN tab_f3 TO <fs_anytab_f>.

    LOOP AT tab_f1 ASSIGNING <fs_struc_f>.
      <fs_struc_f>-connid = '99'.
      <fs_struc_f>-fldate = cl_abap_context_info=>get_system_date( ).
      <fs_struc_f>-price = <fs_struc_f>-price + 100.
      <fs_struc_f>-currency = 'EUR'.
      CLEAR: <fs_struc_f>-paymentsum,
             <fs_struc_f>-seatsocc,
             <fs_struc_f>-seatsocc_b,
             <fs_struc_f>-seatsocc_f.

      "Filling another itab
      <fs_tab_f> = VALUE #( BASE <fs_tab_f> ( <fs_struc_f> ) ).
    ENDLOOP.

    out->write( data = tab_f1 name = `tab_f1` ).
    out->write( |\n| ).

    "The following example shows a field symbol declared inline.
    LOOP AT <fs_tab_f> ASSIGNING FIELD-SYMBOL(<fs_struc_f2>).
      <fs_struc_f2>-connid = '100'.
      <fs_struc_f2>-fldate = cl_abap_context_info=>get_system_date( ) + 1.
      <fs_struc_f2>-price = <fs_struc_f2>-price - 50.
      <fs_struc_f2>-currency = 'USD'.

      "Filling another itab
      <fs_anytab_f> = VALUE #( BASE <fs_anytab_f> ( <fs_struc_f2> ) ).
    ENDLOOP.

    out->write( data = <fs_tab_f> name = `<fs_tab_f>` ).
    out->write( |\n| ).
    out->write( data = <fs_anytab_f> name = `<fs_anytab_f>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Structure Assigned to Field Symbol: Accessing Structure Components` ) ).

    "In this example, all components of a structure are processed using
    "field symbols and an ASSIGN COMPONENT ... OF STRUCTURE ... statement.
    "First, a field symbol is declared with a generic type. A structure is
    "filled with values from a demo table. The structure is assigned to the
    "field symbol. Using a DO loop, all components are processed. The
    "sy-index value represents the position of the component in the
    "structure. Once all components have been processed (i. e. if sy-subrc
    "does not return '0' for a sy-index value), the loop is exited. The output
    "shows all components and their values.
    "See more examples for accessing structure components below.

    FIELD-SYMBOLS <comp> TYPE data.

    DATA comp_tab TYPE string_table.

    SELECT SINGLE carrid, carrname, currcode, url
      FROM zdemo_abap_carr
      WHERE carrid = 'LH'
      INTO @DATA(struct).

    FIELD-SYMBOLS <struct> TYPE data.

    ASSIGN struct TO <struct>.

    DO.
      "sy-index represents the position of a structure component
      ASSIGN <struct>-(sy-index) TO <comp>.

      "Old syntax
      "ASSIGN COMPONENT sy-index OF STRUCTURE <struct> TO <comp>.

      IF sy-subrc <> 0.
        "If all components are processed, the loop is exited.
        EXIT.
      ELSE.
        out->write( |sy-index: { sy-index }, component content:| ).
        out->write( <comp> ).
        out->write( |\n| ).
      ENDIF.

    ENDDO.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Data References` ) ).
    out->write( |9) Declaring Data References\n\n| ).

    "Like field symbols, data reference variables can be declared with both
    "a complete and a generic data type using DATA statements and the
    "addition REF TO. The type after REF TO represents the static data type.
    "The example shows multiple ways of declaring a data reference variable
    "using both complete and generic data types.

    DATA: some_string TYPE string.

    TYPES: ref_type TYPE REF TO zdemo_abap_flsch.

    DATA: ref_a1 TYPE REF TO i, "Complete data type
          ref_a2 TYPE REF TO zdemo_abap_carr, "Complete data type
          ref_a3 LIKE REF TO some_string,
          ref_a4 LIKE ref_a1,
          ref_a5 TYPE ref_type,
          ref_a6 TYPE REF TO data. "Generic data type

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Creating Data References ` &&
    `to Existing Data Objects` ) ).

    "The example includes data reference variables with both complete and
    "generic type. When using the REF operator, the '#' sign means that the
    "type is derived from the data object. You can also explicitly specify
    "the data type after REF before the parenthesis. Within the parentheses,
    "you can provide a value.

    "Declaring data object
    DATA number_b TYPE i VALUE 5.

    "Declaring data reference variables
    DATA ref_b1     TYPE REF TO i.
    DATA ref_data_b TYPE REF TO data.

    "Creating data references to data objects.
    "The '#' sign means that the type is derived from the data object.
    ref_b1     = REF #( number_b ).
    ref_data_b = REF #( number_b ).

    "You can also use inline declarations to omit the explicit declaration.
    DATA(ref_b2) = REF #( number_b ).

    "You can explicitly specify the data type after REF.
    "DATA(ref_b3) = REF #( g ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Dynamically Creating Data Objects at Runtime Using Static Type Definitions` ) ).

    "The example code shows the creation of anonymous data objects. They
    "can be created using the statement CREATE DATA, the instance operator
    "NEW, or the addition NEW of the INTO clause in a SELECT statement.
    "A data reference variable is expected when anonymous objects are
    "declared. They cannot be addressed by a name (hence anonymous).
    "Note:
    "- The examples cover static type definitions. As shown further down,
    "  there are options to dynamically specify the type definitions.
    "- To output the content of the data reference variables, they
    "  must be dereferenced first. The details are shown further down.

    "CREATE DATA statements
    "Note that there are many additions available. The examples show a selection.
    "Behind TYPE and LIKE, the syntax offers the same possibilities as the DATA statement.

    "Creating an anonymous data object with an implicit type.
    "If neither of the additions TYPE or LIKE are specified, the data reference variable
    "must be completely typed.
    DATA dref_c1 TYPE REF TO string.
    CREATE DATA dref_c1.

    "Creating anonymous data objects with explicit data type specification.
    "Data reference variable with a generic type to be used in the following examples
    "for the anonymous data object.
    DATA dref_c2 TYPE REF TO data.

    "Elementary, built-in ABAP type
    CREATE DATA dref_c2 TYPE p LENGTH 8 DECIMALS 3.

    "Anomyous internal table ...
    "using the LIKE addition to refer to an existing internal table
    DATA itab_c TYPE TABLE OF zdemo_abap_carr.
    CREATE DATA dref_c2 LIKE itab_c.

    "by specifying the entire table type
    CREATE DATA dref_c2 TYPE HASHED TABLE OF zdemo_abap_carr WITH UNIQUE KEY carrid.

    "Anonymous structures
    CREATE DATA dref_c2 LIKE LINE OF itab_c.
    CREATE DATA dref_c2 TYPE zdemo_abap_carr.

    "Creating reference variable
    TYPES elem_type_c TYPE c LENGTH 3.
    CREATE DATA dref_c2 TYPE REF TO elem_type_c.

    "NEW operator
    "- Works like CREATE DATA dref TYPE type statements and can be used in general
    "  expression positions.
    "- Allows to assign values to the new anonymous data objects in parentheses

    "Creating data reference variables
    DATA: dref_c3 TYPE REF TO i,
          dref_c4 TYPE REF TO data.

    "# character after NEW if the data type can be identified completely
    "instead of the explicit type specification (only non-generic types)
    dref_c3 = NEW #( 123 ).
    dref_c3 = NEW i( 456 ).
    dref_c4 = NEW zdemo_abap_carr( ). "not assigning any values
    dref_c4 = NEW string( `hi` ).

    "Creating anonymous data objects inline
    "In doing so, you can omit a prior declaration of a variable.
    DATA(dref_c5) = NEW i( 789 ).
    DATA(dref_c6) = NEW zdemo_abap_carr( carrid = 'AB' carrname = 'AB Airlines' ).

    "ABAP SQL SELECT statements
    "Using the NEW addition in the INTO clause, an anonymous data object
    "can be created in place.
    SELECT *
      FROM zdemo_abap_carr
      INTO TABLE NEW @DATA(dref_c7)   "Internal table
      UP TO 3 ROWS.

    SELECT SINGLE *
      FROM zdemo_abap_carr
      WHERE carrid = 'LH'
      INTO NEW @DATA(dref_c8). "Structure

    out->write( data = dref_c6->* name = `dref_c6->*` ).
    out->write( |\n| ).
    out->write( data = dref_c7->* name = `dref_c7->*` ).
    out->write( |\n| ).
    out->write( data = dref_c8->* name = `dref_c8->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Data References and Assignments` ) ).

    "Regarding the assignment, note that static types of both data
    "reference variables must be compatible. As a result of an assignment,
    "both the target reference variable and the source reference variable
    "point to the same data object.
    "Upcast/downcasts: For an assignment to work, the basic rule applies:
    "The static type of the target reference variable must be more general
    "than or the same as the dynamic type of the source reference variable.
    "In the example below:
    "Upcast: The target data reference variable is of generic type, the
    "source variable is of complete type. The assignment is done with the
    "assignment operator '='.
    "Downcast: The target data reference variable is of complete type, the
    "source variable is of generic type. The assignment is done with casting
    "operators, either with the constructor operator CAST or the older ?=.

    "Declaring data reference variables
    DATA ref_d1 TYPE REF TO i.
    DATA ref_d2 TYPE REF TO i.

    ref_d1 = NEW #( 789 ).

    "Assigning data reference
    ref_d2 = ref_d1.

    "Casting
    "Complete type
    DATA(ref_d3) = NEW i( 321 ).

    "Generic type
    DATA ref_data_d1 TYPE REF TO data.

    "Upcast
    ref_data_d1 = ref_d3.

    "Downcasts
    DATA ref_d5 TYPE REF TO i.

    "Generic type
    DATA ref_data_d2 TYPE REF TO data.

    ref_data_d2 = NEW i( 654 ).

    ref_d5 = CAST #( ref_data_d2 ).

    ref_d5 ?= ref_data_d2.

    out->write( data = ref_d2->* name = `ref_d2->*` ).
    out->write( |\n| ).
    out->write( data = ref_data_d1->* name = `ref_data_d1->*` ).
    out->write( |\n| ).
    out->write( data = ref_d5->* name = `ref_d5->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Addressing Data References ` ) ).

    "Before addressing the content of data objects a data reference points
    "to, you must dereference data reference variables. Use the
    "dereferencing operator ->*.
    "The example includes multiple occasions in which data reference are
    "addressed: Changing the content of a referenced data object, the use in
    "logical expressions, structures, and internal tables.

    "Creating data reference variables and assigning values
    DATA(ref_e1) = NEW i( 1 ).
    DATA(ref_e2) = NEW zdemo_abap_carr( carrid   = 'LH'
                                        carrname = 'Lufthansa' ).

    "Generic type
    DATA ref_data_e TYPE REF TO data.

    "Copying reference
    ref_data_e = ref_e1.

    "Addressing
    "Variable receives the content.
    DATA(some_num) = ref_e1->*.

    out->write( data = ref_e1->* name = `ref_e1->*` ).
    out->write( |\n| ).

    "Content of referenced data object is changed
    ref_e1->* = 10.

    out->write( data = ref_e1->* name = `ref_e1->*` ).
    out->write( |\n| ).

    "Data reference used in a logical expression
    IF ref_e1->* > 5.
      out->write( `The value of ref_e1 is greater than 5.` ).
    ELSE.
      out->write( `The value of ref_e1 is lower than 5.` ).
    ENDIF.

    out->write( |\n| ).

    "Dereferenced generic type
    DATA(calc) = 1 + ref_data_e->*.

    out->write( data = calc name = `calc` ).
    out->write( |\n| ).

    "Complete structure
    DATA(struc) = ref_e2->*.

    out->write( data = ref_e2->* name = `ref_e2->*` ).
    out->write( |\n| ).

    "Individual structure component
    "When dereferencing a data reference variable that has a structured
    "data type, you can use the component selector -> to address individual components.
    DATA(carrid) = ref_e2->carrid.

    ref_e2->carrid = 'UA'.

    out->write( data = ref_e2->carrid name = `ref_e2->carrid` ).
    out->write( |\n| ).

    "The following syntax also works (dereferencing operator and the component selector).
    ref_e2->*-carrname = 'United Airlines'.

    out->write( data = ref_e2->*-carrname name = `ref_e2->*-carrname` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) Checking if Data Reference ` &&
   `Can Be Dereferenced` ) ).

    "You can check if a data reference can be dereferenced by using
    "a logical expression with IS [NOT] BOUND.
    "The example shows both a data reference that is bound and not bound.

    DATA(ref_f1) = NEW string( `hello` ).
    DATA ref_f2 TYPE REF TO i.

    out->write( `IF statement:` ).
    IF ref_f1 IS BOUND.
      out->write( `ref_f1 is bound.` ).
    ELSE.
      out->write( `ref_f1 is not bound.` ).
    ENDIF.

    out->write( |\n| ).
    out->write( `COND operator:` ).
    DATA(is_bound) = COND #( WHEN ref_f1 IS BOUND THEN `ref_f1 is bound.` ELSE `ref_f1 is not bound.` ).
    out->write( is_bound ).
    out->write( |\n| ).

    out->write( `IF statement:` ).
    IF ref_f2 IS BOUND.
      out->write( `ref_f2 is bound.` ).
    ELSE.
      out->write( `ref_f2 is not bound.` ).
    ENDIF.

    out->write( |\n| ).
    out->write( `COND operator:` ).
    is_bound = COND #( WHEN ref_f2 IS BOUND THEN `ref_f2 is bound.` ELSE `ref_f2 is not bound.` ).
    out->write( is_bound ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Explicitly Removing a Reference` ) ).

    "Note that the garbage collector takes care of removing the references
    "automatically once the data is not used any more by a reference.

    DATA(ref_g1) = NEW string( `hello` ).

    IF ref_g1 IS INITIAL.
      out->write( `Before CLEAR: ref_g1 is initial.` ).
    ELSE.
      out->write( `Before CLEAR: ref_g1 is not intial.` ).
    ENDIF.

    out->write( |\n| ).

    IF ref_g1 IS BOUND.
      out->write( `Before CLEAR: ref_g1 is bound.` ).
    ELSE.
      out->write( `Before CLEAR: ref_g1 is not bound.` ).
    ENDIF.

    out->write( |\n| ).

    CLEAR ref_g1.

    IF ref_g1 IS INITIAL.
      out->write( `After CLEAR: ref_g1 is initial.` ).
    ELSE.
      out->write( `After CLEAR: ref_g1 is not initial.` ).
    ENDIF.

    out->write( |\n| ).

    IF ref_g1 IS BOUND.
      out->write( `After CLEAR: ref_g1 is bound.` ).
    ELSE.
      out->write( `After CLEAR: ref_g1 is not bound.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Overwriting Data Reference Variables` ) ).

    "A data reference variable is overwritten if a new object is created
    "with a data reference variable already pointing to a data object

    DATA ref_h1 TYPE REF TO data.

    ref_h1 = NEW i( 111 ).

    out->write( data = ref_h1->* name = `ref_h1->*` ).
    out->write( |\n| ).

    ref_h1 = NEW string( `ref_h1 overwritten.` ).

    out->write( data = ref_h1->* name = `ref_h1->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) Retaining Data References` ) ).

    "Storing data reference variables in an internal table using
    "TYPE TABLE OF REF TO prevents the overwriting.
    "The example demonstrates that three data references are created with
    "the same reference variable in the course of a DO loop. There, the data
    "reference is overwritten. However, due to saving the data reference
    "variable in an internal table, the content is preserved.

    DATA: ref_data_i TYPE REF TO data,
          itab_i     TYPE TABLE OF REF TO data,
          number_i   TYPE i VALUE 0.

    DO 3 TIMES.
      "Adding up 1 to demonstrate a changed data object
      number_i += 1.

      "Creating a data reference and assigning value
      "In the course of the loop, the variable is overwritten.
      ref_data_i = NEW i( number_i ).

      "Adding the reference to an internal table
      itab_i     = VALUE #( BASE itab_i ( ref_data_i ) ).
    ENDDO.

    out->write( data = itab_i name = `itab_i` ).
    out->write( |\n| ).
    out->write( data = `The derefenced value of the data reference - which ` &&
    `was changed in the course of the loop - in the second table ` &&
    `entry is ` && itab_i[ 2 ]->* && `.` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) Processing Internal Tables Using ` &&
    `Data References ` ) ).

    "Similar use case to using field symbols: In a loop across an internal table,
    "you can store the content of the line in a data reference variable
    "instead of actually copying the content to boost performance.
    "In the example, an internal table is created including values of
    "database table. A data reference variable is declared as target area of
    "the loop. In the course of the loop, some values are changed.

    SELECT *
      FROM zdemo_abap_flsch
      WHERE distid = 'MI'
      ORDER BY carrid
      INTO TABLE @DATA(flsch_tab)
      UP TO 3 ROWS.

    "The table line is written into a data reference variable
    "that is declared inline.
    LOOP AT flsch_tab REFERENCE INTO DATA(ref_k).
      ref_k->connid = '123'.
      ref_k->distance =  ref_k->distance * '1.609344'.
      ref_k->distid =  'KM' .
    ENDLOOP.

    out->write( data = flsch_tab name = `flsch_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) Data References as Part of ` &&
   `Structures and Internal Tables` ) ).

    "In contrast to field symbols, data reference variables can be used as
    "components of structures or columns in internal tables.
    "The example includes the declaration of a structure that contains a
    "data reference variable.
    "The structure is filled. Based on this structure, an
    "internal table is created. In a DO loop, the internal table is filled.

    "Declaring a structure
    DATA: BEGIN OF struc_l,
            number_l TYPE i,
            ref_l    TYPE REF TO i,
          END OF struc_l,
          some_int TYPE i VALUE 0.

    "Filling structure
    struc_l = VALUE #( number_l = 1 ref_l = NEW #( 2 ) ).

    out->write( data = struc_l ).
    out->write( |\n| ).

    "Declaring an internal table
    DATA itab_l LIKE TABLE OF struc_l WITH EMPTY KEY.

    "Filling internal table.
    DO 3 TIMES.
      some_int += 1.

      "Filling structure
      struc_l = VALUE #( number_l = some_int
                         ref_l    = NEW #( some_int ) ).

      "Filling internal table
      itab_l  = VALUE #( BASE itab_l ( struc_l ) ).
    ENDDO.

    out->write( data = itab_l name = `itab_l` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) Excursion: Generic Data References` ) ).

    "In modern ABAP, variables and field symbols of the generic types
    "'any' and 'data' can be used directly, for example, in LOOP and READ statements.
    DATA dref_gen TYPE REF TO data.
    CREATE DATA dref_gen TYPE TABLE OF zdemo_abap_carr.
    SELECT *
      FROM zdemo_abap_carr
      INTO TABLE @dref_gen->*.

    "Note: In case of a fully generic type, an explicit or implicit index operation
    "is not possible (indicated by the examples commented out).
    LOOP AT dref_gen->* ASSIGNING FIELD-SYMBOL(<loop>).
      ...
    ENDLOOP.
    "LOOP AT dref->* ASSIGNING FIELD-SYMBOL(<loop2>) FROM 1 TO 4.
    "ENDLOOP.

    "The following examples use a dynamic key specification.
    "See more syntax examples below.
    READ TABLE dref_gen->* ASSIGNING FIELD-SYMBOL(<read>) WITH KEY ('CARRID') = 'AA'.
    "READ TABLE dref->* INDEX 1 ASSIGNING FIELD-SYMBOL(<read2>).
    out->write( data = <read> name = `<read>` ).
    out->write( |\n| ).

    "Table expressions
    DATA(line) = CONV zdemo_abap_carr( dref_gen->*[ ('CARRID') = 'AA' ] ).

    out->write( data = line name = `line` ).
    out->write( |\n| ).

    dref_gen->*[ ('CARRID') = 'AA' ] = VALUE zdemo_abap_carr( BASE dref_gen->*[ ('CARRID') = 'AA' ] carrid = 'XY' ).

    out->write( data = dref_gen->*[ ('CARRID') = 'XY' ] name = `dref_gen->*[ ('CARRID') = 'XY' ]` ).
    out->write( |\n| ).

    dref_gen->*[ ('CARRID') = 'XY' ]-('CARRID') = 'AA'.

    out->write( data = dref_gen->*[ ('CARRID') = 'AA' ]-('CARRNAME') name = `dref_gen->*[ ('CARRID') = 'AA' ]-('CARRNAME')` ).
    out->write( |\n| ).

    "Table functions
    DATA(num_tab_lines) = lines( dref_gen->* ).

    out->write( data = num_tab_lines name = `num_tab_lines` ).
    out->write( |\n| ).

    DATA(idx) = line_index( dref_gen->*[ ('CARRID') = 'LH' ] ).

    out->write( data = idx name = `idx` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Dynamic ABAP Statements` ) ).
    out->write( |21) Dynamic ASSIGN Statements (1) - Specifying the Memory Area Dynamically\n\n| ).
    "The memory area is not specified directly, but as content of a
    "character-like data object in parentheses.
    "Note:
    "- When specified as unnamed data object, the compiler treats the
    "  specifications like static assignments. Do not use named data objects
    "  for ASSIGN statements in ABAP for Cloud Development. It is recommended
    "  that existing named data objects are put in a structure. Then, the syntax
    "  for assigning components dynamically can be used so as to avoid a syntax
    "  warning.
    "- Most of the following examples use an unnamed data object.
    "- The specification of the name is not case-sensitive.

    "Creating and populating various types/data objects to work with
    TYPES: BEGIN OF st_type,
             col1 TYPE i,
             col2 TYPE string,
             col3 TYPE string,
           END OF st_type.
    DATA structure TYPE st_type.
    DATA it TYPE TABLE OF st_type WITH EMPTY KEY.
    structure = VALUE #( col1 = 1 col2 = `aaa` col3 = `Z` ).
    APPEND structure TO it.
    DATA(struc_ref) = NEW st_type( col1 = 2 col2 = `b` col3 = `Y` ).
    DATA dobj TYPE string VALUE `hallo`.
    "The following examples use a field symbol with generic type
    FIELD-SYMBOLS <fs> TYPE data.

    ASSIGN ('IT') TO <fs>.
    ASSIGN ('SRUCTURE') TO <fs>.

    "Field symbol declared inline
    "Note: The typing is performed with the generic type data.
    ASSIGN ('DOBJ') TO FIELD-SYMBOL(<fs_inline>).

    "The statements set the sy-subrc value.
    ASSIGN ('DOES_NOT_EXIST') TO <fs>.
    IF sy-subrc <> 0.
      out->write( `Dynamic assignment not successful` ).
    ENDIF.

    "The memory area can also be a dereferenced data reference
    ASSIGN struc_ref->* TO <fs>.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Dynamic ASSIGN Statements (2) - Assigning Components Dynamically` ) ).

    "You can chain the names with the component selector (-), or, in
    "case of reference variables, the object component selector (->).
    ASSIGN structure-('COL1') TO <fs>.
    ASSIGN it[ 1 ]-('COL1') TO <fs>.
    ASSIGN struc_ref->('COL1') TO <fs>.
    "The following example uses the dereferencing operator explicitly
    "followed by the component selector.
    ASSIGN struc_ref->*-('COL1') TO <fs>.

    "Using a named data object for the component specification
    DATA columnname TYPE string VALUE `COL1`.
    ASSIGN structure-(columnname) TO <fs>.

    "Fully dynamic specification
    "If the compiler can fully determine the data object in ASSIGN structureatements
    "in ABAP for Cloud Development, a warning is not issued.
    ASSIGN ('STRUCTURE-COL1') TO <fs>.

    "Numeric expressions are possible. Its value is interpreted
    "as the position of the component in the structureructure.
    ASSIGN structure-(3) TO <fs>.

    "If the value is 0, the memory area of the entire structureructure is
    "assigned to the field symbol.
    ASSIGN structure-(0) TO <fs>.

    "The structureatements above replace the following, older structureatements.
    ASSIGN COMPONENT 'COL1' OF STRUCTURE structure TO <fs>.
    ASSIGN COMPONENT 3 OF STRUCTURE structure TO <fs>.

    "More examples
    SELECT SINGLE * FROM zdemo_abap_carr INTO @DATA(wa).
    "Reading into data reference variable
    SELECT SINGLE * FROM zdemo_abap_carr INTO NEW @DATA(ref_m).

    DATA(comp_name) = lcl_det_at_runtime=>get_dyn_field( ).

    ASSIGN wa-(comp_name) TO FIELD-SYMBOL(<fs_m6>).

    ASSIGN wa-('CARRNAME') TO FIELD-SYMBOL(<fs_m7>).

    IF sy-subrc = 0.
      DATA(subrc1) = sy-subrc.
    ENDIF.

    "No exception occurs in case of an unsuccessful assignment.
    ASSIGN wa-('CRRNM') TO FIELD-SYMBOL(<fs_m8>).

    IF sy-subrc <> 0.
      DATA(subrc2) = sy-subrc.
    ENDIF.

    "Numeric expressions are possible. Its value is interpreted as the position
    "of the component in the structure.
    ASSIGN wa-(4) TO FIELD-SYMBOL(<fs_m9>).

    "If the value is 0, the memory area of the entire structure is assigned to the field symbol.
    ASSIGN wa-(0) TO FIELD-SYMBOL(<fs_m10>).

    "Old syntax
    ASSIGN COMPONENT 'CARRID' OF STRUCTURE wa TO FIELD-SYMBOL(<fs_m11>).
    ASSIGN COMPONENT 5 OF STRUCTURE wa TO FIELD-SYMBOL(<fs_m12>).

    "Dynamically specifying components of structures that are referenced by
    "a data reference variable

    ASSIGN ref_m->('CARRNAME') TO FIELD-SYMBOL(<fs_m13>).

    out->write( data = <fs_m6> name = `<fs_m6>` ).
    out->write( |\n| ).
    out->write( data = <fs_m7> name = `<fs_m7>` ).
    out->write( |\n| ).
    out->write( data = subrc1 name = `subrc1` ).
    out->write( |\n| ).
    out->write( data = subrc2 name = `subrc2` ).
    out->write( |\n| ).
    out->write( data = <fs_m9> name = `<fs_m9>` ).
    out->write( |\n| ).
    out->write( data = <fs_m10> name = `<fs_m10>` ).
    out->write( |\n| ).
    out->write( data = <fs_m11> name = `<fs_m11>` ).
    out->write( |\n| ).
    out->write( data = <fs_m12> name = `<fs_m12>` ).
    out->write( |\n| ).
    out->write( data = <fs_m13> name = `<fs_m13>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Dynamic ASSIGN Statements (3) - Assigning Attributes of Classes or Interfaces Dynamically (1)` ) ).
    "The following syntax pattern shows the possible specifications.
    "... cref->(attr_name) ...  "object reference variable
    "... iref->(attr_name) ...  "interface reference variable
    "... (clif_name)=>(attr_name) ...  "class/interface name
    "... (clif_name)=>attr ...
    "... clif=>(attr_name) ...

    "Creating an instance of a class
    DATA(objref) = NEW zcl_demo_abap_objects( ).

    "Assigning instance attributes using an object reference variable
    "All visible attributes of objects can be assigned.
    objref->string = `ABAP`. "Assigning a value to the attribute for demo purposes
    ASSIGN objref->('STRING') TO <fs>.

    "Assigning instance attributes using an interface reference variable
    DATA intref TYPE REF TO zdemo_abap_objects_interface.
    intref = objref.
    ASSIGN intref->('STRING') TO <fs>.
    intref->in_str = `hallo`.
    ASSIGN intref->('IN_STR') TO <fs>.

    "Assigning static attributes
    "All visible static attributes in classes and interfaces can be assigned
    "In the following example, a class and an interface are specified statically,
    "and the attributes are specified dynamically.
    ASSIGN zcl_demo_abap_objects=>('PUBLIC_STRING') TO <fs>.
    ASSIGN zdemo_abap_objects_interface=>('CONST_INTF') TO <fs>.

    "Specifying a class or interface dynamically, and attributes statically
    ASSIGN ('ZCL_DEMO_ABAP_OBJECTS')=>public_string TO <fs>.
    ASSIGN ('ZDEMO_ABAP_OBJECTS_INTERFACE')=>const_intf TO <fs>.

    "Specifying a class or interface as well as attributes dynamically
    ASSIGN ('ZCL_DEMO_ABAP_OBJECTS')=>('PUBLIC_STRING') TO <fs>.
    ASSIGN ('ZDEMO_ABAP_OBJECTS_INTERFACE')=>('CONST_INTF') TO <fs>.

    "Further dynamic syntax options are possible, for example,
    "specifying the memory area after ASSIGN with a writable expression
    "because the operand position after ASSIGN is a result position.
    ASSIGN NEW zcl_demo_abap_objects( )->('PUBLIC_STRING') TO <fs>.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) Dynamic ASSIGN Statements (4) - Assigning Attributes of Classes or Interfaces Dynamically (2)` ) ).

    "The following examples demonstrate a selection of various dynamic specifications
    "that are possible with ASSIGN statements.

    "Dynamic specification of attributes of classes/interfaces that are assigned to a field symbol.
    DATA(dobj_name) = lcl_det_at_runtime=>get_dyn_dobj( ).

    ASSIGN lcl_det_at_runtime=>(dobj_name) TO FIELD-SYMBOL(<fs_m1>).

    out->write( |Data object name determined at runtime: { dobj_name } | ).
    out->write( |\n| ).
    out->write( |The content of the data object is: { <fs_m1> } | ).
    out->write( |\n| ).
    out->write( |\n| ).

    dobj_name = lcl_det_at_runtime=>get_dyn_dobj( ).

    "Completely dynamic assign
    ASSIGN ('lcl_det_at_runtime')=>(dobj_name) TO FIELD-SYMBOL(<fs_m2>).
    out->write( data = <fs_m2> name = `<fs_m2>` ).
    out->write( |\n| ).

    ASSIGN ('zdemo_abap_objects_interface')=>('const_intf') TO FIELD-SYMBOL(<fs_m3>).
    out->write( data = <fs_m3> name = `<fs_m3>` ).
    out->write( |\n| ).

    "Class/interface reference variables pointing to an object that contains attributes
    "and that are specified dynamically.
    DATA iref TYPE REF TO zdemo_abap_objects_interface.
    DATA(cl_ref) = NEW zcl_demo_abap_objects( ).
    iref = cl_ref.

    ASSIGN iref->('const_intf') TO FIELD-SYMBOL(<fs_m4>).

    out->write( data = <fs_m4> name = `<fs_m4>` ).
    out->write( |\n| ).

    ASSIGN cl_ref->('another_string') TO FIELD-SYMBOL(<fs_m5>).

    out->write( data = <fs_m5> name = `<fs_m5>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) Dynamic ASSIGN Statements (5) - Setting sy-subrc/ELSE UNASSIGN Addition` ) ).

    "In dynamic assignments, the statement ASSIGN sets the return code sy-subrc.
    "If ELSE UNASSIGN is specified, no memory area is assigned to the field symbol. It has the state unassigned after the ASSIGN statement.

    DATA(attr) = VALUE string_table( ( `another_string` ) ( `public_string` ) ( `this_will_fail` ) ).

    LOOP AT attr INTO DATA(attribute).

      ASSIGN cl_ref->(attribute) TO FIELD-SYMBOL(<attr>) ELSE UNASSIGN.
      IF sy-subrc = 0.
        out->write( |Successful assignment for attribute "{ attribute }". sy-subrc = { sy-subrc }. | ).
        out->write( |\n| ).
        out->write( data = <attr> name = `<attr>` ).
      ELSE.
        out->write( |Assignment not successful for attribute "{ attribute }". sy-subrc = { sy-subrc }. | ).
      ENDIF.

      out->write( |\n| ).

      IF <attr> IS ASSIGNED.
        out->write( `The field symbol is assigned.` ).
        out->write( `--------------------` ).
      ELSE.
        out->write( `The field symbol is not assigned.` ).
      ENDIF.

      out->write( |\n| ).

    ENDLOOP.

    "Note: For the static variant of the ASSIGN statement, i.e. if the memory area
    "to be assigned following the ASSIGN keyword is statically specified, the addition
    "ELSE UNASSIGN is implicitly set and cannot be used explicitly.
    DATA(hallo) = `Hallo world`.
    ASSIGN ('HALLO') TO FIELD-SYMBOL(<eu>) ELSE UNASSIGN.
    ASSERT sy-subrc = 0 AND <eu> IS ASSIGNED.
    ASSIGN ('DOES_NOT_EXIST') TO <eu> ELSE UNASSIGN.
    ASSERT sy-subrc = 4 AND <eu> IS NOT ASSIGNED.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26a) Dynamic ASSIGN Statements (6) - Type Casting` ) ).

    "As covered above, the CASTING addition of the ASSIGN statement
    "has dynamic syntax elements.
    DATA dobj_c_l5 TYPE c LENGTH 5 VALUE 'abcde'.
    TYPES dtype_c_l2 TYPE c LENGTH 2.
    FIELD-SYMBOLS <fs_dyn_as> TYPE data.

    "A text literal with the name of a type is specified within the parentheses.
    ASSIGN dobj_c_l5 TO <fs_dyn_as> CASTING TYPE ('DTYPE_C_L2').

    out->write( data = <fs_dyn_as> name = `<fs_dyn_as1>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26b) Dynamic ASSIGN Statements (7) - Type Casting` ) ).

    "Assigning a data object to a field symbol casting a dynamically
    "specified type as also shown in the example above
    TYPES clen5 TYPE c LENGTH 5.
    DATA: dobj_c10    TYPE c LENGTH 10 VALUE '1234567890',
          some_struct TYPE zdemo_abap_fli.
    FIELD-SYMBOLS <casttype> TYPE data.

    ASSIGN dobj_c10 TO <casttype> CASTING TYPE ('CLEN5').  "12345
    ASSIGN dobj_c10 TO <casttype> CASTING LIKE some_struct-('CARRID'). "123

    TYPES: c1  TYPE c LENGTH 1,
           c3  TYPE c LENGTH 3,
           c10 TYPE c LENGTH 10,
           c20 TYPE c LENGTH 20,
           str TYPE string.
    DATA abc TYPE c LENGTH 26 VALUE 'abcdefghijklmnopqrstuvwxyz'.
    DATA(typenames) = VALUE string_table( ( `C1` ) ( `C3` ) ( `C10` ) ( `C20` ) ( `NOPE` ) ( `STR` ) ).
    DATA assignment_results TYPE string_table.
    FIELD-SYMBOLS <c_like> TYPE clike.

    LOOP AT typenames INTO DATA(typename).
      TRY.
          ASSIGN abc TO <c_like> CASTING TYPE (typename).
          assignment_results = VALUE #( BASE assignment_results ( |Type: '{ typename }'; Assignment result: '{ <c_like> }'| ) ).
        CATCH cx_root INTO DATA(error).
          assignment_results = VALUE #( BASE assignment_results
          ( |Error! Exception raised: { cl_abap_typedescr=>describe_by_object_ref( error )->get_relative_name( ) }; | &&
            |'{ error->get_text( ) }'| ) ).
      ENDTRY.
    ENDLOOP.

    out->write( data = assignment_results name = `assignment_results` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26c) Dynamic ASSIGN Statements (8) - Type Casting` ) ).

    "Note: As covered further down CREATE DATA and ASSIGN statements have the HANDLE addition
    "after which dynamically created types can be specified. A type description object is expected.

    "Getting type description object
    DATA(tdo_elem) = cl_abap_elemdescr=>get_c( 4 ).
    ASSIGN dobj_c10 TO <casttype> CASTING TYPE HANDLE tdo_elem.

    out->write( data = <casttype> name = `<casttype>` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `27) Accessing Structure Components Dynamically (1)` ) ).

    "You can achieve the access using ASSIGN statements as shown above, or
    "by statically specifying the structure and the (object) component selector
    "followed by a character-like data object in parentheses.
    "Write position
    structure-('COL1') = 123.
    it[ 1 ]-('COL1') = 456.
    struc_ref->('COL1') = 789.

    "Read position
    "The example shows how you can retrieve the textual content of any component
    "of any structure.
    DATA(content_col2) = CONV string( structure-('COL1') ).
    DATA(content_col3) = |{ structure-('COL3') }|.
    DATA content_col1 LIKE structure-col1.
    content_col1 = structure-('COL1').

    DATA dref_comp TYPE REF TO data.
    CREATE DATA dref_comp LIKE structure-('COL3').
    dref_comp->* = structure-('COL3').

    "If the component is not found, a catchable exception is raised.
    TRY.
        DATA(col_not_existent) = |{ structure-('COL123') }|.
      CATCH cx_sy_assign_illegal_component INTO DATA(error_column).
        out->write( error_column->get_text( ) ).
    ENDTRY.

    "Accessing components of generic structures dynamically,
    "e.g. if you have a method parameter that is typed with the generic type
    "data.
    "The example uses a field symbol with the generic type data which is assigned
    "a structure.
    FIELD-SYMBOLS <gen> TYPE data.
    ASSIGN structure TO <gen>.

    "As in the examples above, specifying components dynamically is possible.
    <gen>-('COL2') = `ABAP`.
    DATA(gen_comp) = CONV string( <gen>-('COL2') ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `28) Accessing Structure Components Dynamically (2) - Excursion` ) ).

    "In the following example, a structure is assigned to a field symbol that
    "has a generic type. The components of the structure are accessed dynamically in
    "a DO loop. The sy-index value is interpreted as the position of the component
    "in the structure. Plus, using RTTI - as also shown further down - the component
    "names are retrieved. Component names and the values are added to a string. As a
    "prerequisite, all component values must be convertible to type string.
    DATA struc2string TYPE string.
    FIELD-SYMBOLS <strco> TYPE data.
    ASSIGN structure TO <strco>.
    IF sy-subrc = 0.
      TRY.
          DATA(components) = CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( <strco> ) )->components.
          DO.
            TRY.
                DATA(co) = components[ sy-index ]-name.
                struc2string = struc2string &&
                               COND #( WHEN sy-index <> 1 THEN `, ` ) &&
                               co && `: "` &&
                               <strco>-(sy-index) && `"`.
              CATCH cx_sy_assign_illegal_component cx_sy_itab_line_not_found.
                EXIT.
            ENDTRY.
          ENDDO.
        CATCH cx_sy_move_cast_error.
      ENDTRY.
    ENDIF.

    out->write( data = struc2string name = `struc2string` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Dynamically Creating Data Objects at Runtime Using Dynamic Type Definitions` ) ).
    out->write( |29) Miscellaneous Data Objects (1)\n\n| ).

    "In an example above, anonymous data objects are created using static
    "type definitions. In this example, anonymous data objects are created
    "using a type determined at runtime.
    "The values of an internal table of type string represent type names.
    "The type name is used for the dynamic type specification in CREATE
    "DATA statements that use various additions. The following is
    "created dynamically: elementary data object, structure, internal
    "table, data reference. For output purposes, the newly created data
    "objects are assigned values.
    "Note:
    "- The NEW operator cannot be used here.
    "- The creation of a data object based on a type description object is shown
    "  below (TYPE HANDLE addition).
    "- Dynamic type specifications for ASSIGN statements together with the
    "  CASTING addition are shown above.

    DATA(type_names) = VALUE string_table( ( `I` )
                                           ( `STRING` )
                                           ( `ZDEMO_ABAP_CARR` ) ).

    DATA dataref TYPE REF TO data.
    DATA some_str TYPE string VALUE `some string`.
    DATA some_structure TYPE zdemo_abap_carr.

    LOOP AT type_names REFERENCE INTO DATA(refwa).
      out->write( |***** Loop iteration { sy-tabix }. Type: { refwa->* } *****| ).

      CASE refwa->*.
        WHEN `I`.
          CREATE DATA dataref TYPE (refwa->*).
          dataref->* = 123.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).

          CREATE DATA dataref TYPE TABLE OF (refwa->*).

          INSERT 1 INTO TABLE dataref->*.
          INSERT 2 INTO TABLE dataref->*.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).

          CREATE DATA dataref TYPE REF TO (refwa->*).
          dataref->* = REF i( 456 ).

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).
        WHEN `STRING`.
          CREATE DATA dataref TYPE (refwa->*).
          dataref->* = `hello`.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).

          CREATE DATA dataref TYPE TABLE OF (refwa->*).
          INSERT `hello` INTO TABLE dataref->*.
          INSERT `abap` INTO TABLE dataref->*.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).

          CREATE DATA dataref TYPE REF TO (refwa->*).
          dataref->* = REF string( `hi` ).

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).
        WHEN `ZDEMO_ABAP_CARR`.
          CREATE DATA dataref TYPE (refwa->*).
          SELECT SINGLE * FROM zdemo_abap_carr INTO @dataref->*.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).

          CREATE DATA dataref TYPE TABLE OF (refwa->*).
          SELECT * FROM zdemo_abap_carr INTO TABLE @dataref->* UP TO 3 ROWS.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).

          CREATE DATA dataref TYPE REF TO (refwa->*).
          SELECT SINGLE * FROM zdemo_abap_carr INTO NEW @dataref->*.

          out->write( data = dataref->* name = `dataref->*` ).
          out->write( |\n| ).
      ENDCASE.
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `30) Elementary Data Object (2)` ) ).

    "The example demonstrates the following:
    "- The method call takes care of providing the name of a built-in data type and more
    "- An elementary data object is created based on the data type
    "- For demonstration purposes, RTTI (as shown further down in more detail) is used
    "  to check on the created data object by retrieving the type description.

    DATA(b_type) = lcl_det_at_runtime=>get_builtin_type( ).

    DATA ref_bt TYPE REF TO data.

    TRY.
        CASE b_type-builtin_type.
          WHEN 'd' OR 'decfloat16' OR 'decfloat34' OR 'f' OR 'i'
                   OR 'string' OR 't' OR 'xstring'.

            CREATE DATA ref_bt TYPE (b_type-builtin_type).
          WHEN 'c' OR 'n' OR 'x'.
            CREATE DATA ref_bt TYPE (b_type-builtin_type) LENGTH b_type-len.
          WHEN 'p'.
            CREATE DATA ref_bt TYPE p LENGTH b_type-len DECIMALS b_type-dec.
          WHEN OTHERS.
            out->write( `That didn't work.` ).
        ENDCASE.

        "Getting type information using RTTI
        DATA(descr_builtin_type) = CAST cl_abap_elemdescr(
          cl_abap_typedescr=>describe_by_data( ref_bt->* ) ).

        out->write( |Built-in type determined at runtime: { b_type-builtin_type } | ).
        out->write( |\n| ).
        out->write( `Type information of created data object at runtime:` ).
        out->write( |\n| ).
        out->write( |\n| ).
        out->write( data = descr_builtin_type name = `descr_builtin_type` ).

      CATCH cx_root.
        out->write( `Something went wrong.` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `31) Structure (3)` ) ).

    "The example demonstrates the following:
    "- The method call takes care of providing the name of a database table name.
    "- A structured data object is created based on the dynamically determined type.
    "  It is used as target data object for a SELECT statement. As shown further
    "  down in more detail, clauses of SELECT statements can be specified
    "  dynamically.

    "Retrieving table name
    DATA(type4struc) = lcl_det_at_runtime=>get_dyn_table_name( ).

    DATA ref_dynstruc TYPE REF TO data.

    "Creating structured data object
    CREATE DATA ref_dynstruc TYPE (type4struc).

    "Dynamic specification of the FROM clause
    SELECT SINGLE *
         FROM (type4struc)
         INTO @ref_dynstruc->*.

    out->write( |Structured data type/database table name determined at runtime: { type4struc } | ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = ref_dynstruc->* name = `ref_dynstruc->*`  ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32a) Internal Table (4)` ) ).

    "The example demonstrates the following:
    "- The method call takes care of providing the name of a database table name.
    "- An internal table is created based on the dynamically determined type.
    "  It is used as target data object for a SELECT statement.
    "- The UP TO ... ROWS addition is provided with a random number in the example.
    "- AS in the example above, the SELECT statement includes the dynamic
    "  specification of the FROM clause.

    "Retrieving table name
    DATA(type_name) = lcl_det_at_runtime=>get_dyn_table_name( ).

    DATA ref_n TYPE REF TO data.

    "Creating internal table based on the type determined at runtime
    CREATE DATA ref_n TYPE TABLE OF (type_name).

    "Specifying random number for up to clause
    DATA(random_upto) = cl_abap_random_int=>create(
         seed = cl_abap_random=>seed( ) min = 2
                                        max = 6 )->get_next( ).

    "Dynamic specification of the FROM clause
    SELECT *
      FROM (type_name)
      INTO TABLE @ref_n->*
      UP TO @random_upto ROWS.

    out->write( |Table/type name determined at runtime: { type_name } | ).
    out->write( |\n| ).
    out->write( |At most, { random_upto } lines should have been read from the database table.| ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = ref_n->* name = `ref_n->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32b) Creating Anonymous Data Objects by Specifying the Type Dynamically (Summarizing Syntax Patterns)` ) ).

    "------------ Specifying a type name dynamically ------------

    "Anonymous data objects are created using a type determined at
    "runtime. In this case, the name of the data type is specified
    "dynamically.
    "Note that the NEW operator cannot be used here.

    "Data reference variable used for the examples
    DATA data_ref TYPE REF TO data.

    "Example types and data objects

    "Elementary type and data object
    TYPES t_c3 TYPE c LENGTH 3.
    DATA c3 TYPE c LENGTH 3.

    "Structured type and data object
    TYPES t_fli_struc TYPE zdemo_abap_fli.
    DATA  fli_struc TYPE zdemo_abap_fli.

    "Table type and internal table
    TYPES t_carr_tab TYPE SORTED TABLE OF zdemo_abap_carr WITH UNIQUE KEY carrid.
    DATA carr_tab TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.

    "Reference type and data reference variable
    TYPES t_str_ref TYPE REF TO string.
    DATA str_ref TYPE REF TO string.

    "----- Pattern: TYPE (typename) ... -----

    "Creating an elementary data object
    "Specifying a literal for the dynamic type name (used in most of the
    "following examples)
    CREATE DATA data_ref TYPE ('T_C3').

    "Specifying a named data object
    DATA(c3_type) = 'T_C3'.
    CREATE DATA data_ref TYPE (c3_type).

    "Structured data object
    CREATE DATA data_ref TYPE ('T_FLI_STRUC').

    "Internal table
    CREATE DATA data_ref TYPE ('T_CARR_TAB').

    "Data reference
    CREATE DATA data_ref TYPE ('T_STR_REF').

    "----- Pattern: TYPE ... TABLE OF (typename) ... -----

    "Creating internal tables

    CREATE DATA data_ref TYPE TABLE OF ('STRING').
    CREATE DATA data_ref TYPE TABLE OF ('T_FLI_STRUC') WITH EMPTY KEY.

    "Specifying the structured type dynamically, but the key values statically
    CREATE DATA data_ref TYPE SORTED TABLE OF ('ZDEMO_ABAP_CARR') WITH UNIQUE KEY carrid.

    "Specifying the structured type and the key values dynamically
    "An internal table such as the following should be created by dynamically
    "specifying the type and keys dynamically. The keys are specified in lines
    "of an internal table with character-like line type.
    DATA itab_compare TYPE SORTED TABLE OF zdemo_abap_fli WITH UNIQUE KEY carrid connid fldate.

    DATA(key_table) = VALUE string_table( ( `CARRID` ) ( `CONNID` ) ( `FLDATE` ) ).
    CREATE DATA data_ref TYPE SORTED TABLE OF ('ZDEMO_ABAP_FLI') WITH UNIQUE KEY (key_table).

    "----- Pattern: TYPE REF TO (typename) -----

    "Creating data reference variables

    CREATE DATA data_ref TYPE REF TO ('STRING').
    CREATE DATA data_ref TYPE REF TO ('T_C3').
    CREATE DATA data_ref TYPE REF TO ('T_FLI_STRUC').
    CREATE DATA data_ref TYPE REF TO ('T_CARR_TAB').

    "----- Pattern: TYPE LINE OF (typename) -----

    "Creating structures based on table types
    CREATE DATA data_ref TYPE LINE OF ('T_CARR_TAB').

    "----- Pattern: LIKE struc-(dobjname) -----

    CREATE DATA data_ref LIKE fli_struc-('CARRID').

    "----- Pattern: TYPE (absolute_name) -----

    CREATE DATA data_ref TYPE ('\TYPE=STRING').
    "Getting an absolute type name; see more information further down
    DATA(absolute_name) = cl_abap_typedescr=>describe_by_name( 'ZDEMO_ABAP_CARR' )->absolute_name.
    CREATE DATA data_ref TYPE (absolute_name).

    "----- Pattern: TYPE HANDLE type_description_object -----

    "Getting a type description object. Find more information about RTTI below.
    DATA(typedescrobj) = cl_abap_elemdescr=>get_c( 4 ). "type c length 4
    CREATE DATA data_ref TYPE HANDLE typedescrobj.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33a) Creating Instances of Classes by Specifying the Type Dynamically` ) ).

    DATA oref_dyn TYPE REF TO object.
    CREATE OBJECT oref_dyn TYPE ('ZCL_DEMO_ABAP_OBJECTS').

    DATA cl TYPE string VALUE `ZCL_DEMO_ABAP_OBJECTS`.
    CREATE OBJECT oref_dyn TYPE (cl).

    "Specifying a wrong/non-existent type name
    TRY.
        CREATE OBJECT oref_dyn TYPE ('THIS_CLASS_DOES_NOT_EXIST').
      CATCH cx_sy_create_object_error.
    ENDTRY.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33b) Absolute Type Names for Dynamically Specifying Types` ) ).

    "In addition to character-like data objects for the type name specified within the
    "parentheses, you can also use absolute type names for statements such as CREATE DATA.
    "The absolute type name is retrieved using RTTI. See more on RTTI further down.

    "Type to refer to
    TYPES type4abs TYPE p LENGTH 4 DECIMALS 3.
    "Data and object reference variables
    DATA dref4abs TYPE REF TO data.
    DATA oref4abs TYPE REF TO object.
    "Getting absolute names using RTTI
    DATA(abs_name_type) = cl_abap_typedescr=>describe_by_name( 'TYPE4ABS' )->absolute_name.
    DATA(abs_name_cl) = cl_abap_typedescr=>describe_by_name( 'ZCL_DEMO_ABAP_DYNAMIC_PROG' )->absolute_name.

    "Data references
    ""Named data object holding the absolute name
    CREATE DATA dref4abs TYPE (abs_name_type).
    "Unnamed data object
    CREATE DATA dref4abs TYPE ('\TYPE=STRING').

    "Object references
    "Named data object
    CREATE OBJECT oref4abs TYPE (abs_name_cl).
    "Unnamed data object
    CREATE OBJECT oref4abs TYPE ('\CLASS=ZCL_DEMO_ABAP_DYNAMIC_PROG').

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Dynamically Specifying Components/Clauses in Statements for Processing Internal Tables with ...` ) ).
    out->write( |34a) SORT (1)\n\n| ).

    "A field is determined at runtime on whose basis a sorting is done on an
    "internal table.

    DATA(field_name) = lcl_det_at_runtime=>get_dyn_field( ).

    SELECT *
     FROM zdemo_abap_carr
     ORDER BY carrid
     INTO TABLE @DATA(carr_itab)
     UP TO 3 ROWS.

    SORT carr_itab BY (field_name).

    out->write(  |Field name determined at runtime | &&
    |by which the sorting was done: { field_name } | ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = carr_itab name = `carr_itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `34b) SORT (2)` ) ).


    "Sorting by dynamically specified components in a sort table, i. e.an
    "internal table of type abap_sortorder_tab.
    "Notes:
    "- Each line of this sort table specifies a component of the sort key.
    "- If this table is init_sortial, there is no sorting.
    "- The sort priorit_sorty is based on the order of the lines in the sort table.

    TYPES: BEGIN OF struct,
             comp1 TYPE i,
             comp2 TYPE string,
             comp3 TYPE c LENGTH 3,
           END OF struct.

    DATA it_sort TYPE TABLE OF struct WITH EMPTY KEY.

    it_sort = VALUE #( ( comp1 = 1 comp2 = `B` comp3 = 'a' )
                  ( comp1 = 1 comp2 = `A` comp3 = 'b' )
                  ( comp1 = 2 comp2 = `D` comp3 = 'c' )
                  ( comp1 = 2 comp2 = `C` comp3 = 'd' )
                  ( comp1 = 3 comp2 = `F` comp3 = 'e' )
                  ( comp1 = 3 comp2 = `E` comp3 = 'f' ) ).

    DATA(it_sort_original) = it_sort.

    "Note: The line type is abap_sortorder.
    DATA(sort) = VALUE abap_sortorder_tab( ).

    "No sorting because the sort table is init_sortial.
    SORT it_sort BY (sort).

    out->write( data = it_sort name = `it_sort` ).
    out->write( |\n| ).

    it_sort = it_sort_original.
    "Note: Ascending is the default sort order. The following example flags
    "the descending sort order explicit_sortly.
    sort = VALUE abap_sortorder_tab( ( name = `COMP1` descending = 'X' ) ).
    SORT it_sort BY (sort).

    out->write( data = it_sort name = `it_sort` ).
    out->write( |\n| ).

    it_sort = it_sort_original.

    sort = VALUE abap_sortorder_tab( ( name = `COMP1` descending = '' )
                                      ( name = `COMP2` descending = 'X' ) ).
    SORT it_sort BY (sort).

    out->write( data = it_sort name = `it_sort` ).
    out->write( |\n| ).

    it_sort = it_sort_original.

    "Sort priorit_sorty based on the order of lines in the sort table
    "In this example, the values of comp3 are set up so that a clear
    "sort order is determined. Since the component is specified first in the
    "sort table, this sorting has priorit_sorty. Note the values of comp2 in the
    "result table.
    sort = VALUE abap_sortorder_tab( ( name = `COMP3` descending = 'X' )
                                      ( name = `COMP2` descending = 'X' ) ).
    SORT it_sort BY (sort).

    out->write( data = it_sort name = `it_sort` ).
    out->write( |\n| ).

    "Specifying an invalid component name raises an exception
    sort = VALUE abap_sortorder_tab( ( name = `XYZ` descending = 'X' ) ).

    TRY.
        SORT it_sort BY (sort).
      CATCH cx_sy_dyn_table_ill_comp_val INTO DATA(err).
    ENDTRY.
    ASSERT err IS NOT INITIAL.

    it_sort = it_sort_original.
    "Specifying an expression/functional method call whose result is a sort
    "table of type abap_sortorder_tab
    "In this case, BY is followed by the expression/functional method call,
    "not enclosed in parentheses.

    "The example shows expressions wit_sorth sort tables created inline
    SORT it_sort BY VALUE abap_sortorder_tab( ( name = `COMP1` descending = 'X' ) ).

    out->write( data = it_sort name = `it_sort` ).
    out->write( |\n| ).

    it_sort = it_sort_original.

    DATA(compnames) = VALUE string_table( ( `comp1` ) ( `comp2` ) ).

    SORT it_sort BY VALUE abap_sortorder_tab( FOR sortwa IN compnames ( name = condense( to_upper( sortwa ) ) ) ).

    out->write( data = it_sort name = `it_sort` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `35) READ TABLE (1)` ) ).

    "Dynamic key specification in READ TABLE statements

    TYPES: BEGIN OF s,
             comp  TYPE string,
             value TYPE string,
           END OF s.

    TYPES comps_type TYPE TABLE OF s WITH EMPTY KEY.

    "Providing components and values for READ TABLE statement
    DATA(comps) = VALUE comps_type( ( comp = `CARRID` value = `LH` )
                                    ( comp = `CONNID` value = `0555` )
                                    ( comp = `SEATSOCC` value = `115` )
                                    ( comp = `CARRID` value = `XY` ) ). "not found

    SELECT *
      FROM zdemo_abap_fli
      INTO TABLE @DATA(itab_read_tab_dyn).

    LOOP AT comps INTO DATA(wa_comps).
      READ TABLE itab_read_tab_dyn
        INTO DATA(read_line)
        WITH KEY (wa_comps-comp) = wa_comps-value.

      IF sy-subrc = 0.
        out->write( data = wa_comps-comp name = `wa_comps-comp` ).
        out->write( |\n| ).
        out->write( data = wa_comps-value name = `wa_comps-value` ).
        out->write( |\n| ).
        out->write( data = read_line name = `read_line` ).
        out->write( |\n| ).
        CLEAR read_line.
      ELSE.
        out->write( data = wa_comps-comp name = `wa_comps-comp` ).
        out->write( |\n| ).
        out->write( data = wa_comps-value name = `wa_comps-value` ).
        out->write( |\n| ).
        out->write( `Line not found.` ).
        out->write( |\n| ).
      ENDIF.

    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `36) READ TABLE (2)` ) ).

    "Data objects and types to work with
    TYPES: BEGIN OF demo_struct,
             col1 TYPE i,
             col2 TYPE string,
             col3 TYPE string,
           END OF demo_struct.
    "Standard table and specification of primary and secondary table key
    DATA itab TYPE TABLE OF demo_struct
      WITH NON-UNIQUE KEY col1
      WITH UNIQUE SORTED KEY sk COMPONENTS col2.
    TYPES itab_type LIKE itab.
    DATA itab_ref TYPE TABLE OF REF TO demo_struct WITH EMPTY KEY.
    itab = VALUE #( ( col1 = 1 col2 = `aaa` col3 = `zzz` )
                    ( col1 = 2 col2 = `bbb` col3 = `yyy` )
                    ( col1 = 3 col2 = `ccc` col3 = `xxx` ) ).
    itab_ref = VALUE #( ( NEW demo_struct( col1 = 1 col2 = `aaa` col3 = `zzz` ) ) ).

    "Notes
    "- In statements using key specifications, secondary table key names (or alias names)
    "  are usually specified. Also the primary table key using the predefined name
    "  primary_key or its alias name can be used.
    "- Many of the following statements provide similar additions offering dynamic
    "  specifications, such as USING KEY and dynamic component name specifications.

    "Reading by specifying keys dynamically
    "Implicitly specifying the table key values in a work area (USING KEY addition)
    DATA(wa_read) = VALUE demo_struct( col2 = `aaa` ).
    READ TABLE itab FROM wa_read USING KEY ('SK') REFERENCE INTO DATA(read_ref).

    "Explicitly specifying the key and key values (TABLE KEY addition)
    "The component names can also be specified dynamically (which is done in most of the
    "following examples for demonstration purposes). Note that each component of the table
    "key must be specified.
    READ TABLE itab WITH TABLE KEY ('SK') COMPONENTS ('COL2') = `aaa` REFERENCE INTO read_ref.
    "Specifying the predefined name primary_key explicitly and dynamically
    READ TABLE itab WITH TABLE KEY ('PRIMARY_KEY') COMPONENTS ('COL1') = 1 REFERENCE INTO read_ref.
    "If the addition COMPONENTS is not specified, the primary table key is implicitly used.
    READ TABLE itab WITH TABLE KEY ('COL1') = 1 REFERENCE INTO read_ref.

    "Reading using a free key (WITH KEY addition)
    READ TABLE itab WITH KEY ('COL3') = `yyy` REFERENCE INTO read_ref.
    "The addition can also be used by specifying a secondary table key name
    READ TABLE itab WITH KEY ('SK') COMPONENTS ('COL2') = `ccc` REFERENCE INTO read_ref.

    "Reading based on a table index (INDEX addition)
    "Not using the addition USING KEY means reading from the primary table index.
    READ TABLE itab INDEX 1 USING KEY ('SK') REFERENCE INTO read_ref.

    "More dynamic specification options when specifying the target as work area
    "(COMPARING/TRANSPORTING additions)
    "TRANSPORTING: Specifying which components shall be respected
    READ TABLE itab INDEX 1 INTO DATA(workarea) TRANSPORTING ('COL1') ('COL3').

    "COMPARING: If the content of the compared components is identical, sy-subrc is set
    "to 0, and otherwise to 2. The line found is assigned to the work area independently
    "of the result of the comparison.
    workarea-('COL3') = `uvw`.
    READ TABLE itab INDEX 1 INTO workarea COMPARING ('COL3') TRANSPORTING ('COL1') ('COL3').
    IF sy-subrc <> 0.
      ...
    ENDIF.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `37) Table Expressions` ) ).

    "Similar to READ TABLE statements, you can specify table lines with 3 alternatives:
    "index read, read using free key, table key
    "Also there, dynamic specifications are possible regarding the key specifications.

    "Reading based on index with dynamic key specifications
    "Specifying the secondary table index of a sorted secondary key
    DATA(wa_te1) = itab[ KEY ('SK') INDEX 1 ].
    "Reading using a free key, the keys are specified dynamically
    DATA(wa_te2) = itab[ ('COL2') = `bbb` ('COL3') = `yyy` ].

    "Reading using a table key
    "Specyfing the table key explicitly
    "Note: Unlike READ TABLE statements, the name of the table key must be specified. The
    "addition COMPONENTS can be omitted.
    "In the following example, the component names are also specified dynamically.
    DATA(wa_te3) = itab[ KEY ('SK') ('COL2') = `ccc` ].
    "Specifying the COMPONENTS addition explicitly
    DATA(wa_te4) = itab[ KEY ('PRIMARY_KEY') COMPONENTS ('COL1') = 1 ].

    "Accessing components
    "As shown above, chaininings with the (object) component selector are possible.
    "The examples use index access and write positions.
    itab[ 1 ]-('COL2') = `jkl`.
    itab_ref[ 1 ]->('COL2') = `mno`.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `38) LOOP (1)` ) ).

    "Dynamic specification of the key in LOOP statements
    "In the example, the loop can be executed with the entries 'SKEY' and 'PRIMARY_KEY'.
    "This is not case sensitive. Any other entries produce a runtime error.

    DATA(keys) = VALUE string_table( ( `PRIMARY_KEY` ) ( `SKEY` ) ).

    DATA itab_loop TYPE TABLE OF i
              WITH NON-UNIQUE KEY primary_key COMPONENTS table_line
              WITH NON-UNIQUE SORTED KEY skey COMPONENTS table_line.

    itab_loop = VALUE #( ( 3 ) ( 2 ) ( 1 ) ).

    DATA itab_dyn_key LIKE itab_loop.

    LOOP AT keys INTO DATA(k).

      LOOP AT itab_loop INTO DATA(wa_lo) USING KEY (k).
        APPEND wa_lo TO itab_dyn_key.
      ENDLOOP.

      out->write( |Loop over internal table using key "{ k }".| ).
      out->write( |\n| ).
      out->write( data = itab_dyn_key name = `itab_dyn_key` ).
      out->write( |\n| ).
      CLEAR itab_dyn_key.

    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `39) LOOP (2)` ) ).

    "USING KEY addition: Overriding the standard order determined by the table category
    LOOP AT itab REFERENCE INTO DATA(ref) USING KEY ('SK').
      ...
    ENDLOOP.

    "When the primary table key is specified, the loop behaves as if it was not specified.
    "So, the following statement corresponds to the one below.
    LOOP AT itab REFERENCE INTO ref USING KEY ('PRIMARY_KEY').
      ...
    ENDLOOP.

    LOOP AT itab REFERENCE INTO ref.
      ...
    ENDLOOP.

    "Dynamic WHERE condition
    "You can specify a character-like data object or a standard table with character-like
    "line type.
    DATA(cond_loop) = `COL1 > 1`.
    LOOP AT itab REFERENCE INTO ref WHERE (cond_loop).
      ...
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `40) INSERT` ) ).

    "The USING KEY addition (which accepts a dynamic specification) affects the order in which lines are inserted.

    "Result of the following example when using the ...
    "- secondary table key: order of itab entries 5 ... /4 ... /...
    "- primary table key: order of itab entries 4 ... /5 ... /...
    INSERT LINES OF VALUE itab_type( ( col1 = 4 col2 = `eee` col3 = `www` )
                                     ( col1 = 5 col2 = `ddd` col3 = `vvv` ) )
      USING KEY ('SK')
      "USING KEY ('PRIMARY_KEY')
      INTO itab INDEX 1.

    "Excursion: Using LOOP AT statements with the USING KEY addition
    "and exploring the table index
    "Declaring demo tables to hold the internal table entries
    DATA it_seckey_idx TYPE TABLE OF demo_struct WITH EMPTY KEY.
    DATA it_primekey_idx LIKE it_seckey_idx.

    "Visualizing the secondary table index
    LOOP AT itab INTO DATA(wa_sk) USING KEY ('SK').
      APPEND wa_sk TO it_seckey_idx.
    ENDLOOP.

    out->write( data = it_seckey_idx name = `it_seckey_idx` ).
    out->write( |\n| ).

    "Visualizing the primary table index
    LOOP AT itab INTO DATA(wa_pk) USING KEY ('PRIMARY_KEY').
      APPEND wa_pk TO it_primekey_idx.
    ENDLOOP.

    out->write( data = it_primekey_idx name = `it_primekey_idx` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `41) MODIFY (1)` ) ).

    "Dynamic WHERE condition in MODIFY statements
    "Note:
    "- The addition WHERE can only be specified together with the addition TRANSPORTING.
    "- Invalid logical expressions raise an exception from the class CX_SY_ITAB_DYN_LOOP.

    TYPES:
      BEGIN OF line,
        col1 TYPE c LENGTH 1,
        col2 TYPE i,
      END OF line.

    DATA itab_mod_tab_dyn TYPE SORTED TABLE OF line
                   WITH UNIQUE KEY col1.

    itab_mod_tab_dyn = VALUE #( ( col1 = 'A' col2 = 1 )
                                ( col1 = 'B' col2 = 10 )
                                ( col1 = 'C' col2 = 100 ) ).

    out->write( `Internal table content before modifications:` ).
    out->write( |\n| ).
    out->write( data = itab_mod_tab_dyn name = `itab_mod_tab_dyn` ).
    out->write( |\n| ).

    "Providing conditions for MODIFY statement
    DATA(conditions) = VALUE string_table( ( `col2 < 5` )
                                           ( `col2 = 10` )
                                           ( `colxyz > 50` ) ). "to fail

    LOOP AT itab_mod_tab_dyn INTO DATA(wa_mod_dyn).
      TRY.

          DATA(condition) = conditions[ sy-tabix ].

          MODIFY itab_mod_tab_dyn
            FROM VALUE line( col2 = wa_mod_dyn-col2 * 2 )
            TRANSPORTING col2
            WHERE (condition).

        CATCH cx_sy_itab_dyn_loop.
          out->write( |Invalid WHERE condition "{ condition }".| ).
      ENDTRY.
    ENDLOOP.

    out->write( `Internal table content after modifications:` ).
    out->write( |\n| ).
    out->write( data = itab_mod_tab_dyn name = `itab_mod_tab_dyn` ).


**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `42) MODIFY (2)` ) ).

    "In the following example, a line is modified based on a work area and a table key.
    "The component col1 is left out from the work area intentionally.
    "If the primary table key was used, the value of sy-subrc would be 4, and no modification was done.
    "The optional addition transporting is specified to denote what should be modified. In this example,
    "the component is also specified dynamically.
    MODIFY TABLE itab FROM VALUE #( col2 = `bbb` col3 = `uuu` ) USING KEY ('SK') TRANSPORTING ('COL3').

    "In the following example, a line is modified based on a work area, an index specification and a
    "table key.
    "INDEX can also be positioned after FROM.
    MODIFY itab INDEX 2 USING KEY ('SK') FROM VALUE #( col3 = `ttt` ) TRANSPORTING ('COL3').

    "Dynamic WHERE clause (only to be used with the TRANSPORTING addition)
    "The USING KEY addition is also possible. Check the ABAP Keyword Documentation
    "for special rules that apply.
    DATA(cond_mod) = `COL1 < 3`.
    MODIFY itab FROM VALUE #( col3 = `sss` ) TRANSPORTING ('COL3') WHERE (cond_mod).

    out->write( data = itab name = `itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `43) DELETE (1)` ) ).

    "Dynamic WHERE condition in DELETE statements

    DATA itab_del_tab_dyn TYPE TABLE OF i WITH EMPTY KEY
                   WITH NON-UNIQUE SORTED KEY skey COMPONENTS table_line.

    itab_del_tab_dyn = VALUE #( ( 100 )
                                ( 200 )
                                ( 300 )
                                ( 400 )
                                ( 500 )
                                ( 600 ) ).

    out->write( `Internal table content before modifications:` ).
    out->write( |\n| ).
    out->write( data = itab_del_tab_dyn name = `itab_del_tab_dyn` ).
    out->write( |\n| ).

    DO 3 TIMES.
      TRY.

          CASE sy-index.
            WHEN 1.
              condition = `table_line <= 200`.
            WHEN 2.
              condition = `table_line >= 500`.
            WHEN 3.
              condition = `col1 = 600`.
          ENDCASE.

          DELETE itab_del_tab_dyn
            USING KEY skey
            WHERE (condition).

          out->write( |Condition: { condition }| ).
          out->write( |\n| ).
          out->write( data = itab_del_tab_dyn name = `itab_del_tab_dyn` ).
          out->write( |\n| ).
        CATCH cx_sy_itab_dyn_loop.
          out->write( |Invalid WHERE condition "{ condition }".| ).
          out->write( |\n| ).
      ENDTRY.
    ENDDO.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `44) DELETE (2)` ) ).

    "A single line or multipled lines can be deleted.
    "Note that DELETE ADJACENT DUPLICATES statements can also be specified using
    "dynamic parts.

    "Deleting based on a dynamically specified table key
    "The values can be declared either implicitly in a work area after FROM or explicitly
    "by listing the components of the table key after TABLE KEY.
    "If the USING KEY addition is not specified, the primary table key is used by default.
    DELETE TABLE itab FROM VALUE #( col2 = `eee` col3 = `www` ) USING KEY ('SK').

    "Each component of the table key must be listed.
    DELETE TABLE itab WITH TABLE KEY ('SK') COMPONENTS ('COL2') = `ddd`.

    "Deleting based on the table index
    DELETE itab INDEX 1 USING KEY ('SK').

    "Deleting multiple lines and specifying the WHERE conditions dynamically
    "The USING KEY addition is also possible.
    DATA(condition_tab) = VALUE string_table( ( `COL1 < 3` )
                                              ( `OR` )
                                              ( `COL3 = ``www``` ) ).
    DELETE itab WHERE (condition_tab).

    out->write( data = itab name = `itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Dynamically Specifying Clauses in ABAP SQL SELECT Statements` ) ).
    out->write( |45) SELECT List\n\n| ).

    "In the example, the SELECT list that is used in a SELECT statement is
    "determined at runtime.
    "Note: Check out the CL_ABAP_DYN_PRG class, which supports dynamic programming by
    "checking the validity of dynamic specifications. See an example below.

    DATA(select_list) = lcl_det_at_runtime=>get_dyn_select_list( ).

    DATA sel_table TYPE TABLE OF zdemo_abap_flsch WITH EMPTY KEY.

    SELECT (select_list)
     FROM zdemo_abap_flsch
     ORDER BY carrid
     INTO CORRESPONDING FIELDS OF TABLE @sel_table
     UP TO 3 ROWS.

    out->write( |SELECT list determined at runtime: { select_list } | ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = sel_table name = `sel_table` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `46) FROM Clause` ) ).

    "In the example, the FROM clause that is used in a SELECT statement is
    "determined at runtime. Here, the number of entries of a database table
    "is counted.

    DATA(tab_name) = lcl_det_at_runtime=>get_dyn_table_name( ).

    SELECT COUNT(*)
     FROM (tab_name)
     INTO @DATA(count).

    out->write( |Table name determined at runtime: { tab_name } | ).
    out->write( |\n| ).
    out->write( |The table { tab_name } has { count } entries.| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `47) WHERE Clause` ) ).

    "In the example, the WHERE clause that is used in a SELECT statement is
    "determined at runtime. Here, the WHERE clause is based on a string
    "table.

    DATA(where_clause) = lcl_det_at_runtime=>get_dyn_where_clause( ).

    SELECT *
     FROM zdemo_abap_flsch
     WHERE (where_clause)
     ORDER BY carrid
     INTO TABLE @DATA(where_tab)
     UP TO 5 ROWS.

    out->write( |WHERE clause determined at runtime:| ).
    out->write( |\n| ).
    out->write( data =  where_clause name = `where_clause` ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = where_tab name = `where_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `48) ORDER BY Clause` ) ).

    DATA(order_by) = 'FLTIME'.

    SELECT *
     FROM zdemo_abap_flsch
     ORDER BY (order_by)
     INTO TABLE @DATA(order_by_tab)
     UP TO 5 ROWS.

    out->write( |ORDER BY clause determined at runtime:| ).
    out->write( |\n| ).
    out->write( data = order_by name = `order_by` ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = order_by_tab name = `order_by_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `49) Multiple Dynamically Specified Clauses in an ABAP SQL SELECT Statement` ) ).

    "In this example, multiple clauses in a SELECT statement are
    "determined at runtime to demonstrate the rich variety of possibilities.
    "Note: The rows and target table specifications are not real dynamic
    "specifications in the SELECT statement in the sense of syntax elements
    "enclosed by parentheses. Here, they are just included to provide some
    "more 'dynamic' touch of the statement :)

    "Getting all clauses of the SELECT statement
    DATA(dyn_syntax_elem) = lcl_det_at_runtime=>get_dyn_syntax_elements( ).

    IF dyn_syntax_elem-table IS NOT INITIAL
    AND dyn_syntax_elem-select_list IS NOT INITIAL
    AND dyn_syntax_elem-where_clause IS NOT INITIAL
    AND dyn_syntax_elem-order_by IS NOT INITIAL
    AND dyn_syntax_elem-target IS BOUND
    AND dyn_syntax_elem-rows IS NOT INITIAL.

      out->write( `Dynamically determined syntax elements:` ).
      out->write( |\n| ).
      out->write( data = dyn_syntax_elem name = `dyn_syntax_elem` ).
      out->write( |\n| ).

      SELECT (dyn_syntax_elem-select_list)
        FROM (dyn_syntax_elem-table)
        WHERE (dyn_syntax_elem-where_clause)
        ORDER BY (dyn_syntax_elem-order_by)
        INTO CORRESPONDING FIELDS OF TABLE @dyn_syntax_elem-target->*
        UP TO @dyn_syntax_elem-rows ROWS.

      out->write( data = dyn_syntax_elem-target->* name = `dyn_syntax_elem-target->*` ).

    ELSE.
      out->write( `There's an issue with syntax elements.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `50) Dynamic Specifications in Other ABAP SQL Statements` ) ).

    "Creating a structure to be inserted into the database table
    DATA(table) = 'ZDEMO_ABAP_CARR'.
    DATA(wherecl) = 'CARRID = ''ZZ'''.
    SELECT SINGLE *
          FROM (table)
          INTO NEW @DATA(refstruc).
    refstruc->('CARRID') = 'ZZ'.

    INSERT (table) FROM @refstruc->*.

    SELECT SINGLE *
      FROM (table)
      WHERE (wherecl)
      INTO NEW @DATA(res1).
    out->write( data = res1->* name = `res1->*` ).
    out->write( |\n| ).

    refstruc->('CARRNAME') = 'ZZ Airlines'.
    UPDATE (table) FROM @refstruc->*.

    SELECT SINGLE *
      FROM (table)
      WHERE (wherecl)
      INTO NEW @DATA(res2).
    out->write( data = res2->* name = `res2->*` ).
    out->write( |\n| ).


    refstruc->('CURRCODE') = 'GBP'.
    MODIFY (table) FROM @refstruc->*.

    SELECT SINGLE *
      FROM (table)
      WHERE (wherecl)
      INTO NEW @DATA(res3).
    out->write( data = res3->* name = `res3->*` ).
    out->write( |\n| ).

    DELETE FROM (table) WHERE (wherecl).

    SELECT *
      FROM (table)
      INTO TABLE NEW @DATA(res4).
    out->write( data = res4->* name = `res4->*` ).
    out->write( |\n| ).

    "--------------------- Dynamic UPDATE ... SET ... statement ---------------------

    "Inserting demo data into the database table to work with
    TYPES carr_tab TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.
    INSERT ('ZDEMO_ABAP_CARR') FROM TABLE @( VALUE carr_tab( ( carrid = 'WX' carrname = 'WX Airways' )
                                                             ( carrid = 'XY' carrname = 'Air XY' )
                                                             ( carrid = 'YZ' carrname = 'YZ Airlines' ) ) ).

    "Note that erroneous dynamic specifications can lead to runtime errors
    "In the following example, the final inverted comma is missing in the dynamic
    "set clause.
    DATA(set_clause) = `CURRCODE = 'EUR`.
    DATA(where_cl) = `CARRID = 'WX' OR CARRID = 'XY' OR CARRID = 'YZ'`.

    TRY.
        UPDATE ('ZDEMO_ABAP_CARR') SET (set_clause) WHERE (where_cl).
      CATCH cx_sy_dynamic_osql_syntax INTO DATA(err_sql).
        DATA(error_text) = err_sql->get_text( ).
    ENDTRY.

    "Correcting the dynamic specification
    "The example sets the value for a component for all entries.
    "The example additionally specifies a (dynamic) WHERE clause
    "to restrict the range of entries where the update is performed.
    "The database table is also specified dynamically.
    set_clause = `CURRCODE = 'EUR'`.

    UPDATE ('ZDEMO_ABAP_CARR') SET (set_clause) WHERE (where_cl).

    SELECT *
      FROM ('ZDEMO_ABAP_CARR')
      INTO TABLE NEW @DATA(res5).
    out->write( data = res5->* name = `res5->*` ).
    out->write( |\n| ).

    "--------------------- Dynamic UPDATE ... INDICATORS ... statement ---------------------

    "The statement changes values of specific fields without overwriting existing values of
    "other fields.

    "Notes on the example:
    "- A structured type is created with the WITH INDICATORS addition.
    "- An internal table from which to update a database table is created.
    "- The table includes the indicator structure comp_ind.
    "- The table is populated, and two components are flagged as
    "  to be updated.
    "- Other fields remain unchanged. Note that key fields must be
    "  included in ind_tab (indicator setting for key fields has
    "  no effect).
    "- The UPDATE statement includes dynamically specified
    "  indicator syntax. Additionally, the database table is specified
    "  dynamically.

    "Structured type with WITH INDICATORS addition
    TYPES ind_wa TYPE zdemo_abap_carr WITH INDICATORS comp_ind TYPE abap_bool.

    DATA ind_tab TYPE TABLE OF ind_wa.

    "Filling internal table; only CURRCODE and URL should be updated
    ind_tab = VALUE #( ( carrid = 'WX'
                          carrname = 'WX Airways'
                          currcode = 'USD'
                          url = 'some_url_wx'
                          comp_ind-currcode = abap_true
                          comp_ind-url = abap_true )
                        ( carrid = 'XY'
                          carrname = 'Air XY'
                          currcode = 'USD'
                          url = 'some_url_xy'
                          comp_ind-currcode = abap_true
                          comp_ind-url = abap_true )
                        ( carrid = 'YZ'
                          carrname = 'YZ Airlines'
                          currcode = 'USD'
                          url = 'some_url_yz'
                          comp_ind-currcode = abap_true
                          comp_ind-url = abap_true ) ).

    DATA(dyn_ind) = `SET STRUCTURE comp_ind`.

    UPDATE ('ZDEMO_ABAP_CARR') FROM TABLE @ind_tab INDICATORS (dyn_ind).

    SELECT *
      FROM ('ZDEMO_ABAP_CARR')
      INTO TABLE NEW @DATA(res6).
    out->write( data = res6->* name = `res6->*` ).

    DELETE FROM ('ZDEMO_ABAP_CARR') WHERE (where_cl).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `51) Validating Input for Dynamic Specifications` ) ).
    "The following examples use methods of the CL_ABAP_DYN_PRG class, which supports
    "dynamic programming by checking the validity for dynamic specifications.
    "Check out the class documentation for more information.

    "In the following example, several table names are provided in a string table that
    "is looped over. Some wrong table names are intentionally included.
    "You can provide the "packages" formal parameter with a table that contains
    "the names of packages in which the tables should be included. The
    "assumption is that you imported the repository into the package
    "specified. If you imported it into a package with a different name,
    "change the value accordingly. Otherwise, none of the tables is found.

    out->write( `****** Checking if the input is a database table name, inlcuded in given packages ******` ).
    out->write( |\n| ).

    DATA(table_names) = VALUE string_table( ( `ZDEMO_ABAP_CARR` )
                                            ( `ZDEMO_ABAP_FLI` )
                                            ( `NO_DBTAB` )
                                            ( `ZDEMO_ABAP_FLSCH` )
                                            ( `ZDEMO_ABAP_FLI2` )
                                            ( `WRONG_DBTAB` ) ).

    DATA(check_packages) = VALUE string_hashed_table( ( `ZABAP_CHEAT_SHEETS` ) ).

    DATA dbtab TYPE string.

    LOOP AT table_names INTO DATA(wa_tab).
      TRY.
          dbtab = cl_abap_dyn_prg=>check_table_name_tab( val      = to_upper( wa_tab )
                                                         packages = check_packages ).

          SELECT SINGLE * FROM (dbtab) INTO NEW @DATA(ref_wa).

          out->write( |Result for { wa_tab }:| ).
          out->write( ref_wa->* ).
          out->write( |\n| ).
        CATCH cx_abap_not_a_table cx_abap_not_in_package INTO DATA(e).
          out->write( |Result for { wa_tab }:| ).
          out->write( e->get_text( ) ).
          out->write( |\n| ).
      ENDTRY.
    ENDLOOP.

    "In the following example, the check_allowlist method is used to check
    "whether the input is allowed or not. Similar to above, an internal
    "is filled with demo input. Here, a parameter is used that expects
    "a comma-separated list of allowed values.

    out->write( `****** Checking if input is allowed or not ******` ).
    out->write( |\n| ).

    DATA(to_be_checked) = VALUE string_table( ( `A` )
                                              ( `B` )
                                              ( `C` )
                                              ( `D` )
                                              ( `HALLO` )
                                              ( `ABAP` ) ).

    LOOP AT to_be_checked INTO DATA(chk).
      TRY.
          DATA(value) = cl_abap_dyn_prg=>check_allowlist( val      = chk
                                                          allowlist_str = `A,B,C,ABAP` ).
          out->write( |{ value } is allowed.| ).
        CATCH cx_abap_not_in_allowlist INTO e.
          out->write( e->get_text( ) ).
      ENDTRY.
    ENDLOOP.

    out->write( |\n| ).

    "The following example is similar to the one above. However, in this case,
    "a parameter is used that expects an internal table containing the allowed
    "values.

    LOOP AT to_be_checked INTO chk.
      TRY.
          value = cl_abap_dyn_prg=>check_allowlist( val      = chk
                                                    allowlist_htab = VALUE #( ( `X` )
                                                                              ( `B` )
                                                                              ( `HALLO` )
                                                                              ( `Y` )
                                                                              ( `ABAP` ) ) ).
          out->write( |{ value } is allowed.| ).
        CATCH cx_abap_not_in_allowlist INTO e.
          out->write( e->get_text( ) ).
      ENDTRY.
    ENDLOOP.

    out->write( |\n| ).
    out->write( `****** Checking if input can be a column name and does not contain invalid characters ******` ).
    out->write( |\n| ).

    "The following example uses a method with which the validity of column names
    "of database tables can be checked.

    to_be_checked = VALUE #( ( `CARRID` )
                             ( `CONNID` )
                             ( `SOME_COLUMN` )
                             ( `??NOPE??` )
                             ( `...!` ) ).

    LOOP AT to_be_checked INTO chk.
      TRY.
          DATA(col_name) = cl_abap_dyn_prg=>check_column_name( val    = chk
                                                               strict = abap_true ).
          out->write( |{ col_name } is allowed.| ).
        CATCH cx_abap_invalid_name INTO e.
          out->write( e->get_text( ) ).
      ENDTRY.
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52) Dynamic Method Calls (1)` ) ).

    "In the example, both class and method are determined at runtime for
    "the method call. The suitable parameter table is filled in the
    "method get_dyn_class_meth. The example is implemented in a way that
    "all the methods that are called store some text in a string. This
    "string is displayed to see the effect of the dynamic method call.

    lcl_det_at_runtime=>get_dyn_class_meth( IMPORTING cl = DATA(cl_name)
                                                      meth = DATA(meth_name)
                                                      ptab = DATA(p_tab) ).

    CALL METHOD (cl_name)=>(meth_name) PARAMETER-TABLE p_tab.

    out->write( |Class name determined at runtime: { cl_name } | ).
    out->write( |\n| ).
    out->write( |Method name determined at runtime: { meth_name } | ).
    out->write( |\n| ).

    out->write( `Result of method call (text stored in a variable):` ).
    out->write( |\n| ).
    out->write( data = lcl_det_at_runtime=>dyn_meth_call_result name = `lcl_det_at_runtime=>dyn_meth_call_result` ).
    out->write( |\n| ).

    "Further method calls
    "The class and method to be used is determined here by just providing
    "the character-like content (the name) via a data object in a predefined way.

    DATA method TYPE string VALUE `FILL_STRING`.

    "Note that the method has no parameters in this example.
    "Similar to above. The method stores some text in a string which is
    "displayed to see the effect of the dynamic method call.
    CALL METHOD lcl_det_at_runtime=>(method).

    out->write( data = lcl_det_at_runtime=>dyn_meth_call_result name = `lcl_det_at_runtime=>dyn_meth_call_result` ).
    out->write( |\n| ).

    DATA class TYPE string VALUE `LCL_DET_AT_RUNTIME`.

    CALL METHOD (class)=>fill_string.

    out->write( data = lcl_det_at_runtime=>dyn_meth_call_result name = `lcl_det_at_runtime=>dyn_meth_call_result` ).


**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52b) Dynamic Method Calls (2)` ) ).
    "Another example for dynamic invoke, using an instance method.

    "Example that uses the PARAMETER-TABLE addition
    "Creating an instance by specifying the type statically
    "An example class of the cheat sheet repository is used.
    DATA(oref1) = NEW zcl_demo_abap_objects( ).
    "Calling an instance method
    "The method multiplies an integer by 3.
    "The calculation result is returned.
    DATA(result) = oref1->triple( i_op = 2 ).

    out->write( data = result name = `result` ).
    out->write( |\n| ).

    "Dynamic equivalent
    "Creating an instance of a class by specifying the type
    "dynamically
    DATA oref2 TYPE REF TO object.
    CREATE OBJECT oref2 TYPE ('ZCL_DEMO_ABAP_OBJECTS').

    "Creating parameter table
    DATA(ptab) = VALUE abap_parmbind_tab( ( name  = 'I_OP'
                                            kind  = cl_abap_objectdescr=>exporting
                                            value = NEW i( 3 ) )
                                          ( name  = 'R_TRIPLE'
                                            kind  = cl_abap_objectdescr=>returning
                                            value = NEW i( ) ) ).

    "Dynamic method call and specifying a parameter table
    CALL METHOD oref2->('TRIPLE') PARAMETER-TABLE ptab.
    result = ptab[ name = 'R_TRIPLE' ]-('VALUE')->*.

    out->write( data = result name = `result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52c) Dynamic Method Calls (Syntax Pattern Overview) (3)` ) ).

    "The following examples use both named and unnamed data objects randomly,
    "i.e. ...=>(meth_name) or ...=>(`SOME_METH`), for example.
    DATA(classname) = `ZCL_DEMO_ABAP_DYNAMIC_PROG`.
    DATA(meth_name1) = `STAT_METH1`.

    "------------------------------------------------------------------------
    "---------------- Calling static methods dynamically --------------------
    "------------------------------------------------------------------------

    "-------- Method without mandatory parameters defined --------
    "The syntax is possible for methods of the same class.
    CALL METHOD (meth_name1).

    "The previous example method call works like me->(meth).
    CALL METHOD me->(meth_name1).

    "-------- Class specified statically, method specified dynamically --------
    CALL METHOD zcl_demo_abap_dynamic_prog=>(meth_name1).

    "-------- Class specified dynamically, method specified statically --------
    CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth1.

    "-------- Class and method specified dynamically --------
    CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>(`STAT_METH1`).

    "-------- Specifying non-optional parameters --------
    CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2 EXPORTING text = `hallo`.

    "Specifying the output parameter is optional
    DATA res TYPE string.
    CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2 EXPORTING text = `hallo` IMPORTING result = res.
    ASSERT res = `HALLO`.

    "-------- Some examples for handling errors when calling methods wrongly --------

    "Instance method called using =>
    TRY.
        CALL METHOD zcl_demo_abap_dynamic_prog=>(`INST_METH1`).
      CATCH cx_sy_dyn_call_illegal_method.
    ENDTRY.

    "The example method does not specify non-optional parameters.
    TRY.
        CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2.
      CATCH cx_sy_dyn_call_param_missing.
    ENDTRY.

    "Specifying a wrong parameter name
    TRY.
        CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2 EXPORTING hallo = `hallo`.
      CATCH cx_sy_dyn_call_param_missing.
    ENDTRY.

    "Assigning wrong, non-compatible type
    TRY.
        CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2 EXPORTING text = VALUE string_table( ( `hi` ) ).
      CATCH cx_sy_dyn_call_illegal_type.
    ENDTRY.

    "Specifying wrong parameter kinds (the example method specifies importing
    "and exporting parameters, and not a returning parameter)
    TRY.
        CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2 EXPORTING text = `hallo` RECEIVING result = res.
      CATCH cx_sy_dyn_call_illegal_type.
    ENDTRY.

    "------------------------------------------------------------------------
    "---------------- Calling instance methods dynamically ------------------
    "------------------------------------------------------------------------

    "Creating an instance of a class by specifying the type dynamically
    DATA object_ref TYPE REF TO object.
    CREATE OBJECT object_ref TYPE ('ZCL_DEMO_ABAP_DYNAMIC_PROG').

    "--- Object reference variable specified statically, method specified dynamically ---
    "Note: This is a also possible for interface reference variables.
    CALL METHOD object_ref->(`INST_METH1`).

    "-------- Specifying non-optional parameters --------
    CALL METHOD object_ref->(`INST_METH2`) EXPORTING text = `abap`.

    CALL METHOD object_ref->(`INST_METH2`) EXPORTING text = `abap` RECEIVING result = res.
    ASSERT res = `ABAP`.

    "Note that calling static methods using object reference variables is also possible.
    CALL METHOD object_ref->(`STAT_METH1`).

    CALL METHOD object_ref->(`STAT_METH2`) EXPORTING text = `test` IMPORTING result = res.
    ASSERT res = `TEST`.

    "------------------------------------------------------------------------
    "------------------- PARAMETER-TABLE addition ---------------------------
    "------------------------------------------------------------------------

    "------- Static equivalents to the dynamic statement below -------
    DATA(object_ref_stat) = NEW zcl_demo_abap_dynamic_prog( ).
    res = object_ref_stat->inst_meth2( `abc` ).
    ASSERT res = `ABC`.
    "For demo purposes, including chained method call options:
    "Functional method call
    res = NEW zcl_demo_abap_dynamic_prog( )->inst_meth2( `def` ).
    ASSERT res = `DEF`.
    "Standalone statement)
    NEW zcl_demo_abap_dynamic_prog( )->inst_meth2( EXPORTING text = `ghi` RECEIVING result = res ).
    ASSERT res = `GHI`.

    "------- Dynamic CALL METHOD statements using the PARAMETER-TABLE addition -------

    "Creating parameter table for an instance example method
    DATA(paramtab) = VALUE abap_parmbind_tab( ( name  = 'TEXT'
                                            kind  = cl_abap_objectdescr=>exporting
                                            value = NEW string( `jkl` ) )
                                          ( name  = 'RESULT'
                                            kind  = cl_abap_objectdescr=>returning
                                            value = NEW string( ) )
                                             ).

    CALL METHOD object_ref->(`INST_METH2`) PARAMETER-TABLE paramtab.
    "Excursion: Accessing structure components dynamically
    res = paramtab[ name = 'RESULT' ]-('VALUE')->*.
    ASSERT res = `JKL`.

    "Creating parameter table for a static example method
    paramtab = VALUE abap_parmbind_tab( ( name  = 'TEXT'
                                      kind  = cl_abap_objectdescr=>exporting
                                      value = NEW string( `mno` ) )
                                    ( name  = 'RESULT'
                                      kind  = cl_abap_objectdescr=>importing
                                      value = NEW string( ) ) ).

    "Demonstrating static/dynamic specification variants
    CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>(`STAT_METH2`) PARAMETER-TABLE paramtab.
    res = paramtab[ name = 'RESULT' ]-('VALUE')->*.
    ASSERT res = `MNO`.

    CALL METHOD zcl_demo_abap_dynamic_prog=>(`STAT_METH2`) PARAMETER-TABLE paramtab.
    res = paramtab[ name = 'RESULT' ]-('VALUE')->*.
    ASSERT res = `MNO`.

    CALL METHOD (`ZCL_DEMO_ABAP_DYNAMIC_PROG`)=>stat_meth2 PARAMETER-TABLE paramtab.
    res = paramtab[ name = 'RESULT' ]-('VALUE')->*.
    ASSERT res = `MNO`.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52d) Dynamic Formatting Option Specifications in String Templates` ) ).

    "ALIGN
    "Only to be used with WIDTH; only the associated values of the following attributes of the
    "class CL_ABAP_FORMAT can be used (they are of type i): A_LEFT (1), A_RIGHT (2), A_CENTER (3)
    DATA(demo_string) = `##`.
    DATA(s1) = |{ demo_string WIDTH = 10 ALIGN = (1) }<---|.

    out->write( data = s1 name = `s1` ).
    out->write( |\n| ).

    DATA(right) = 2.
    DATA(s2) = |{ demo_string WIDTH = 10 ALIGN = (right) }<---|.

    out->write( data = s2 name = `s2` ).
    out->write( |\n| ).

    "The following example uses method chaining with methods of the class
    "cl_abap_random_int to get a random integer value (in the range of 1 - 3).
    "The get_next method has a returning parameter, and returns an integer value.
    DO 5 TIMES.
      DATA(s3) = |{ demo_string WIDTH = 10 ALIGN = cl_abap_random_int=>create( seed = cl_abap_random=>seed( )
                                                      min  = 1 max = 3 )->get_next( ) }<---|.
    ENDDO.

    out->write( data = s3 name = `s3` ).
    out->write( |\n| ).

    "CASE
    "Values to be used: CL_ABAP_FORMAT=>C_RAW (for not changing the case; 0),
    "CL_ABAP_FORMAT=>C_UPPER (1), CL_ABAP_FORMAT=>C_LOWER (2)
    demo_string = `AbAp`.
    DATA(s4) = |{ demo_string CASE = (1) }|.

    out->write( data = s4 name = `s4` ).
    out->write( |\n| ).

    DATA(s5) = |{ demo_string CASE = CONV i( '2' ) }|.

    out->write( data = s5 name = `s5` ).
    out->write( |\n| ).

    DATA int_tab TYPE TABLE OF i WITH EMPTY KEY.
    int_tab = VALUE #( ( 0 ) ( 1 ) ( 2 ) ).
    DATA(s6) = |{ demo_string CASE = int_tab[ 1 ] }|.

    out->write( data = s2 name = `s2` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52e) Dynamic Parameter List in EXPORT and IMPORT Statements` ) ).

    DATA buffer TYPE xstring.

    "--------- Dynamic specification of the parameter list ---------
    "Note:
    "- The parameter list is specified in an index table with two columns.
    "- The column names can have random names, but the type must be character-like.
    "- The first column represents the parameter name, the second column represents
    "  the name of the data object.
    "- Note that special behavior applies. See the documentation.

    TYPES: BEGIN OF param,
             name TYPE string,
             dobj TYPE string,
           END OF param,
           param_tab_type TYPE TABLE OF param WITH EMPTY KEY.

    DATA: txt1 TYPE string VALUE `hello`,
          txt2 TYPE string VALUE `world`,
          txt3 TYPE string VALUE `ABAP`.

    DATA(param_table) = VALUE param_tab_type(
      ( name = `txt1` dobj = `txt1` )
      ( name = `txt2` dobj = `txt2` )
      ( name = `txt3` dobj = `txt3` ) ).

    EXPORT (param_table) TO DATA BUFFER buffer.

    "The example reads the content into structure components.
    DATA: BEGIN OF values,
            txt1 TYPE string,
            txt2 TYPE string,
            txt3 TYPE string,
          END OF values.

    param_table = VALUE param_tab_type(
      ( name = `txt1` dobj = `values-txt1` )
      ( name = `txt2` dobj = `values-txt2` )
      ( name = `txt3` dobj = `values-txt3` ) ).

    IMPORT (param_table) FROM DATA BUFFER buffer.

    out->write( data = values name = `values` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52f) Security Considerations in Dynamic Programming Using External Input` ) ).

    "Filling demo database tables of the ABAP cheat sheet repository
    zcl_demo_abap_aux=>fill_dbtabs( ).

    "--------------------------------------------------------------------
    "--- Specifying the data object holding external input as operand ---
    "--- and literal ----------------------------------------------------
    "--------------------------------------------------------------------

    "The example explores a dynamic WHERE clause. External content is used
    "in the WHERE clause, unchecked.

    "Assuming the data object 'input' holds external input inserted on a UI.
    DATA(input) = 'LH'.

    "Inserting the input value into a dynamic WHERE clause as literal
    DATA(cond1) = `CARRID = '` && input && `'`.
    SELECT SINGLE * FROM zdemo_abap_fli WHERE (cond1) INTO @DATA(db_entry).

    out->write( data = db_entry name = `db_entry` ).
    out->write( |\n\n| ).

    "Inserting the input value into a dynamic WHERE clause using the data
    "object name
    DATA(cond2) = `CARRID = @input`.
    SELECT SINGLE * FROM zdemo_abap_fli WHERE (cond2) INTO @db_entry.

    out->write( data =  db_entry name = `db_entry` ).
    out->write( |\n\n| ).

    "Assuming bad input is provided that is unchecked
    DATA(bad_input) = |LH' AND CONNID = '401|.

    "Inserting the input value as literal
    "Because of using the value as literal, the WHERE clause
    "can be manipulated, yielding a potentially different
    "result, thus posing a security risk.
    DATA(cond3) = `CARRID = '` && bad_input && `'`.
    SELECT SINGLE * FROM zdemo_abap_fli WHERE (cond3) INTO @db_entry.

    out->write( data =  db_entry name = `db_entry` ).
    out->write( |\n\n| ).

    "Inserting the input value using the data object name
    "In doing so, the WHERE clause becomes erroneous, the ABAP
    "SQL statement cannot be executed.
    DATA(cond4) = `CARRID = @bad_input`.
    TRY.
        SELECT SINGLE * FROM zdemo_abap_fli WHERE (cond4) INTO @db_entry.
        out->write( data =  db_entry name = `db_entry` ).
      CATCH cx_sy_dynamic_osql_error cx_sy_open_sql_data_error INTO DATA(select_error).
        out->write( select_error->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).
    out->write( |{ repeat( val = `*` occ = 70 ) }| ).

    "--------------------------------------------------------------------
    "------------ Accessing not allowed database tables -----------------
    "--------------------------------------------------------------------
    "Assume the name of a database table is specified externally, and a
    "dynamic ABAP SQL statement uses this name. Potentially, users that
    "are actually not allowed to access the database table may get access.
    "The example uses the CL_ABAP_DYN_PRG class that checks a list of
    "allowed database tables.

    "The following methods check ...
    "- Database table names
    "- Whether the database table is contained in a/certain package/s
    "Assuming you provide incorrect input for the table name, or
    "the table is not contained in the specified packages, you should
    "expect an exception to be raied.

    "Assuming the following data object contains external input
    DATA(input_dbtab_name) = `zdemo_abap_fli`.

    "check_table_name_str method: Specifying a single package
    TRY.
        DATA(databasetable) = cl_abap_dyn_prg=>check_table_name_str(
          val      = to_upper( input_dbtab_name )
          packages = `ZABAP_CHEAT_SHEETS` ).

        SELECT SINGLE * FROM (databasetable) INTO NEW @DATA(ref_db_entry).
        out->write( data =  ref_db_entry name = `ref_db_entry` ).
      CATCH cx_abap_not_a_table cx_abap_not_in_package INTO DATA(error_input_dbtab1).
        out->write( error_input_dbtab1->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).

    "check_table_name_tab method: Specifying multiple packages in an internal
    "table
    TRY.
        dbtab = cl_abap_dyn_prg=>check_table_name_tab(
          val      = to_upper( input_dbtab_name )
          packages = VALUE #( ( `ZABAP_CHEAT_SHEETS` )
                              ( `ZSOME_PACKAGE` ) ) ).

        SELECT SINGLE * FROM (dbtab) INTO NEW @ref_db_entry.
        out->write( data =  ref_db_entry name = `ref_db_entry` ).
      CATCH cx_abap_not_a_table cx_abap_not_in_package INTO DATA(error_input_dbtab2).
        out->write( error_input_dbtab2->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).

    "Not existant database table/invalid name
    input_dbtab_name = `not_a_dbtab!!`.
    TRY.
        dbtab = cl_abap_dyn_prg=>check_table_name_tab(
          val      = to_upper( input_dbtab_name )
          packages = VALUE #( ( `ZABAP_CHEAT_SHEETS` )
                              ( `ZSOME_PACKAGE` ) ) ).

        SELECT SINGLE * FROM (dbtab) INTO NEW @ref_db_entry.
        out->write( data =  ref_db_entry name = `ref_db_entry` ).
      CATCH cx_abap_not_a_table cx_abap_not_in_package INTO DATA(error_input_dbtab3).
        out->write( error_input_dbtab3->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).

    "Database table not existant in packages specified (assuming you have imported
    "the ABAP cheat sheet repository, and the database table is available)
    input_dbtab_name = `zdemo_abap_fli`.
    TRY.
        dbtab = cl_abap_dyn_prg=>check_table_name_tab(
          val      = to_upper( input_dbtab_name )
          packages = VALUE #( ( `SAP_BASIS` ) ) ).

        SELECT SINGLE * FROM (dbtab) INTO NEW @ref_db_entry.
        out->write( data =  ref_db_entry name = `ref_db_entry` ).
      CATCH cx_abap_not_a_table cx_abap_not_in_package INTO DATA(error_input_dbtab4).
        out->write( error_input_dbtab4->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).
    out->write( |{ repeat( val = `*` occ = 70 ) }| ).

    "--------------------------------------------------------------------
    "------------ Verifying input against a given allowlist  ------------
    "--------------------------------------------------------------------

    "Assume a SELECT statement dynamically specifies the column names
    "in the SELECT list. Table columns might be accessed although
    "they should not be.
    "You may check against an allowlist.

    "check_allowlist method
    "In the following examples, a method is used to check whether
    "the input is allowed or not. For this, you specify an allowlist.
    "Here, the relevant parameter expects a comma-separated list of
    "allowed values.

    "Assuming the following data object contains external input
    DATA(input_col_name) = `carrid`.

    TRY.
        DATA(value1) = cl_abap_dyn_prg=>check_allowlist(
            val           = to_upper( input_col_name )
            allowlist_str = `CARRID,CONNID,FLDATE` ).

        SELECT SINGLE (input_col_name) FROM zdemo_abap_fli INTO NEW @ref_db_entry.
        out->write( data =  ref_db_entry name = `ref_db_entry` ).
      CATCH cx_abap_not_in_allowlist INTO DATA(error_allowed1).
        out->write( error_allowed1->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).

    "The allowlist_htab formal parameter expects an internal table.
    input_col_name = `price`.
    TRY.
        DATA(value2) = cl_abap_dyn_prg=>check_allowlist(
            val           = to_upper( input_col_name )
            allowlist_htab = VALUE #( ( `CARRID` )
                                      ( `CONNID` )
                                      ( `FLDATE` ) ) ).

        SELECT SINGLE (input_col_name) FROM zdemo_abap_fli INTO NEW @ref_db_entry.
        out->write( data =  ref_db_entry name = `ref_db_entry` ).
      CATCH cx_abap_not_in_allowlist INTO DATA(error_allowed2).
        out->write( error_allowed2->get_text( ) ).
    ENDTRY.
    out->write( |\n\n| ).
    out->write( |{ repeat( val = `*` occ = 70 ) }| ).

    "--------------------------------------------------------------------
    "------------ Potential manipulation of ABAP SQL clauses ------------
    "--------------------------------------------------------------------

    "In the following example, a dynamic WHERE clause is set up. For this,
    "it is assumed that the WHERE clause uses external input via input fields.
    "This is represented by the column and value data objects. It is assumed
    "that column holds the name of the table column, value a dedicated value in
    "the specified table column.
    "The cl_abap_dyn_prg class is used to check content in two ways:
    "- Checking if the provided column name is valid using the check_column_name
    "  method.
    "- Using the quote method for putting single quotes around the value and escaping
    "  single quotes.
    "In a DO loop, various example inputs are explored. The fourth loop pass includes
    "bad input without using the quote method. This way, an SQL injection takes
    "place, yielding a different result. In this case, all database table entries
    "are retrieved because the WHERE clause is as follows:
    "CARRID = 'LH' OR CARRID <> 'LH'.
    "This is prevented using the quote method, resulting in a non-functional SELECT
    "statement.

    DATA: column TYPE c LENGTH 30,
          val    TYPE c LENGTH 30.

    DO 4 TIMES.
      CASE sy-index.
        WHEN 1.
          "Working example
          column = 'carrid'.
          val = 'lh'.
        WHEN 2.
          "Invalid column name
          column = '?=('.
          val = 'lh'.
        WHEN 3.
          "Bad input, using cl_abap_dyn_prg
          column = 'carrid'.
          val = |'LH' OR CARRID <> 'LH'|.

        WHEN 4.
          "Bad input, not using cl_abap_dyn_prg
          column = 'carrid'.
          val = |'LH' OR CARRID <> 'LH'|.

      ENDCASE.

      out->write( |---------- Run { sy-index } ----------| ).

      TRY.
          cl_abap_dyn_prg=>check_column_name( column ).
        CATCH cx_abap_invalid_name INTO DATA(error_col_name).
          out->write( error_col_name->get_text( ) ).
      ENDTRY.

      DATA(cond_syntax) = to_upper( column ) && ` = ` &&
      COND #( WHEN sy-index <> 4 THEN cl_abap_dyn_prg=>quote( to_upper( value ) ) ELSE to_upper( value ) ).

      TRY.
          SELECT *
                 FROM zdemo_abap_flsch
                 WHERE (cond_syntax)
                 INTO TABLE @DATA(itab_flsch).

          out->write( itab_flsch ).
        CATCH cx_sy_dynamic_osql_error cx_sy_open_sql_data_error INTO DATA(error_select).
          out->write( error_select->get_text( ) ).
      ENDTRY.

      out->write( |\n\n| ).
    ENDDO.

    "Example manipulating the SET clause in an UPDATE statement
    "Inserting a database table entry to work with in the example
    INSERT zdemo_abap_carr FROM @( VALUE #( carrid = 'XY' carrname = 'XY Airways' currcode = 'EUR' url = 'some_url'  ) ).
    SELECT SINGLE * FROM zdemo_abap_carr WHERE carrid = 'XY' INTO @DATA(row4update).

    out->write( data =  row4update name = `row4update` ).
    out->write( |\n\n| ).

    "Assuming the carrier name is to be changed (that was previously created and retrieved
    "for demo purposes). The carrier name is provided via external input, represented by
    "the following data object assignment.
    DATA(input_carrname) = 'Air XY'.

    "Specifying a potentially dangerous dynamic SET clause by directly using external
    "input in the clause
    DATA(dyn_set_clause) = `CARRNAME = '` && input_carrname && `'`.

    UPDATE zdemo_abap_carr
      SET (dyn_set_clause)
      WHERE carrid = @row4update-carrid.

    SELECT SINGLE * FROM zdemo_abap_carr WHERE carrid = 'XY' INTO @row4update.
    out->write( data =  row4update name = `row4update` ).
    out->write( |\n\n| ).

    "Bad input, not using cl_abap_dyn_prg
    "In the example, the input is manipulated in a way that also changes
    "another field value.
    DATA(bad_input_carrname) = |XY Airways', URL = '#########|.
    dyn_set_clause = `CARRNAME = '` && bad_input_carrname && `'`.

    UPDATE zdemo_abap_carr
      SET (dyn_set_clause)
      WHERE carrid = @row4update-carrid.

    SELECT SINGLE * FROM zdemo_abap_carr WHERE carrid = 'XY' INTO @row4update.
    out->write( data =  row4update name = `row4update` ).
    out->write( |\n\n| ).

    "Bad input, using cl_abap_dyn_prg
    "Undoing the changes for the demo database table row
    MODIFY zdemo_abap_carr FROM @( VALUE #( carrid = 'XY' carrname = 'XY Airways' currcode = 'EUR' url = 'some_url' ) ).
    SELECT SINGLE * FROM zdemo_abap_carr WHERE carrid = 'XY' INTO @row4update.

    bad_input_carrname = |XY Airways', URL = '#########|.
    dyn_set_clause = `CARRNAME = ` && cl_abap_dyn_prg=>quote( bad_input_carrname ).

    TRY.
        UPDATE zdemo_abap_carr
          SET (dyn_set_clause)
          WHERE carrid = @row4update-carrid.
      CATCH cx_sy_open_sql_data_error INTO DATA(error_set).
        out->write( error_set->get_text( ) ).
    ENDTRY.

    out->write( |{ repeat( val = `*` occ = 70 ) }| ).

    "--------------------------------------------------------------------
    "---------------------------- Escaping ------------------------------
    "--------------------------------------------------------------------

    "In various contexts, a replacement of special characters may be important.
    "Such an escaping is applied on characters contained in a string according
    "to a set of rules.

    "The following example deals with Cross Site Scripting, e.g. manipulating
    "HTML pages and embedding scripts displayed in a browser. In ABAP, this
    "enters the picture, for example, when directly dealing with the Internet
    "Communication Framework.
    "The built-in function escape can be used to escape content in various contexts.
    "The cl_abap_dyn_prg class also offers methods to escape. However, the function
    "is recommended due to performance reasons.

    "Assuming building HTML code by using external input
    DATA your_name TYPE string.
    your_name = sy-uname.
    DATA(html) = `<p>Hello ` && your_name && `!</p>`.

    out->write( data =  html name = `html` ).
    out->write( |\n\n| ).

    "Embedding potentially malicious scripts into the code
    your_name = `<script>alert("Hmmm... potentially malicious code!");</script>`.
    html = `<p>Hello ` && your_name && `!</p>`.

    "Inserted this in an HTML and run in a browser, an alert will be displayed.
    out->write( data =  html name = `html` ).
    out->write( |\n\n| ).

    "Escaping may be done as follows
    "Check the various methods available for escaping with cl_abap_dyn_prg, as well as
    "the formats in the context of the escape function
    DATA(esc_js_cl) = `<p>Hello ` && cl_abap_dyn_prg=>escape_xss_javascript( html ) && `!</p>`.

    "Using the built-in function escape
    DATA(esc_js_fu) = `<p>Hello ` && escape( val = html format = cl_abap_format=>e_xss_js ) && `!</p>`.

    "Further character handling and escaping examples using the cl_abap_dyn_prg class
    DATA(quote) = |10 o'clock|.
    DATA(handle_quotes) = cl_abap_dyn_prg=>quote( quote ).
    DATA(backtick) = |The character ` is a backtick|.
    DATA(handle_backtick) = cl_abap_dyn_prg=>quote_str( backtick ).
    DATA(esc_quotes) = cl_abap_dyn_prg=>escape_quotes( quote ).
    DATA(esc_backticks) = cl_abap_dyn_prg=>escape_quotes_str( backtick ).
    "You may also do the escaping using string processing techniques, e.g.
    "using the replace function.
    DATA(esc_quotes_replace) = replace( val = quote sub = |'| with = |''| occ = 0 ).
    DATA(esc_backticks_replace) = replace( val = backtick sub = |`| with = |``| occ = 0 ).

    out->write( data =  esc_js_cl name = `esc_js_cl` ).
    out->write( data =  esc_js_fu name = `esc_js_fu` ).
    out->write( data =  handle_quotes name = `handle_quotes` ).
    out->write( data =  handle_backtick name = `handle_backtick` ).
    out->write( data =  esc_quotes name = `esc_quotes` ).
    out->write( data =  esc_backticks name = `esc_backticks` ).
    out->write( data =  esc_quotes_replace name = `esc_quotes_replace` ).
    out->write( data =  esc_backticks_replace name = `esc_backticks` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `53) RTTI: Getting Type Information at Runtime/Getting a Reference to a Type Description Object` ) ).

    "Getting a reference to a type description object of a type.
    "i.e. getting an instance of a type description class
    "As shown below, the type decription object can be used
    "to create data objects dynamically.

    "Type for which information should be retrieved
    TYPES: elem_type TYPE c LENGTH 5.

    "Creating a data reference variable to hold the reference to
    "the type description object
    DATA type_descr_obj_elem TYPE REF TO cl_abap_elemdescr.

    "Retrieving type information by creating an instance of a type description class
    "As the name implies, the describe_by_name method expects the name of the type
    "The following example uses the CAST operator for the necessary downcast.
    type_descr_obj_elem = CAST #( cl_abap_typedescr=>describe_by_name( 'ELEM_TYPE' ) ).

    "Using the older ?= operator
    type_descr_obj_elem ?= cl_abap_typedescr=>describe_by_name( 'ELEM_TYPE' ).

    "Inline declaration is handy to avoid helper variables.
    DATA(type_descr_obj_elem_inl) = CAST cl_abap_elemdescr(
      cl_abap_typedescr=>describe_by_name( 'ELEM_TYPE' ) ).

    "You may also want to check the type description object in the debugger.
    out->write( data = type_descr_obj_elem_inl name = `type_descr_obj_elem_inl` ).

    "Various methods/attributes (note that they vary depending on the type) provide
    "you with detailed information.
    "The following examples show a selection.
    "Kind/Type kind/Output length
    DATA(kind_elem) = type_descr_obj_elem_inl->kind.
    DATA(type_kind_elem) = type_descr_obj_elem_inl->type_kind.
    DATA(output_length_elem) = type_descr_obj_elem_inl->output_length.

    out->write( data = kind_elem name = `kind_elem` ).
    out->write( |\n| ).
    out->write( data = type_kind_elem name = `type_kind_elem` ).
    out->write( |\n| ).
    out->write( data = output_length_elem name = `output_length_elem` ).
    out->write( |\n| ).

    "In the following example, the type properties are retrieved
    "without casting. The data object has the type ref to
    "cl_abap_typedescr. See the hierarchy tree of type description classes.
    "The reference in the type description object references an
    "object from one of the classes CL_ABAP_ELEMDESCR, CL_ABAP_ENUMDESCR,
    "CL_ABAP_REFDESCR, CL_ABAP_STRUCTDESCR, CL_ABAP_TABLEDSECR,
    "CL_ABAP_CLASSDESCR, or CL_ABAP_INTFDESCR.
    "In the following case, it is CL_ABAP_ELEMDESCR.
    "Note that in most of the RTTI examples in this class, the explicit
    "casting is included when retrieving a reference to the type
    "description object.
    TYPES another_elem_type TYPE n LENGTH 3.
    DATA(type_descr_obj_elem_inl_2) = cl_abap_typedescr=>describe_by_name( 'ANOTHER_ELEM_TYPE' ).

    out->write( data = type_descr_obj_elem_inl_2->kind name = `type_descr_obj_elem_inl_2->kind` ).
    out->write( |\n| ).
    out->write( data = type_descr_obj_elem_inl_2->type_kind name = `type_descr_obj_elem_inl_2->type_kind` ).
    out->write( |\n| ).

    "More types
    "Structured data type (here, using the name of a database table)
    DATA(type_descr_obj_struc) = CAST cl_abap_structdescr(
      cl_abap_typedescr=>describe_by_name( 'ZDEMO_ABAP_CARR' ) ).

    "Various attributes/methods available for detailed information
    "Kind
    DATA(struc_kind) = type_descr_obj_struc->kind.
    "Components of the structure (e.g. the component names and type description
    "objects for the individual components)
    DATA(comps_struc) = type_descr_obj_struc->get_components( ).
    "The attribute also lists the component names and types (but not the type
    "desription objects)
    DATA(comps_struc2) = type_descr_obj_struc->components.
    "Kind of structure
    DATA(struct_kind) = type_descr_obj_struc->struct_kind.

    out->write( data = struc_kind name = `struc_kind` ).
    out->write( |\n| ).
    out->write( data = comps_struc name = `comps_struc` ).
    out->write( |\n| ).
    out->write( data = comps_struc2 name = `comps_struc2` ).
    out->write( |\n| ).
    out->write( data = struct_kind name = `struct_kind` ).
    out->write( |\n| ).

    "Internal table type
    TYPES table_type TYPE SORTED TABLE OF zdemo_abap_carr WITH UNIQUE KEY carrid.

    DATA(type_descr_obj_tab) = CAST cl_abap_tabledescr(
      cl_abap_typedescr=>describe_by_name( 'TABLE_TYPE' ) ).

    "Kind
    DATA(tab_kind) = type_descr_obj_tab->kind.
    "The following method returns more information than the attribute below
    "(e.g. key kind (unique) etc.)
    DATA(tab_keys) = type_descr_obj_tab->get_keys( ).
    DATA(tab_keys2) = type_descr_obj_tab->key. "Attribute; lists the keys
    "Getting internal table components
    "The method get_table_line_type returns a variable of type ref to cl_abap_datadescr.
    "This way you can retrieve the table components. Method chaining comes in handy.
    DATA(tab_comps) = CAST cl_abap_structdescr(
      type_descr_obj_tab->get_table_line_type( ) )->get_components( ).

    out->write( data = tab_kind name = `tab_kind` ).
    out->write( |\n| ).
    out->write( data = tab_keys name = `tab_keys` ).
    out->write( |\n| ).
    out->write( data = tab_keys2 name = `tab_keys2` ).
    out->write( |\n| ).
    out->write( data = tab_comps name = `tab_comps` ).
    out->write( |\n| ).

    "Reference type
    TYPES ref_str TYPE REF TO string.
    DATA(type_descr_obj_ref) = CAST cl_abap_refdescr(
      cl_abap_typedescr=>describe_by_name( 'REF_STR' ) ).

    "Kind
    DATA(ref_kind) = type_descr_obj_ref->kind.
    "Returns type description object of the referenced type
    DATA(ref_type) = type_descr_obj_ref->get_referenced_type( ).
    "Absolute type name
    DATA(ref_type_abs_name) =
      type_descr_obj_ref->get_referenced_type( )->absolute_name.
    "Type kind
    DATA(ref_type_type_kind) =
      type_descr_obj_ref->get_referenced_type( )->type_kind.

    out->write( data = ref_kind name = `ref_kind` ).
    out->write( |\n| ).
    out->write( data = ref_type name = `ref_type` ).
    out->write( |\n| ).
    out->write( data = ref_type_abs_name name = `ref_type_abs_name` ).
    out->write( |\n| ).
    out->write( data = ref_type_type_kind name = `ref_type_type_kind` ).

    "Getting a reference to a type description object of an existing data object.
    "Instead of referring to the name of a type, referring to a data object here.
    "The relevant method is describe_by_data

    "Elementary data object
    DATA dobj_elem TYPE i.
    DATA(ty_des_obj_el) = CAST cl_abap_elemdescr(
      cl_abap_typedescr=>describe_by_data( dobj_elem ) ).

    "Structure
    DATA dobj_struc TYPE zdemo_abap_carr.
    DATA(ty_des_obj_struc) = CAST cl_abap_structdescr(
      cl_abap_typedescr=>describe_by_data( dobj_struc ) ).

    "Internal table
    DATA dobj_itab TYPE TABLE OF zdemo_abap_carr WITH EMPTY KEY.
    DATA(ty_des_obj_itab) = CAST cl_abap_tabledescr(
      cl_abap_typedescr=>describe_by_data( dobj_itab ) ).

    "Reference variable
    DATA dref_var TYPE REF TO string.
    DATA(ty_des_obj_dref) = CAST cl_abap_refdescr(
      cl_abap_typedescr=>describe_by_data( dref_var ) ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `54a) RTTI: Getting Type Information at Runtime for Miscellaneous Types` ) ).

    "The example demonstrates RTTI as follows:
    "- The method call takes care of providing the name of a type. It is implemented
    "  in a way that various types can be returned, i. e. elementary, structure,
    "  internal table, reference, class, interface.
    "- If the retrieved type is not a class or interface, a data object is created
    "  based on the type determined at runtime.
    "- The type description is retrieved using the method cl_abap_typedescr=>describe_by_data.
    "  Note the casts for the information retrieval statements.
    "- Depending on the type kind, various pieces of information are retrieved. There
    "  are plenty of options. In ADT, you can use the input help. Just position the
    "  cursor after the reference variable and ->, e.g. el->, and hit CTRL-Space.
    "  A dropdown appears showing you the variety you can explore. Check the class
    "  documentation for more information.
    "- If the retrieved type is a class or interface, the type description is
    "  retrieved using cl_abap_typedescr=>describe_by_name.
    "- The example for a class type includes the creation of an object based
    "  on a type determined at runtime using a CREATE OBJECT statement.

    "Retrieving type
    DATA(get_type) = lcl_det_at_runtime=>get_random_type( ).

    out->write( |Type name determined at runtime: { get_type }| ).
    out->write( |\n| ).

    DATA dref TYPE REF TO data.

    IF get_type <> `LCL_DET_AT_RUNTIME`
    AND get_type <> `IF_OO_ADT_CLASSRUN`.
      TRY.
          CREATE DATA dref TYPE (get_type).
        CATCH cx_sy_create_data_error.
          out->write( `Create data error!` ).
      ENDTRY.

      "Retrieving type information
      "When referring to a concrete data object name, you can use this method:
      DATA(some_type) = cl_abap_typedescr=>describe_by_data( dref->* ).

      "Elementary type
      IF some_type->kind = cl_abap_typedescr=>kind_elem.
        DATA(el) = CAST cl_abap_elemdescr( some_type ).
        out->write( data = el name = `el` ).
        "Various attributes and methods possible
        out->write( data = el->type_kind name = `el->type_kind` ).
        out->write( |\n| ).
        out->write( data = el->absolute_name name = `el->absolute_name` ).
        out->write( |\n| ).
        out->write( data = el->get_relative_name( ) name = `el->get_relative_name( )` ).
        out->write( |\n| ).

        "Structure
      ELSEIF some_type->kind = cl_abap_typedescr=>kind_struct.
        DATA(stru) = CAST cl_abap_structdescr( some_type ).
        out->write( data = stru->absolute_name name = `stru->absolute_name` ).
        out->write( |\n| ).
        out->write( data = stru->components name = `stru->components` ).
        out->write( |\n| ).
        out->write( data = stru->struct_kind name = `stru->struct_kind` ).
        out->write( |\n| ).
        out->write( data = stru->get_components( ) name = `stru->get_components( )` ).
        out->write( |\n| ).

        "Internal table
      ELSEIF some_type->kind =  cl_abap_typedescr=>kind_table.
        DATA(tab) = CAST cl_abap_tabledescr( some_type ).
        out->write( data = tab->absolute_name name = `tab->absolute_name` ).
        out->write( |\n| ).
        out->write( data = tab->table_kind name = `tab->table_kind` ).
        out->write( |\n| ).
        out->write( data = tab->get_keys( ) name = `tab->get_keys` ).
        out->write( |\n| ).
        out->write( data = tab->get_table_line_type( ) name = `tab->get_table_line_type( )` ).
        out->write( |\n| ).

        "Reference
      ELSEIF some_type->kind =  cl_abap_typedescr=>kind_ref.
        DATA(ref_descr) = CAST cl_abap_refdescr( some_type ).
        out->write( data = ref_descr->absolute_name name = `ref_descr->absolute_name` ).
        out->write( |\n| ).
        out->write( data = ref_descr->get_referenced_type( ) name = `ref_descr->get_referenced_type( )` ).
        out->write( |\n| ).
      ELSE.
        out->write( `Others ...` ).
      ENDIF.

    ELSE.

      "Retrieving type information
      "Here, using the type name and not a concrete data object as above.
      some_type = cl_abap_typedescr=>describe_by_name( get_type ).

      "Class
      IF some_type->kind =  cl_abap_typedescr=>kind_class.
        DATA(class_desc) = CAST cl_abap_classdescr( some_type ).
        out->write( data = class_desc->absolute_name name = `class_desc->absolute_name` ).
        out->write( |\n| ).
        out->write( data = class_desc->attributes name = `class_desc->attributes` ).
        out->write( |\n| ).
        out->write( data = class_desc->methods name = `class_desc->methods` ).
        out->write( |\n| ).

        "Creating an object based on a type determined at runtime
        DATA oref TYPE REF TO object.

        TRY.
            CREATE OBJECT oref TYPE (get_type).
            "Retrieving type information
            DATA(descr_ref) = cl_abap_typedescr=>describe_by_object_ref( oref ).
            out->write( data = descr_ref->absolute_name name = `descr_ref->absolute_name` ).
            out->write( |\n| ).
            out->write( data = descr_ref->kind name = `descr_ref->kind` ).
            out->write( |\n| ).
          CATCH cx_root.
            out->write( `Error` ).
        ENDTRY.

        "Interface
      ELSEIF some_type->kind =  cl_abap_typedescr=>kind_intf.
        DATA(if_descr) = CAST cl_abap_intfdescr( some_type ).
        out->write( data = if_descr->absolute_name name = `if_descr->absolute_name` ).
        out->write( |\n| ).
        out->write( data = if_descr->methods name = `class_desc->methods` ).
        out->write( |\n| ).
      ELSE.
        out->write( `Others ...` ).
      ENDIF.
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `54b) RTTI: Getting Type Information at Runtime for Miscellaneous Types` ) ).

    "Data objects to work with in the example
    DATA itab_refs TYPE TABLE OF REF TO data.
    DATA str_tab TYPE string_table.
    DATA dyn_dobj TYPE REF TO data.
    DATA dyn_obj TYPE REF TO object.
    DATA typdeobj TYPE REF TO cl_abap_typedescr.

    "Data objects of different kinds based on which type information shall be retrieved
    "Elementary type
    DATA elem_dobj TYPE c LENGTH 4 VALUE 'ABAP'.

    "Enumerated type
    TYPES: BEGIN OF ENUM enum_t,
             enum1,
             enum2,
             enum3,
           END OF ENUM enum_t.
    DATA(dobj_enum) = enum2.

    "demo_structured types
    DATA(demo_struct) = VALUE zdemo_abap_carr( carrid = 'XY' carrname = 'XY Airlines' ).
    "BDEF derived type (demo_structure)
    DATA demo_struct_rap TYPE STRUCTURE FOR CREATE zdemo_abap_rap_ro_m.

    "Internal table types
    "Standard table with standard table key
    DATA(string_table) = VALUE string_table( ( `AB` ) ( `AP` ) ).
    "Local demo_structured type as basis for a sorted internal table that
    "includes primary and secondary table key specifiactions (including
    "an alias name)
    TYPES: BEGIN OF struc_type,
             a TYPE c LENGTH 3,
             b TYPE i,
             c TYPE decfloat34,
           END OF struc_type.
    TYPES demo_tab_type TYPE SORTED TABLE OF struc_type
      WITH UNIQUE KEY a
      WITH NON-UNIQUE SORTED KEY sec_key ALIAS sk COMPONENTS b c .
    DATA(demo_sorted_tab) = VALUE demo_tab_type( ( a = 'aaa' ) ).

    "Reference variables
    "Data reference variable
    DATA(demo_dref) = NEW i( 123 ).
    "Object reference variable
    DATA(demo_oref) = NEW zcl_demo_abap_objects( ).
    "Interface reference variable
    DATA demo_iref TYPE REF TO zdemo_abap_objects_interface.
    demo_iref = CAST #( demo_oref ).

    "Adding the previous (data) objects to an internal table which is
    "looped over to retrieve type information for all
    itab_refs = VALUE #( ( REF #( elem_dobj ) ) "elementary type (1)
                         ( REF #( dobj_enum ) ) "enumerated type (2)
                         ( REF #( demo_struct ) ) "flat demo_structure (3)
                         ( REF #( demo_struct_rap ) ) "demo_structure typed with BDEF derived type (4)
                         ( REF #( string_table ) ) "internal table, elementary line type (5)
                         ( REF #( demo_sorted_tab ) ) "internal table, local line type (6)
                         ( REF #( demo_dref ) ) "data reference variable (7)
                         ( REF #( demo_oref ) ) "object reference variable (8)
                         ( REF #( demo_iref ) ) "interface reference variable (9)
                      ).


    LOOP AT itab_refs INTO DATA(type).
      DATA(tabix) = sy-tabix.
      TRY.
          "The reference returned points to an object from the class CL_ABAP_CLASSDESCR
          typdeobj = cl_abap_typedescr=>describe_by_object_ref( type->* ).
        CATCH cx_sy_dyn_call_illegal_type.
          "The reference returned points to an object from the class CL_ABAP_DATADESCR
          typdeobj = cl_abap_typedescr=>describe_by_data( type->* ).
      ENDTRY.

      "----------------- Exploring general type information -----------------
      "At this stage, with using the static methods above, you already get general type
      "information such as the type kind or the abosulte name. Check the type description
      "object in the debugger for more attributes.
      "When performing a down cast to more specific classes, you can access special
      "methods of the type object and get more detailed information.

      "Getting the type kind
      "For the constant values of type abap_typekind, see cl_abap_typedescr. For example, 'h'
      "stands for internal table.
      DATA(type_kind) = typdeobj->type_kind.
      INSERT |{ tabix } Type kind: { type_kind }| INTO TABLE str_tab.

      "Type category
      "For the constant values of type abap_typecategory, see cl_abap_typedescr.
      "C (class), E (elementary), I (interface), R (Reference), S (demo_structure), T (table)
      DATA(type_category) = typdeobj->kind.
      INSERT |{ tabix } Type category: { type_category }| INTO TABLE str_tab.

      "Absolute name (used later for dynamic (data) object creation)
      "Note: In ABAP for Cloud Development, absolute names having the pattern \TYPE=%_...
      "cannot be used to create (data) objects dynamically.
      DATA(absolutename) = typdeobj->absolute_name.
      INSERT |{ tabix } Absolute name: { absolutename }| INTO TABLE str_tab.

      "Relative name
      "Types that are implicitly defined (e.g. created using DATA) do not have a relative
      "type name. Explicitly defined types are, for example, standard ABAP types, Dictionary
      "types, classes and interfaces.
      DATA(relative_name) = typdeobj->get_relative_name( ).
      IF relative_name IS NOT INITIAL.
        INSERT |{ tabix } Relative name: { relative_name }| INTO TABLE str_tab.
      ENDIF.

      "Checking if it is a DDIC type
      DATA(is_ddic_type) = typdeobj->is_ddic_type( ).
      IF is_ddic_type IS NOT INITIAL.
        INSERT |{ tabix } Is DDIC type: "{ is_ddic_type }"| INTO TABLE str_tab.
      ENDIF.

      "----------------- Exploring more specific information by casting -----------------
      "For checking the type before performing the cast, you can use statements with
      "CASE TYPE OF and IS INSTANCE. The example demonstrates both options.

      CASE TYPE OF typdeobj.

        WHEN TYPE cl_abap_datadescr.
          INSERT |{ tabix } Is instance of cl_abap_datadescr| INTO TABLE str_tab.

          "-----------------------------------------------------------------------
          "----------------------- Elementary types ------------------------------
          "-----------------------------------------------------------------------
          IF typdeobj IS INSTANCE OF cl_abap_elemdescr.
            INSERT |{ tabix } Is instance of cl_abap_elemdescr| INTO TABLE str_tab.

            "Enumerated types
            IF typdeobj IS INSTANCE OF cl_abap_enumdescr.
              INSERT |{ tabix } Is instance of cl_abap_enumdescr| INTO TABLE str_tab.

              DATA(enum) = CAST cl_abap_enumdescr( typdeobj ).

              "Various type-specific information retrieval
              "Base type of enumerated type
              DATA(enum_base_type_kind) = enum->base_type_kind.
              INSERT |{ tabix } Base type: { enum_base_type_kind }| INTO TABLE str_tab.

              "Elements of the enumerated type
              DATA(enum_elements) = enum->members.
              INSERT |{ tabix } Elements:| &&
              | { REDUCE string( INIT rstr = `` FOR <l> IN enum_elements NEXT rstr = |{ rstr }{ COND #( WHEN rstr IS NOT INITIAL THEN ` / ` ) }| &&
              |{ <l>-name } ({ CONV i( <l>-value ) })| ) }| INTO TABLE str_tab.

              "Checking the type compatibility of the data object
              DATA(applies_enum1) = enum->applies_to_data( enum2 ).
              DATA(applies_enum2) = enum->applies_to_data( `nope` ).
              DATA(applies_enum3) = enum->applies_to_data_ref( REF #( enum3 ) ).
              DATA(applies_enum4) = enum->applies_to_data_ref( REF #( `nope` ) ).

              INSERT |{ tabix } Applies: 1) "{ applies_enum1 }" 2) "{ applies_enum2 }"| &&
              | 3) "{ applies_enum3 }" 4) "{ applies_enum4 }"| INTO TABLE str_tab.

              "Dynamically creating data objects based on the ...
              TRY.
                  "... absolute name
                  CREATE DATA dyn_dobj TYPE (absolutename).
                  "Assigning the value to the dynamically created data object
                  dyn_dobj->* = type->*.

                  "... type description object
                  CREATE DATA dyn_dobj TYPE HANDLE enum.
                  dyn_dobj->* = type->*.
                  INSERT |{ tabix } Dynamic data objects created, assignments done| INTO TABLE str_tab.
                CATCH cx_root INTO DATA(err_enum).
                  INSERT |{ tabix } Dynamic data object creation error: { err_enum->get_text( ) }| INTO TABLE str_tab.
              ENDTRY.

              "Elementary types other than enumerated types
            ELSE.
              DATA(elem) = CAST cl_abap_elemdescr( typdeobj ).

              "Note: General information such as (output) length, decimals etc. especially
              "for elementary types is already available without the cast.

              "Internal length
              DATA(elem_internal_length) = elem->length.
              "Output length
              DATA(elem_output_length) = elem->output_length.
              INSERT |{ tabix } Internal length: "{ elem_internal_length }", | &&
              |output length: "{ elem_output_length }"| INTO TABLE str_tab.

              "Checking the type compatibility of the data object
              DATA(applies_elem1) = elem->applies_to_data( 'ciao' ).
              DATA(applies_elem2) = elem->applies_to_data( abap_true ).
              DATA(applies_elem3) = elem->applies_to_data_ref( REF #( 'abap' ) ).
              DATA(applies_elem4) = elem->applies_to_data_ref( REF #( `nope` ) ).

              INSERT |{ tabix } Applies: 1) "{ applies_elem1 }" 2) "{ applies_elem2 }"| &&
              | 3) "{ applies_elem3 }" 4) "{ applies_elem4 }"| INTO TABLE str_tab.

              "Dynamically creating data objects based on the ...
              TRY.
                  "... absolute name
                  CREATE DATA dyn_dobj TYPE (absolutename).
                  "Assigning the value to the dynamically created data object
                  dyn_dobj->* = type->*.

                  "... type description object
                  CREATE DATA dyn_dobj TYPE HANDLE elem.
                  dyn_dobj->* = type->*.
                  INSERT |{ tabix } Dynamic data objects created, assignments done| INTO TABLE str_tab.
                CATCH cx_root INTO DATA(err_elem).
                  INSERT |{ tabix } Dynamic data object creation error: { err_elem->get_text( ) }| INTO TABLE str_tab.
              ENDTRY.
            ENDIF.

            "-----------------------------------------------------------------------
            "----------------------- Reference types ------------------------------
            "-----------------------------------------------------------------------
          ELSEIF typdeobj IS INSTANCE OF cl_abap_refdescr.
            INSERT |{ tabix } Is instance of cl_abap_refdescr| INTO TABLE str_tab.

            "Getting a reference to the type's type description object using the
            "describe_by_data_ref, which can be used for data reference variables.
            "Note that the dynamic type is evaluated.

            "The following statement retrieves a type description object using the describe_by_data_ref
            "method, which can be used for data reference variables. An object is returned that points
            "to an object in one of these classes: cl_abap_elemdescr, cl_abap_enumdescr, cl_abap_refdescr,
            "cl_abap_demo_structdescr, cl_abap_tabledsecr.
            "The method call is for demonstration purposes. With the returned object, the information
            "retrieval can also be performed as above.
            DATA(typdeobj_demo_dref) = cl_abap_typedescr=>describe_by_data_ref( type->* ).

            "Using the type description object retrieved above (describe_by_data) and casting
            DATA(data_reference) = CAST cl_abap_refdescr( typdeobj ).

            "Getting a reference to the type's type description object that is used to
            "type the reference.
            DATA(demo_dref_referenced_type) = data_reference->get_referenced_type( ).

            "Based on this, you can get further information of the dynamic type just like in the
            "other examples for the referenced type. Here, skipping further type evaluation.
            IF demo_dref_referenced_type IS INSTANCE OF cl_abap_elemdescr.
              INSERT |{ tabix } The referenced type is an elementary type.| INTO TABLE str_tab.
            ELSE.
              INSERT |{ tabix } The referenced type is a type other than elementary.| INTO TABLE str_tab.
            ENDIF.

            "Checking the type compatibility
            DATA(applies_demo_dref1) = data_reference->applies_to_data( REF #( 456 ) ).
            DATA(applies_demo_dref2) = data_reference->applies_to_data( REF #( `hello` ) ).
            TYPES ref_int TYPE REF TO i.
            TYPES ref_dstr TYPE REF TO string.
            DATA(applies_demo_dref3) = data_reference->applies_to_data_ref( NEW ref_int( ) ).
            DATA(applies_demo_dref4) = data_reference->applies_to_data_ref( NEW ref_dstr( ) ).

            INSERT |{ tabix } Applies: 1) "{ applies_demo_dref1 }" 2) "{ applies_demo_dref2 }"| &&
            | 3) "{ applies_demo_dref3 }" 4) "{ applies_demo_dref4 }"| INTO TABLE str_tab.

            "Dynamically creating data objects based on the ...
            TRY.
                "... absolute name of the referenced data object
                DATA(absolutename_ref) = demo_dref_referenced_type->absolute_name.
                CREATE DATA dyn_dobj TYPE REF TO (absolutename_ref).
                "Assigning the value to the dynamically created data object
                dyn_dobj->* = type->*.

                "... type description object
                CREATE DATA dyn_dobj TYPE HANDLE data_reference.
                dyn_dobj->* = type->*.
                INSERT |{ tabix } Dynamic data objects created, assignments done| INTO TABLE str_tab.
              CATCH cx_root INTO DATA(err_ref).
                INSERT |{ tabix } Dynamic data object creation error: { err_ref->get_text( ) }| INTO TABLE str_tab.
            ENDTRY.

            "Complex types
          ELSEIF typdeobj IS INSTANCE OF cl_abap_complexdescr.
            INSERT |{ tabix } Is instance of cl_abap_complexdescr| INTO TABLE str_tab.

            "-----------------------------------------------------------------------
            "----------------------- demo_structured types ------------------------------
            "-----------------------------------------------------------------------
            IF typdeobj IS INSTANCE OF cl_abap_structdescr.
              INSERT |{ tabix } Is instance of cl_abap_demo_structdescr| INTO TABLE str_tab.

              DATA(cast_struc) = CAST cl_abap_structdescr( typdeobj ).

              "demo_structure kind
              "For the constant values, see abap_demo_structkind cl_abap_demo_structdescr
              "For the constant values of type abap_demo_structkind, see cl_abap_demo_structdescr. For example, 'F'
              "stands for a flat demo_structure.
              DATA(struckind) = cast_struc->struct_kind.
              INSERT |{ tabix } demo_structure kind: { struckind }| INTO TABLE str_tab.

              "demo_structure components
              "The following attribute returns a table with component information, such as
              "the component names and type kinds.
              DATA(struc_components) = cast_struc->components.
              INSERT |{ tabix } Components 1: | &&
              |{ REDUCE string( INIT dstr = `` FOR <comp1> IN struc_components NEXT dstr = |{ dstr }| &&
              |{ COND #( WHEN dstr IS NOT INITIAL THEN ` / ` ) }{ <comp1>-name } ({ <comp1>-type_kind })| ) }| INTO TABLE str_tab.

              "demo_structure components (more details)
              "The following method also returns a table with component information. In this case,
              "type description objects of each component and the component names are returned, which can
              "be further evaluated.
              DATA(struc_components_tab) = cast_struc->get_components( ).
              INSERT |{ tabix } Components 2: | &&
              |{ REDUCE string( INIT dstr = `` FOR <comp2> IN struc_components_tab NEXT dstr = |{ dstr }| &&
              |{ COND #( WHEN dstr IS NOT INITIAL THEN ` / ` ) }{ <comp2>-name } ({ <comp2>-type->type_kind })| ) }| INTO TABLE str_tab.

              "Checking if the demo_structure has includes
              DATA(struc_has_include) = cast_struc->has_include.
              INSERT |{ tabix } Has include: "{ struc_has_include }"| INTO TABLE str_tab.
              IF struc_has_include = abap_true.
                "Returning the included view
                "Check the class documentation for more information
                DATA(struc_incl_view) = cast_struc->get_included_view( ).
                INSERT |{ tabix } Included view: | &&
                |{ REDUCE string( INIT dstr = `` FOR <comp3> IN struc_incl_view NEXT dstr = |{ dstr }| &&
                |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <comp3>-name }| ) }| INTO TABLE str_tab.

                "Returning component names of all components and subdemo_structures in included
                "demo_structures that contain included demo_structures
                DATA(struc_all_incl) = cast_struc->get_symbols( ).
                INSERT |{ tabix } Included view: | &&
                |{ REDUCE string( INIT dstr = `` FOR <comp4> IN struc_all_incl NEXT dstr = |{ dstr }| &&
                |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <comp4>-name }| ) }| INTO TABLE str_tab.
              ENDIF.

              "Checking the type compatibility of the data object
              DATA demo_struct_test TYPE zdemo_abap_carr.
              DATA demo_struct_rap_test TYPE STRUCTURE FOR CREATE zdemo_abap_rap_ro_m.
              DATA(applies_struc1) = cast_struc->applies_to_data( demo_struct_test ).
              DATA(applies_struc2) = cast_struc->applies_to_data( demo_struct_rap_test ).
              DATA(applies_struc3) = cast_struc->applies_to_data_ref( REF #( demo_struct_test ) ).
              DATA(applies_struc4) = cast_struc->applies_to_data_ref( REF #( demo_struct_rap_test ) ).

              INSERT |{ tabix } Applies: 1) "{ applies_struc1 }" 2) "{ applies_struc2 }" | &&
              |3) "{ applies_struc3 }" 4) "{ applies_struc4 }"| INTO TABLE str_tab.

              "Dynamically creating data objects based on the ...
              TRY.
                  "... absolute name
                  CREATE DATA dyn_dobj TYPE (absolutename).
                  "Assigning the value to the dynamically created data object
                  dyn_dobj->* = type->*.

                  "... type description object
                  CREATE DATA dyn_dobj TYPE HANDLE cast_struc.
                  dyn_dobj->* = type->*.
                  INSERT |{ tabix } Dynamic data objects created, assignments done| INTO TABLE str_tab.
                CATCH cx_root INTO DATA(err_struc).
                  INSERT |{ tabix } Dynamic data object creation error: { err_struc->get_text( ) }| INTO TABLE str_tab.
              ENDTRY.

              "-----------------------------------------------------------------------
              "----------------------- Table types ------------------------------
              "-----------------------------------------------------------------------
            ELSEIF typdeobj IS INSTANCE OF cl_abap_tabledescr.
              INSERT |{ tabix } Is instance of cl_abap_tabledescr| INTO TABLE str_tab.

              DATA(cast_tab) = CAST cl_abap_tabledescr( typdeobj ).

              "Getting the table kind
              "For the constant values of type abap_tablekind, see cl_abap_tabledescr. For example, 'S'
              "stands for a standard table.
              DATA(tab_table_kind) = cast_tab->table_kind.
              INSERT |{ tabix } Table kind: { tab_table_kind }| INTO TABLE str_tab.

              "Checking if the table has a unique key
              DATA(tab_has_unique_key) = cast_tab->has_unique_key.
              INSERT |{ tabix } Has a unique key: "{ tab_has_unique_key }" | &&
              |{ COND #( WHEN tab_has_unique_key IS INITIAL THEN `(no unique key)` ) }| INTO TABLE str_tab.

              "Returning a table with the names of internal table keys
              DATA(tab_table_key) = cast_tab->key.
              INSERT |{ tabix } Table keys: { REDUCE string( INIT dstr = `` FOR <key1> IN tab_table_key NEXT dstr = |{ dstr }| &&
              |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <key1>-name }| ) }| INTO TABLE str_tab.

              "Returning a table with a description of all table keys, e.g. all components of a key,
              "key kind (U, unique, in the example case), information whether the key is the primary
              "key etc. For the constant values, see the cl_abap_tabledescr class.
              DATA(tabkeys) = cast_tab->get_keys( ).

              INSERT |{ tabix } Table keys: { REDUCE string( INIT dstr = `` FOR <key2> IN tabkeys NEXT dstr = |{ dstr }| &&
              |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ REDUCE string( INIT str2 = `` FOR <key3> IN <key2>-components NEXT str2 = |{ str2 }| &&
              |{ COND #( WHEN str2 IS NOT INITIAL THEN `/` ) }{ <key3>-name }| ) } (is primary: "{ <key2>-is_primary }", |  &&
              |is unique: "{ <key2>-is_unique }", key kind: "{ <key2>-key_kind }", access kind: "{ <key2>-access_kind }")| ) }| INTO TABLE str_tab.

              DATA(tab_keys_aliases) = cast_tab->get_key_aliases( ).
              IF tab_keys_aliases IS NOT INITIAL.
                INSERT |{ tabix } Table key aliases: { REDUCE string( INIT dstr = `` FOR <key4> IN tab_keys_aliases NEXT dstr = |{ dstr }| &&
                |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <key4>-name } (table key) -> { <key4>-alias } (alias)| ) }|  INTO TABLE str_tab.
              ENDIF.

              "If you want to get information about the line type, e.g. finding out about the component
              "names, another cast is required. First, getting a reference to the type description object
              "for the demo_structured type.
              DATA(tab_line_type) = cast_tab->get_table_line_type( ).

              "Then, performing a cast to access the component information as shown above.
              "Note that the line type can also be of types other than demo_structured line types.
              IF tab_line_type IS INSTANCE OF cl_abap_structdescr.
                DATA(tab_line_info) = CAST cl_abap_structdescr( tab_line_type ).
                "See more options for demo_structures above.
                DATA(tabcomps) = tab_line_info->components.
                INSERT |{ tabix } Table components: { REDUCE string( INIT dstr = `` FOR <com> IN tabcomps NEXT dstr = |{ dstr }| &&
                |{ COND #( WHEN dstr IS NOT INITIAL THEN ` / ` ) }{ <com>-name } ({ <com>-type_kind })| ) }| INTO TABLE str_tab.

              ELSEIF tab_line_type IS INSTANCE OF cl_abap_elemdescr.
                DATA(tab_elem_line_type) = CAST cl_abap_elemdescr( tab_line_type ).
                DATA(tab_elem_line_type_kind) = tab_elem_line_type->type_kind.
                INSERT |{ tabix } Elementary line type, type kind: { tab_elem_line_type_kind }| INTO TABLE str_tab.
              ENDIF.

              "Checking the type compatibility of the data object
              DATA tab_test1 TYPE string_table.
              DATA tab_test2 TYPE demo_tab_type.

              DATA(applies_tab1) = cast_tab->applies_to_data( tab_test1 ).
              DATA(applies_tab2) = cast_tab->applies_to_data( tab_test2 ).
              DATA(applies_tab3) = cast_tab->applies_to_data_ref( REF #( tab_test1 ) ).
              DATA(applies_tab4) = cast_tab->applies_to_data_ref( REF #( tab_test2 ) ).

              INSERT |{ tabix } Applies: 1) "{ applies_tab1 }" 2) "{ applies_tab2 }" | &&
              |3) "{ applies_tab3 }" 4) "{ applies_tab4 }"| INTO TABLE str_tab.

              "Dynamically creating data objects based on the ...
              TRY.
                  "... absolute name
                  CREATE DATA dyn_dobj TYPE (absolutename).
                  dyn_dobj->* = type->*.

                  "... type description object
                  CREATE DATA dyn_dobj TYPE HANDLE cast_tab.
                  dyn_dobj->* = type->*.
                  INSERT |{ tabix } Dynamic data objects created, assignments done| INTO TABLE str_tab.
                CATCH cx_root INTO DATA(err_tab).
                  INSERT |{ tabix } Dynamic data object creation error: { err_tab->get_text( ) }| INTO TABLE str_tab.
              ENDTRY.
            ENDIF.
          ENDIF.

          "Object types
        WHEN TYPE cl_abap_objectdescr.
          INSERT |{ tabix } Is instance of cl_abap_objectdescr| INTO TABLE str_tab.

          "In this example, reference variables are used to retrieve type information of their dynamic type.
          "Here, and to find out about the dynamic type the reference refers to (i.e. class or interface), a cast
          "with cl_abap_refdescr and calling the get_referenced_type method is used to also find out about the
          "instance of cl_abap_intfdescr. In this example, the dynamic type in 'type->*' is evaluated, which is
          "cl_abap_classdescr for both because the interface reference variable was assigned accordingly above.
          DATA(referenced_type) = CAST cl_abap_refdescr( cl_abap_typedescr=>describe_by_data( type->* ) )->get_referenced_type( ).

          "-----------------------------------------------------------------------
          "----------------------- Class descriptions ------------------------------
          "-----------------------------------------------------------------------
          IF referenced_type IS INSTANCE OF cl_abap_classdescr.
            INSERT |{ tabix } Is instance of cl_abap_classdescr| INTO TABLE str_tab.

            DATA(obj_ref) = CAST cl_abap_classdescr( typdeobj ).

            "Getting the class kind
            "For the constant values of type abap_classkind, see cl_abap_classdescr.
            "Common, simple class (C), abstract class (A), final class (F)
            DATA(obj_ref_class_kind) = obj_ref->class_kind.

            "Getting class attributes
            "You can check the following table in the debugger. There is plenty of information available
            "such as type kind, constant, read only etc.
            "The example writes the names, the visibility and static or instance attribute (is_class = abap_true
            "means it is a static attribute) to the string table.
            DATA(obj_ref_attributes) = obj_ref->attributes.

            INSERT |{ tabix } Attributes: { REDUCE string( INIT dstr = `` FOR <at> IN obj_ref_attributes NEXT dstr = |{ dstr }| &&
            |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <at>-name } (vis: "{ <at>-visibility }", static: "{ <at>-is_class }")| ) }| INTO TABLE str_tab.

            "Getting the interfaces implemented
            DATA(obj_ref_interfaces) = obj_ref->interfaces.
            INSERT |{ tabix } Interfaces: { REDUCE string( INIT dstr = `` FOR <intf> IN obj_ref_interfaces NEXT dstr = |{ dstr }| &&
            |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <intf>-name }| ) }| INTO TABLE str_tab.

            "Getting information about the methods
            "You can check the following table in the debugger. There is plenty of information available
            "such as parameters, visibility, abstract/final, static/instance and more.
            "The example only writes the method names to the string table.
            DATA(obj_ref_methods) = obj_ref->methods.
            INSERT |{ tabix } Methods: { REDUCE string( INIT dstr = `` FOR <meth> IN obj_ref_methods NEXT dstr = |{ dstr }| &&
            |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <meth>-name }| ) }| INTO TABLE str_tab.

            "Getting a reference to the type description object and the absolute name
            "of the superclass
            "In this example, it is the root class object OBJECT.
            DATA(obj_ref_super_class) = obj_ref->get_super_class_type( ).
            DATA(obj_ref_super_class_name) = obj_ref_super_class->absolute_name.
            INSERT |{ tabix } Super class: { obj_ref_super_class_name }| INTO TABLE str_tab.

            "Checking the type compatibility of the object
            DATA(demo_oref_test1) = NEW zcl_demo_abap_objects( ).
            DATA(demo_oref_test2) = NEW cl_system_uuid( ).

            DATA(applies_obj1) = obj_ref->applies_to( demo_oref_test1 ).
            DATA(applies_obj2) = obj_ref->applies_to( demo_oref_test2 ).
            DATA(applies_obj3) = obj_ref->applies_to_class( 'ZCL_DEMO_ABAP_OBJECTS' ).
            DATA(applies_obj4) = obj_ref->applies_to_class( 'CL_SYSTEM_UUID' ).

            INSERT |{ tabix } Applies: 1) "{ applies_obj1 }" 2) "{ applies_obj2 }" | &&
            |3) "{ applies_obj3 }" 4) "{ applies_obj4 }"| INTO TABLE str_tab.

            "Dynamically creating objects based on the absolute name
            TRY.
                CREATE OBJECT dyn_obj TYPE (absolutename).
                INSERT |{ tabix } Dynamic object created| INTO TABLE str_tab.
              CATCH cx_sy_create_object_error INTO DATA(err_obj).
                INSERT |{ tabix } Dynamic object creation error: { err_obj->get_text( ) }| INTO TABLE str_tab.
            ENDTRY.

            "The following example shows dynamically accessing public class attributes using the
            "dynamically created object. The names and the attribute content are added to the string table.
            "In this example (using an ABAP cheat sheet class), all attributes are convertible to string.
            IF  absolutename CS '\CLASS=ZCL_DEMO_ABAP_OBJECTS' AND err_obj IS INITIAL.
              INSERT |{ tabix } Dynamic attribute access: { REDUCE string( INIT dstr = `` FOR <m> IN obj_ref_attributes NEXT dstr = |{ dstr }| &&
              |{ COND #( WHEN dstr IS NOT INITIAL AND <m>-visibility = 'U' THEN ` / ` ) }| &&
              |{ COND #( WHEN <m>-visibility = 'U' THEN <m>-name && ` ("` && CONV string( dyn_obj->(<m>-name) ) && `")` ) }| ) }| INTO TABLE str_tab.
            ENDIF.

            "-----------------------------------------------------------------------
            "----------------------- Interface descriptions ------------------------------
            "-----------------------------------------------------------------------
          ELSEIF referenced_type IS INSTANCE OF cl_abap_intfdescr.
            INSERT |{ tabix } Is instance of cl_abap_intfdescr| INTO TABLE str_tab.

            "In the example, the checked reference variable points to the class
            "as the interface reference variable was assigned an instance of a class.
            "Therefore, the example here does not work with 'typdeobj' but with the type
            "description object 'referenced_type'. With 'referenced_type', the
            "interface-specific information can be accessed using a cast.
            DATA(intf) = CAST cl_abap_intfdescr( referenced_type ).

            "Getting the absolute name
            DATA(intf_abs_name) = intf->absolute_name.
            INSERT |{ tabix } Absolute name (via cl_abap_intfdescr): { intf_abs_name }| INTO TABLE str_tab.

            "Relative name
            DATA(intf_rel_name) = intf->get_relative_name( ).
            INSERT |{ tabix } Relative name (via cl_abap_intfdescr): { intf_rel_name }| INTO TABLE str_tab.

            "Type kind
            "For the constant values of type abap_typekind, see cl_abap_typedescr.
            "+ stands for the internal type interface.
            DATA(intf_type_kind) = intf->type_kind.
            INSERT |{ tabix } Type kind (via cl_abap_intfdescr): { intf_type_kind }| INTO TABLE str_tab.

            "Type category
            "For the constant values of type abap_typecategory, see cl_abap_typedescr.
            "I stands for interface.
            DATA(intf_type_category) = intf->kind.
            INSERT |{ tabix } Type category (via cl_abap_intfdescr): { intf_type_category }| INTO TABLE str_tab.

            "Interface type
            "For the constant values of type abap_intfkind, see cl_abap_intfdescr.
            "F stands for flat interface
            DATA(intf_type) = intf->intf_kind.
            INSERT |{ tabix } Interface type: { intf_type }| INTO TABLE str_tab.

            "Interface attributes
            DATA(intf_attributes) = intf->attributes.
            INSERT |{ tabix } Attributes: { REDUCE string( INIT dstr = `` FOR <attrintf> IN intf_attributes NEXT dstr = |{ dstr }| &&
            |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <attrintf>-name } (vis: "{ <attrintf>-visibility }", | &&
            |static: "{ <attrintf>-is_class }")| ) }| INTO TABLE str_tab.

            "Interface methods
            "You can check the following table in the debugger. There is plenty of information available
            "such as parameters, visibility, abstract/final, static/instance, and more.
            "The example only writes the methods names to the string table.
            DATA(intf_methods) = intf->methods.
            INSERT |{ tabix } Methods: { REDUCE string( INIT dstr = `` FOR <methintf> IN intf_methods NEXT dstr = |{ dstr }| &&
            |{ COND #( WHEN dstr IS NOT INITIAL THEN `, ` ) }{ <methintf>-name }| ) }| INTO TABLE str_tab.

            "Checking the type compatibility
            DATA(intf_test1) = NEW zcl_demo_abap_objects( ).
            DATA(intf_test2) = NEW cl_system_uuid( ).

            DATA(applies_intf1) = intf->applies_to( intf_test1 ).
            DATA(applies_intf2) = intf->applies_to( intf_test2 ).
            DATA(applies_intf3) = intf->applies_to_class( 'ZCL_DEMO_ABAP_OBJECTS' ).
            DATA(applies_intf4) = intf->applies_to_class( 'CL_SYSTEM_UUID' ).

            INSERT |{ tabix } Applies: 1) "{ applies_intf1 }" 2) "{ applies_intf2 }"| &&
            | 3) "{ applies_intf3 }" 4) "{ applies_intf4 }"| INTO TABLE str_tab.

            "Creating an interface reference variable dynamically
            TRY.
                CREATE DATA dyn_dobj TYPE REF TO (intf_abs_name).
                INSERT |{ tabix } Dynamic data object created| INTO TABLE str_tab.
              CATCH cx_sy_create_data_error INTO DATA(err_intf).
                INSERT |{ tabix } Dynamic data object creation error: { err_intf->get_text( ) }| INTO TABLE str_tab.
            ENDTRY.

            "The following example shows dynamically creating an object which is assigned to the
            "previously created interface reference variable. Artifacts of the ABAP cheat sheet repository
            "are used.
            IF intf_abs_name CS '\INTERFACE=ZDEMO_ABAP_OBJECTS_INTERFACE'
            AND absolutename CS '\CLASS=ZCL_DEMO_ABAP_OBJECTS'
            AND err_intf IS INITIAL.
              TRY.
                  CREATE OBJECT dyn_dobj->* TYPE (absolutename).
                  INSERT |{ tabix } Dynamic object created| INTO TABLE str_tab.
                CATCH cx_sy_create_object_error INTO err_obj.
                  INSERT |{ tabix } Dynamic object creation error: { err_obj->get_text( ) }| INTO TABLE str_tab.
              ENDTRY.
            ENDIF.
          ENDIF.
      ENDCASE.
      INSERT `-----------------------------------` INTO TABLE str_tab.
    ENDLOOP.
    out->write( str_tab ).

**********************************************************************

    "----------- Exploring the describe_by_name method -----------
    "The method returns a type description object when providing the relative or
    "absolute name of a type.
    "The following example explores the RTTI type hierarchy based on relative names
    "and using the describe_by_name method. Similar to the example above, an internal
    "table that is filled with local and global type names instead of data objects is
    "looped over. The information retrieval can be performed via the type description
    "object as above, but it is not implemented here.

    CLEAR str_tab.
    DATA typdeobj_from_type_name TYPE REF TO cl_abap_typedescr.

    "Data types of different kinds based on which type
    "information shall be retrieved
    "Elementary type
    TYPES packed TYPE p LENGTH 8 DECIMALS 2.

    "Enumerated type
    TYPES: BEGIN OF ENUM enum_type,
             enum_a,
             enum_b,
             enum_c,
           END OF ENUM enum_type.

    "demo_structured types
    TYPES: BEGIN OF flat_struc_type,
             a TYPE c LENGTH 3,
             b TYPE i,
             c TYPE decfloat34,
           END OF flat_struc_type.

    TYPES str_der_type TYPE STRUCTURE FOR CREATE zdemo_abap_rap_ro_m.

    "Internal table types
    TYPES int_demo_tab_type TYPE TABLE OF i WITH EMPTY KEY.
    TYPES demo_sorted_demo_tab_type TYPE SORTED TABLE OF flat_struc_type
      WITH UNIQUE KEY a
      WITH NON-UNIQUE SORTED KEY sec_key ALIAS sk COMPONENTS b c.
    TYPES itab_der_type TYPE TABLE FOR UPDATE zdemo_abap_rap_ro_m.

    "Reference types
    TYPES int_demo_dref_type TYPE REF TO i.
    TYPES gen_demo_dref_type TYPE REF TO data.
    "Class and interface names are specified directly

    DATA(type_name_tab) = VALUE string_table( ( `PACKED` )                       "Elementary type (1)
                                           ( `TIMESTAMPL` )                   "Elementary type, global DDIC type/data element (2)
                                           ( `ENUM_TYPE` )                    "Enumerated type (3)
                                           ( `FLAT_STRUC_TYPE` )              "demo_structured type, flat demo_structure (4)
                                           ( `STR_DER_TYPE` )                 "demo_structured type, BDEF derived type (5)
                                           ( `INT_demo_tab_type` )                 "Table type, elementary line type (6)
                                           ( `demo_sorted_demo_tab_type` )              "Table type, demo_structured line type (7)
                                           ( `ITAB_DER_TYPE` )                "Table type, BDEF derived type (8)
                                           ( `INT_demo_dref_TYPE` )                "Reference type (9)
                                           ( `GEN_demo_dref_TYPE` )                "Reference type, generic type (10)
                                           ( `CL_ABAP_TYPEDESCR` )            "Class name (11)
                                           ( `CL_ABAP_CORRESPONDING` )        "Class name (12)
                                           ( `IF_OO_ADT_CLASSRUN` )           "Interface name (13)
                                           ( `ZDEMO_ABAP_OBJECTS_INTERFACE` ) "Interface name (14)
                                         ).

    LOOP AT type_name_tab INTO DATA(ty_name).
      DATA(tabix_type_names) = sy-tabix.
      typdeobj_from_type_name = cl_abap_typedescr=>describe_by_name( ty_name ).
      CASE TYPE OF typdeobj_from_type_name.
        WHEN TYPE cl_abap_datadescr.
          INSERT |{ tabix_type_names } Is instance of cl_abap_datadescr| INTO TABLE str_tab.
          CASE TYPE OF typdeobj_from_type_name.
            WHEN TYPE cl_abap_elemdescr.
              INSERT |{ tabix_type_names } Is instance of cl_abap_elemdescr| INTO TABLE str_tab.
              IF typdeobj_from_type_name IS INSTANCE OF cl_abap_enumdescr.
                INSERT |{ tabix_type_names } Is instance of cl_abap_enumdescr| INTO TABLE str_tab.
              ENDIF.
            WHEN TYPE cl_abap_complexdescr.
              INSERT |{ tabix_type_names } Is instance of cl_abap_complexdescr| INTO TABLE str_tab.
              CASE TYPE OF typdeobj_from_type_name.
                WHEN TYPE cl_abap_structdescr.
                  INSERT |{ tabix_type_names } Is instance of cl_abap_demo_structdescr| INTO TABLE str_tab.
                WHEN TYPE cl_abap_tabledescr.
                  INSERT |{ tabix_type_names } Is instance of cl_abap_tabledescr| INTO TABLE str_tab.
              ENDCASE.
            WHEN TYPE cl_abap_refdescr.
              INSERT |{ tabix_type_names } Is instance of cl_abap_refdescr| INTO TABLE str_tab.
          ENDCASE.
        WHEN TYPE cl_abap_objectdescr.
          INSERT |{ tabix_type_names } Is instance of cl_abap_objectdescr| INTO TABLE str_tab.
          CASE TYPE OF typdeobj_from_type_name.
            WHEN TYPE cl_abap_classdescr.
              INSERT |{ tabix_type_names } Is instance of cl_abap_classdescr| INTO TABLE str_tab.
            WHEN TYPE cl_abap_intfdescr.
              INSERT |{ tabix_type_names } Is instance of cl_abap_intfdescr| INTO TABLE str_tab.
          ENDCASE.
      ENDCASE.
      INSERT `-----------------------------------` INTO TABLE str_tab.
    ENDLOOP.
    out->write( |\n*************************************************************\n\n| ).
    out->write( str_tab ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `55) RTTC: Dynamically Creating Data Types at Runtime` ) ).

    "You can create data types at program runtime using methods of the type
    "description classes of RTTS. These types are only valid locally in the
    "program. They are also anonymous, i.e. they are only accessible through
    "type description objects. As shown above, you can get a reference to a
    "type description object of a type using the static methods of the class
    "CL_ABAP_TYPEDESCR. The focus here is on using RTTC methods such as get*.

    "Creating type description objects using ...
    "... elementary data types
    "Conceptually, all elementary, built-in ABAP types already exist and can
    "be accessed by the corresponding get_* methods.
    "In ADT, click CTRL + space after cl_abap_elemdescr=>... to check out the options.
    "The following examples show a selection.
    DATA(tdo_elem_i) = cl_abap_elemdescr=>get_i( ).
    DATA(tdo_elem_string) = cl_abap_elemdescr=>get_string( ).
    "For the length specification of type c, there is an importing parameter available.
    DATA(tdo_elem_c_l20) = cl_abap_elemdescr=>get_c( 10 ).
    "Type p with two parameters to be specified.
    DATA(tdo_elem_p) = cl_abap_elemdescr=>get_p( p_length = 3 p_decimals = 2 ).

    "Instead of calling get_i() and others having no importing parameters, you could also call
    "the describe_by_name( ) method and pass the type names (I‚ STRING etc.) as arguments.
    "DATA(tdo_elem_i_2) = CAST cl_abap_elemdescr(
    "  cl_abap_typedescr=>describe_by_name( 'I' ) ).
    "DATA(tdo_elem_string_2) = CAST cl_abap_elemdescr(
    "  cl_abap_typedescr=>describe_by_name( 'STRING' ) ).

    "... structured data types
    "They are created based on a component description table.

    "A structured type such as the following shall be created using a
    "type description object.
    TYPES:
      BEGIN OF demo_struc_type,
        a TYPE string,
        b TYPE i,
        c TYPE c LENGTH 5,
        d TYPE p LENGTH 4 DECIMALS 3,
      END OF demo_struc_type.

    "Creating a type description object using RTTC method
    "Using the get method, you can create the type description object
    "dynamically based on a component table. The component table is of type
    "abap_component_tab. In this example, the component table is created inline.
    DATA(tdo_struc) = cl_abap_structdescr=>get(
        VALUE #(
          ( name = 'A' type = cl_abap_elemdescr=>get_string( ) )
          ( name = 'B' type = cl_abap_elemdescr=>get_i( ) )
          ( name = 'C' type = cl_abap_elemdescr=>get_c( 5 ) )
          ( name = 'D' type = cl_abap_elemdescr=>get_p( p_length = 4 p_decimals = 3 ) ) ) ).

    "... internal table types
    "Note: Specifying the line type is mandatory, the rest is optional.

    "An internal table type such as the following shall be created using a
    "type description object.
    TYPES std_tab_type_std_key TYPE STANDARD TABLE OF string WITH DEFAULT KEY.

    "Creating a type description object using RTTC method
    "Not specifying the other optional parameters means that the
    "default values are used, for example, standard table is the
    "default value for p_table_kind.
    DATA(tdo_tab_1) = cl_abap_tabledescr=>get(
            p_line_type  = cl_abap_elemdescr=>get_string( ) ).

    "Another internal table type for which more parameter specifications are needed
    "The following internal table type shall be created using a type description object.
    TYPES so_table_type TYPE SORTED TABLE OF zdemo_abap_flsch WITH UNIQUE KEY carrid connid.

    "Creating a type description object using RTTC method
    "The following example also demonstrates how comfortably constructor
    "operators can be used at these positions.
    DATA(tdo_tab_2) = cl_abap_tabledescr=>get(
            p_line_type  = CAST cl_abap_structdescr( cl_abap_tabledescr=>describe_by_name( 'ZDEMO_ABAP_FLSCH' ) )
            p_table_kind = cl_abap_tabledescr=>tablekind_sorted
            p_key        = VALUE #( ( name = 'CARRID' ) ( name = 'CONNID' ) )
            p_unique     = cl_abap_typedescr=>true ).

    " ... reference types
    "Reference types such as the following shall be created using a
    "type description object.
    TYPES some_ref_type2t TYPE REF TO t.
    TYPES some_ref_type2cl TYPE REF TO zcl_demo_abap_dynamic_prog.

    "Using RTTC methods
    "You can create a reference type from a base type. This base type
    "may be class, interface or data type.
    DATA(tdo_ref_1) = cl_abap_refdescr=>get( cl_abap_elemdescr=>get_t( ) ).
    DATA(tdo_ref_2) = cl_abap_refdescr=>get( cl_abap_typedescr=>describe_by_name( 'ZCL_DEMO_ABAP_DYNAMIC_PROG' ) ).
    "Alternative: get_by_name method
    DATA(tdo_ref_3) = cl_abap_refdescr=>get_by_name( 'T' ).
    DATA(tdo_ref_4) = cl_abap_refdescr=>get_by_name( 'ZCL_DEMO_ABAP_DYNAMIC_PROG' ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `56) Dynamically Creating Data Objects at Runtime Using Type Description Objects (1) - Miscellaneous` ) ).

    "Using the TYPE HANDLE addition to CREATE DATA statements, you can
    "dynamically create data objects at runtime based on type description objects.
    "The following example uses type description objects from the previous example.
    "For output purposes, the created data objects are assigned values.

    DATA dref_typ_obj TYPE REF TO data.

    "Elementary data object
    CREATE DATA dref_typ_obj TYPE HANDLE tdo_elem_i.
    dref_typ_obj->* = 5 + 4.

    out->write( data = dref_typ_obj->* name = `dref_typ_obj->*` ).
    out->write( |\n| ).

    "Structured data object
    CREATE DATA dref_typ_obj TYPE HANDLE tdo_struc.
    dref_typ_obj->('A') = `hello`.
    dref_typ_obj->('B') = 4 + 3.
    dref_typ_obj->('C') = 'abcde'.
    dref_typ_obj->('D') = '1.234'.

    out->write( data = dref_typ_obj->* name = `dref_typ_obj->*` ).
    out->write( |\n| ).

    "Internal table
    CREATE DATA dref_typ_obj TYPE HANDLE tdo_tab_2.
    SELECT * FROM zdemo_abap_flsch INTO TABLE @dref_typ_obj->* UP TO 3 ROWS.

    out->write( data = dref_typ_obj->* name = `dref_typ_obj->*` ).
    out->write( |\n| ).

    "Reference
    CREATE DATA dref_typ_obj TYPE HANDLE tdo_ref_3.
    dref_typ_obj->* = NEW t( '120000' ).

    out->write( data = dref_typ_obj->* name = `dref_typ_obj->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `57) Dynamically Creating Data Objects at Runtime Using Type Description Objects (2) - Structure` ) ).

    "This example includes the dynamic definition of a structure with three components
    "using the GET method of the CL_ABAP_STRUCTDESCR class.

    DATA: struct_type TYPE REF TO cl_abap_structdescr,
          dref_struc  TYPE REF TO data.

    DATA column1 TYPE c LENGTH 5.
    DATA column2 TYPE c LENGTH 5.
    DATA column3 TYPE c LENGTH 5.

    "Potential component names
    DATA(comp_names) = VALUE string_table( ( `A` ) ( `B` ) ( `C` ) ( `D` ) ( `E` ) ( `F` ) ).

    "The structure should contain 3 components.
    DO 3 TIMES.

      "Getting a random integer that represents the table index
      "The line (the component name) is deleted from the table so as to
      "guarantee unique component names.
      DATA(num) = cl_abap_random_int=>create(
               seed = cl_abap_random=>seed( ) min = 1
                                              max = lines( comp_names ) )->get_next( ).
      CASE sy-index.
        WHEN 1.
          column1 = comp_names[ num ].
        WHEN 2.
          column2 = comp_names[ num ].
        WHEN 3.
          column3 = comp_names[ num ].
      ENDCASE.

      DELETE comp_names INDEX num.

    ENDDO.

    "All components should be typed with c length 3
    struct_type = cl_abap_structdescr=>get(
              VALUE #(
                ( name = column1 type = cl_abap_elemdescr=>get_c( 3 ) )
                ( name = column2 type = cl_abap_elemdescr=>get_c( 3 ) )
                ( name = column3 type = cl_abap_elemdescr=>get_c( 3 ) ) ) ).

    "Creating structured data object
    CREATE DATA dref_struc TYPE HANDLE struct_type.

    "Assigning values to the structure components
    dref_struc->(column1) = 'abc'.
    dref_struc->(column2) = 'def'.
    dref_struc->(column3) = 'ghi'.

    out->write( data = dref_struc->* name = `dref_struc->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `58) Dynamically Creating Data Objects at Runtime Using Type Description Objects (3) - Internal Table` ) ).

    "In the example an internal table type is created based on a DDIC type.
    "See the comments in the code.

    "Retrieving table name
    DATA(table_name) = lcl_det_at_runtime=>get_dyn_table_name( ).

    "Retrieving type information using RTTI
    DATA(st) =  CAST cl_abap_structdescr(
            cl_abap_tabledescr=>describe_by_name( table_name ) ).

    "Declaring an internal table to hold the components;
    "it will include the component name and the component type
    DATA comp_table TYPE cl_abap_structdescr=>component_table.

    "Looping across the retrieved field list to extract information
    "In principle, you could also just use method get_components( ) :)
    LOOP AT st->components ASSIGNING FIELD-SYMBOL(<field>).

      "Adding name of the component and its type, which is retrieved using the
      "get_component_type method, are added to the internal table that holds the components
      APPEND VALUE #( name = <field>-name
                      type = st->get_component_type( <field>-name ) ) TO comp_table.

      "The SELECT statement further down includes a dynamic specification
      "of the ORDER BY clause.
      "In this case, just using the second field since MANDT is the first.
      IF sy-tabix = 2.
        DATA(dyn_order_by) = <field>-name.
      ENDIF.

    ENDLOOP.

    "Creating an internal table type
    "Note: The parameter p_key is not filled here, i. e. the default key is used.
    DATA(itab_type) = cl_abap_tabledescr=>create(
        p_line_type  = st
        p_table_kind = cl_abap_tabledescr=>tablekind_sorted
        p_unique     = cl_abap_typedescr=>true ).

    "Creating an internal table based on the created table type
    DATA ref_tab TYPE REF TO data.
    CREATE DATA ref_tab TYPE HANDLE itab_type.

    "Filling an internal table
    SELECT *
      FROM (table_name)
      ORDER BY (dyn_order_by)
      INTO CORRESPONDING FIELDS OF TABLE @ref_tab->*
      UP TO 3 ROWS.

    out->write( |Type/Database table name determined at runtime: { table_name }| ).
    out->write( |\n| ).
    out->write( |Internal table entries (ordered by { dyn_order_by }):| ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = ref_tab->* name = `ref_tab->*` ).

  ENDMETHOD.""",
    r"""METHOD inst_meth1.
    ... "No implementation added
  ENDMETHOD.

  METHOD inst_meth2.
    result = to_upper( text ).
  ENDMETHOD.

  METHOD stat_meth1.
    ... "No implementation added
  ENDMETHOD.

  METHOD stat_meth2.
    result = to_upper( text ).
  ENDMETHOD.""",
    r"""CLASS lcl_det_at_runtime DEFINITION.

  PUBLIC SECTION.

    CLASS-DATA: string1              TYPE string,
                string2              TYPE string,
                string3              TYPE string,
                dyn_meth_call_result TYPE string.

    TYPES: type_p     TYPE p LENGTH 8 DECIMALS 2, "elementary type
           type_struc TYPE zdemo_abap_carr, "structure type
           "internal table type
           type_itab  TYPE SORTED TABLE OF zdemo_abap_flsch WITH NON-UNIQUE KEY carrid connid                         "primary key
                                                            WITH UNIQUE SORTED KEY cities COMPONENTS cityfrom cityto, "secondary key
           type_ref   TYPE REF TO lcl_det_at_runtime. "reference type

    TYPES: BEGIN OF struc_builtin,
             builtin_type TYPE c LENGTH 10,
             len          TYPE i,
             dec          TYPE i,
           END OF struc_builtin.

    TYPES: BEGIN OF struc_dyn,
            table        TYPE string,
            select_list  TYPE string,
            where_clause TYPE string_table,
            order_by     TYPE string,
            target       TYPE REF TO data,
            rows         TYPE i,
          END OF struc_dyn.

    CLASS-METHODS:
      get_dyn_table_name RETURNING VALUE(tab) TYPE string,
      get_dyn_dobj RETURNING VALUE(dobj) TYPE string,
      get_dyn_field RETURNING VALUE(field) TYPE string,
      get_dyn_select_list RETURNING VALUE(list) TYPE string,
      get_dyn_where_clause RETURNING VALUE(clause_tab) TYPE string_table,
      get_random_type RETURNING VALUE(random_type) TYPE string,
      get_builtin_type RETURNING VALUE(builtin_type) TYPE struc_builtin,
      get_dyn_class_meth EXPORTING cl   TYPE string
                                   meth TYPE string
                                   ptab TYPE abap_parmbind_tab,
      get_dyn_syntax_elements RETURNING VALUE(syntax_elements) TYPE struc_dyn,
      fill_string.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS lcl_det_at_runtime IMPLEMENTATION.
  METHOD get_dyn_table_name.

    "Providing DDIC table names in a string table to be selected from.
    DATA(flight_tables) = VALUE string_table(
     ( `ZDEMO_ABAP_CARR` ) ( `ZDEMO_ABAP_FLSCH` ) ( `ZDEMO_ABAP_FLI` ) ).

    "Getting random number to determine the table index at runtime.
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( flight_tables ) )->get_next( ).

    "Returning parameter to receive the random table name.
    tab = VALUE #( flight_tables[ idx ] DEFAULT `ZDEMO_ABAP_CARR`  ).

  ENDMETHOD.

  METHOD get_builtin_type.

    "Providing the names of built-in types in a string table to be selected from.
    TYPES tabtyp TYPE TABLE OF struc_builtin-builtin_type WITH EMPTY KEY.

    DATA(built) = VALUE tabtyp(
     ( 'd' )
     ( 'decfloat16' )
     ( 'decfloat34' )
     ( 'f' )
     ( 'i' )
     ( 'string' )
     ( 't' )
     ( 'xstring' )
     ( 'c' )
     ( 'n' )
     ( 'x' )
     ( 'p' )
     ).

    "Getting random number to determine the table index at runtime
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( built ) )->get_next( ).

    "Providing the returning parameter with a random type name
    TRY.
        builtin_type = VALUE #( builtin_type = built[ idx ] dec = idx len = idx ).
      CATCH cx_sy_itab_line_not_found.
        builtin_type = VALUE #( builtin_type = `p` dec = 5 len = 5 ).
    ENDTRY.

  ENDMETHOD.

  METHOD get_dyn_dobj.

    "Providing strings with demo content
    string1 = |Hallo, { sy-uname }. | &&
              |This is string1.|.
    string2 = |Hallo, { sy-uname }. | &&
              |This is string2.|.
    string3 = |Hallo, { sy-uname }. | &&
              |This is string3.|.

    "Filling table with data object names
    DATA(str_tab) = VALUE string_table(
      ( `STRING1` ) ( `STRING2` ) ( `STRING3` ) ).

    "Getting random number to determine the table index at runtime
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( str_tab ) )->get_next( ).

    "Providing the returning parameter with a random data object name
    dobj = VALUE #( str_tab[ idx ] DEFAULT |Hallo, { sy-uname }. This is a string.| ).

  ENDMETHOD.

  METHOD get_dyn_field.

    "Getting list of components of DDIC type zdemo_abap_carr
    DATA(comp) = CAST cl_abap_structdescr(
                        cl_abap_typedescr=>describe_by_name(
                          'ZDEMO_ABAP_CARR' )
                            )->components.

    "Getting random number to determine the table index at runtime;
    "starting from 2 to exclude MANDT field
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 2
                                     max = lines( comp ) )->get_next( ).

    "Providing the returning parameter with a random component name
    field = VALUE #( comp[ idx ]-name DEFAULT `CARRID`  ).

  ENDMETHOD.

  METHOD get_dyn_select_list.

    "Providing SELECT lists in a string table to be selected from
    DATA sel_list_tab TYPE string_table.
    sel_list_tab = VALUE #(
      ( `CARRID, CONNID, COUNTRYFR, COUNTRYTO` )
      ( `CARRID, CONNID, CITYFROM, CITYTO` )
      ( `CARRID, CONNID, AIRPFROM, AIRPTO` )
      ( `CARRID, CONNID, AIRPFROM, AIRPTO, ` &&
        `FLTIME, DEPTIME, ARRTIME, DISTANCE` )
     ).

    "Getting random number to determine the table index at runtime
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( sel_list_tab ) )->get_next( ).

    "Providing the returning parameter with a random SELECT list
    list = VALUE #( sel_list_tab[ idx ] DEFAULT `CARRID, CONNID, COUNTRYFR, COUNTRYTO`  ).

  ENDMETHOD.

  METHOD get_dyn_where_clause.

    "Providing WHERE clauses in a table to be selected from
    DATA: BEGIN OF where_struc,
            where_clause_tab TYPE string_table,
          END OF where_struc.

    DATA where_itab LIKE TABLE OF where_struc WITH EMPTY KEY.

    where_itab = VALUE #(
      ( where_clause_tab = VALUE #( ( `CARRID = 'LH'` )
                                    ( `OR CARRID = 'AA'` ) ) )
      ( where_clause_tab = VALUE #( ( `CONNID BETWEEN 0 AND 300` ) ) )
      ( where_clause_tab = VALUE #( ( `CITYFROM LIKE '%FRA%'` ) ) )
      ( where_clause_tab =
          VALUE #( ( `DISTANCE > 500 AND DISTID = 'KM'` ) ) )  ).

    "Getting random number to determine the table index at runtime
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( where_itab ) )->get_next( ).

    "Providing the returning parameter with a random WHERE clause
    clause_tab = VALUE #( where_itab[ idx ]-where_clause_tab DEFAULT VALUE #( ( `CARRID = 'LH'` ) ( `OR CARRID = 'AA'` ) )  ).

  ENDMETHOD.

  METHOD get_random_type.

    "Providing names of classes in a string table to be selected from
    "In this example, some types are defined in the public section
    "of a local class. The class name is added here since the names
    "are used in the global class.
    DATA(str_tab) = VALUE string_table(
      ( `LCL_DET_AT_RUNTIME=>TYPE_P` )
      ( `LCL_DET_AT_RUNTIME=>TYPE_STRUC` )
      ( `LCL_DET_AT_RUNTIME=>TYPE_ITAB` )
      ( `LCL_DET_AT_RUNTIME=>TYPE_REF` )
      ( `LCL_DET_AT_RUNTIME` )
      ( `IF_OO_ADT_CLASSRUN` )
      ).

    "Getting random number to determine the table index at runtime
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( str_tab ) )->get_next( ).

    "Providing the returning parameter with a random type name
    random_type = VALUE #( str_tab[ idx ] DEFAULT `LCL_DET_AT_RUNTIME=>TYPE_STRUC` ).

  ENDMETHOD.

  METHOD get_dyn_class_meth.

    "Providing class names in a string table to be selected from
    DATA(class_tab) = VALUE string_table(
      ( `LCL_DEMO1` )
      ( `LCL_DEMO2` ) ).

    "Getting random number to determine the table index at runtime
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( class_tab ) )->get_next( ).

    "Provide the exporting parameter with the random class name
    cl = VALUE #( class_tab[ idx ] DEFAULT `LCL_DEMO1` ).

    "Getting method names using RTTI
    DATA(methods) = CAST cl_abap_classdescr( cl_abap_typedescr=>describe_by_name( cl ) )->methods.

    "Getting random number to determine the table index at runtime
    idx = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( methods ) )->get_next( ).

    "Provide the exporting parameter with the random method name
    meth = VALUE #( methods[ idx ]-name DEFAULT `METH_A` ).

    "Data reference objects for the value parameter in the parameter table
    DATA(ref_imp) = NEW string( `hi` ).
    DATA(ref_exp) = NEW string( `hallo` ).
    DATA(ref_ch) = NEW string( `salut` ).
    DATA(ref_ret) = NEW string( `ciao` ).

    "Filling the parameter tables
    "Note: If the method signature has an importing parameter,
    "it must be specified as exporting parameter here.
    "Same is true for the exporting parameter in the signature
    "that must be specified as importing parameter.

    CASE meth.

      WHEN `METH_A`.

        ptab = VALUE #( ( name  = 'A'
                          kind  = cl_abap_objectdescr=>exporting
                          value = ref_exp )
                        ( name  = 'B'
                          kind  = cl_abap_objectdescr=>importing
                          value = ref_imp ) ).

      WHEN `METH_B`.

        ptab = VALUE #( ( name  = 'C'
                          kind  = cl_abap_objectdescr=>changing
                          value = ref_ch )
                        ( name  = 'D'
                          kind  = cl_abap_objectdescr=>returning
                          value = ref_ret ) ).

      WHEN `METH_C`.

        ptab = VALUE #( ( name  = 'E'
                          kind  = cl_abap_objectdescr=>exporting
                          value = ref_exp )
                        ( name  = 'F'
                          kind  = cl_abap_objectdescr=>importing
                          value = ref_imp ) ).

      WHEN `METH_D`.

        ptab = VALUE #( ( name  = 'G'
                          kind  = cl_abap_objectdescr=>changing
                          value = ref_ch )
                        ( name  = 'H'
                          kind  = cl_abap_objectdescr=>returning
                          value = ref_ret ) ).

    ENDCASE.

  ENDMETHOD.

  METHOD fill_string.
    dyn_meth_call_result = |Hallo { sy-uname }. The string was filled at { utclong_current( ) }.|.
  ENDMETHOD.

  METHOD get_dyn_syntax_elements.

    "FROM clause
    DATA(flight_tables) = VALUE string_table(
         ( `ZDEMO_ABAP_CARR` ) ( `ZDEMO_ABAP_FLSCH` ) ( `ZDEMO_ABAP_FLI` ) ).

    "Getting random number to determine the table index at runtime.
    DATA(idx_table) = cl_abap_random_int=>create(
          seed = cl_abap_random=>seed( )
          min  = 1
          max  = lines( flight_tables ) )->get_next( ).

    syntax_elements-table = VALUE #( flight_tables[ idx_table ] DEFAULT `ZDEMO_ABAP_CARR`  ).

    "SELECT list
    DATA(comp) = CAST cl_abap_structdescr(
      cl_abap_typedescr=>describe_by_name( syntax_elements-table ) )->components.

    "At least 3 components
    DATA(idx_comp) = cl_abap_random_int=>create(
          seed = cl_abap_random=>seed( )
          min  = 3
          max  = lines( comp ) )->get_next( ).

    DELETE comp FROM idx_comp + 1 TO lines( comp ).

    LOOP AT comp ASSIGNING FIELD-SYMBOL(<comp>).
      syntax_elements-select_list = syntax_elements-select_list && `, ` && <comp>-name.
    ENDLOOP.

    "Replacing initial comma
    REPLACE PCRE `^,\s` IN syntax_elements-select_list WITH ``.

    "WHERE clause
    "Excluding the client field
    DELETE comp WHERE name = 'MANDT'.

    "A maximum of 4 fields are to be respected because that is the maximum of possible fields
    "available in table zdemo_abap_carr (without the client field)
    DATA(idx_where) = cl_abap_random_int=>create(
          seed = cl_abap_random=>seed( )
          min  = 1
          max  = 4 )->get_next( ).

    "In the example, the WHERE clause consists of an internal table of type string.
    "The clause is set up with fields and only IS NOT INITIAL to be on the safe side for a
    "somewhat 'meaningful' clause and in the interest of simplicity.
    LOOP AT comp ASSIGNING FIELD-SYMBOL(<where>) TO idx_where.
      IF sy-tabix = 1.
        APPEND <where>-name && ` IS NOT INITIAL` TO syntax_elements-where_clause.
      ELSE.
        APPEND `OR ` && <where>-name && ` IS NOT INITIAL` TO syntax_elements-where_clause.
      ENDIF.
    ENDLOOP.

    "ORDER BY clause
    DATA(idx_order) = cl_abap_random_int=>create(
          seed = cl_abap_random=>seed( )
          min  = 1
          max  = lines( comp ) )->get_next( ).

    syntax_elements-order_by = VALUE #( comp[ idx_order ]-name DEFAULT `CARRID`  ).

    "INTO clause
    CREATE DATA syntax_elements-target TYPE TABLE OF (syntax_elements-table).

    "UP TO ... ROWS
    "A minimum of 2 and a maximum of 6 rows are to be retrieved by the SELECT statement
    syntax_elements-rows = cl_abap_random_int=>create(
            seed = cl_abap_random=>seed( )
            min  = 2
            max  = 5 )->get_next( ).

  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_demo1 DEFINITION.
"Note that this is just a demo class with demo methods to work with in the example.
  PUBLIC SECTION.

    CLASS-METHODS:
      meth_a IMPORTING a TYPE string
             EXPORTING b TYPE string,
      meth_b CHANGING  c        TYPE string
             RETURNING VALUE(d) TYPE string.

ENDCLASS.""",
    r"""CLASS lcl_demo1 IMPLEMENTATION.
  METHOD meth_a.
    b = |Hallo from meth_a. '{ a }' was input.|.

    "Filling an attribute for the output in the global class.
    lcl_det_at_runtime=>dyn_meth_call_result = b.
  ENDMETHOD.

  METHOD meth_b.
    c = `#` && c && `#`.
    d = |Hallo from meth_b. Actual parameter of changing parameter: '{ c }'|.

    "Filling an attribute for the output in the global class.
    lcl_det_at_runtime=>dyn_meth_call_result = d.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_demo2 DEFINITION.
"Note that this is just a demo class with demo methods to work with in the example.
  PUBLIC SECTION.

    CLASS-METHODS:
      meth_c IMPORTING e TYPE string
             EXPORTING f TYPE string,
      meth_d CHANGING  g        TYPE string
             RETURNING VALUE(h) TYPE string.

ENDCLASS.""",
    r"""CLASS lcl_demo2 IMPLEMENTATION.
  METHOD meth_c.
    f = |Hallo from meth_c. '{ e }' was input.|.

    "Filling an attribute for the output in the global class.
    lcl_det_at_runtime=>dyn_meth_call_result = f.
  ENDMETHOD.

  METHOD meth_d.
    g = `*` && g && `*`.
    h = |Hallo from meth_d. Actual parameter of changing parameter: '{ g }'|.

    "Filling an attribute for the output in the global class.
    lcl_det_at_runtime=>dyn_meth_call_result = h.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_error_handling DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.

    CLASS-METHODS meth_a
      IMPORTING num TYPE i
      RAISING   zcx_demo_abap_error_a.

    CLASS-METHODS meth_b
      IMPORTING num TYPE i
      RAISING   zcx_demo_abap_error_b.

    CLASS-METHODS meth_resumable
      IMPORTING num1              TYPE i
                num2              TYPE i
      RETURNING VALUE(div_result) TYPE string
      RAISING   RESUMABLE(zcx_demo_abap_error_b).

    CLASS-METHODS divide
      IMPORTING num1              TYPE i
                num2              TYPE i
      RETURNING VALUE(div_result) TYPE decfloat34
      RAISING   cx_sy_zerodivide.

    CLASS-METHODS get_uuid
      RETURNING VALUE(uuid) TYPE sysuuid_x16
      RAISING   cx_uuid_error.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_error_handling IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: Exceptions and Runtime Errors\n\n| ).
    out->write( `1) Exception Categories` ).

    "Method specifying an exception class that inherits from CX_DYNAMIC_CHECK

    "No explicit exception handling required
    "The following statement does not show a syntax warning.
    DATA(div_result1) = divide( num1 = 5 num2 = 2 ).
    out->write( data = div_result1 name = `div_result1` ).

    TRY.
        DATA(div_result2) = divide( num1 = 5 num2 = 0 ).
      CATCH cx_sy_zerodivide.
        out->write( `Exception caught` ).
    ENDTRY.

    "Method specifying an exception class that inherits from CX_STATIC_CHECK

    "Explicit exception handling required
    "The following statement (commented in) shows a syntax warning.
    "DATA(uuid1) = get_uuid( ).

    TRY.
        DATA(uuid2) = get_uuid( ).
      CATCH cx_uuid_error.
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Raising Class-Based Exceptions` ) ).

    "Note: The examples show a selection. More additions are available.
    "Some are demonstrated further down.

    "RAISE EXCEPTION statements

    "RAISE EXCEPTION statement with the TYPE addition, specifying
    "the name of a visible exception class; an exception
    "object is created (if necessary, see the ABAP Keyword Documentation
    "for more details)
    TRY.
        RAISE EXCEPTION TYPE cx_sy_zerodivide.
      CATCH cx_sy_zerodivide.
    ENDTRY.

    "RAISE EXCEPTION statement specifying an exception object (an object
    "reference variable pointing to an exception class)
    DATA(exc) = NEW cx_sy_zerodivide( ).
    TRY.
        RAISE EXCEPTION exc.
      CATCH cx_sy_zerodivide.
    ENDTRY.

    "Creating an exception object inline using the NEW operator
    TRY.
        RAISE EXCEPTION NEW cx_sy_zerodivide( ).
      CATCH cx_sy_zerodivide.
    ENDTRY.

    "Note: Instances of abstract classes cannot be created. So, the
    "following statements are not possible.
    "RAISE EXCEPTION NEW cx_sy_arithmetic_error( ).
    "RAISE EXCEPTION NEW cx_static_check( ).
    "RAISE EXCEPTION NEW cx_dynamic_check( ).
    "RAISE EXCEPTION NEW cx_no_check( ).
    "RAISE EXCEPTION NEW cx_root( ).

    "Dynamic creation of an exception object with CREATE OBJECT
    DATA dyn_exc TYPE REF TO cx_root.
    CREATE OBJECT dyn_exc TYPE ('CX_SY_ZERODIVIDE').
    TRY.
        RAISE EXCEPTION dyn_exc.
      CATCH cx_root.
    ENDTRY.

    "COND/SWITCH operators with THROW addition
    "THROW addition in conditional expressions with the COND and SWITCH operators
    "enabling raising class-based exceptions in operand positions
    "The addition works like RAISE EXCEPTION TYPE statements.

    "COND operator
    DATA(int1) = 1.
    DATA(int2) = 0.
    "The example considers ABAP "allowing" zero division when both operands are 0.
    TRY.
        DATA(res1) = COND decfloat34( WHEN ( int1 <> 0 AND int2 <> 0 ) OR ( int1 = 0 AND int2 <> 0 ) THEN int1 / int2
                                      ELSE THROW cx_sy_zerodivide( ) ).
      CATCH cx_sy_zerodivide.
    ENDTRY.

    "SWITCH operator
    "The following example shows SWITCH with the THROW addition
    "and uses cx_sy_zerodivide for demonstration purposes.
    DO.
      TRY.
          DATA(num) = SWITCH #( sy-index
                                WHEN 1 THEN `one`
                                WHEN 2 THEN `two`
                                WHEN 3 THEN `three`
                                WHEN 4 THEN `four`
                                ELSE THROW cx_sy_zerodivide( ) ).
          out->write( num ).
        CATCH cx_sy_zerodivide.
          out->write( `Exception caught` ).
          EXIT.
      ENDTRY.
    ENDDO.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Excursions with TRY control structures` ) ).

    "TRY control structures are meant for handling catchable exceptions locally
    "The example shows divisions. The predefined exception class cx_sy_zerodivide
    "as suitable exception class is used.
    "If the exception is not handled, the program is terminated and the runtime
    "error COMPUTE_INT_ZERODIVIDE occurs.
    "The third calculation is not carried out because the statement block is
    "left due to the previous erroneous 0 division.

    TRY.
        DATA(div1) = 4 / 2.
        out->write( data = div1 name = `div1` ).
        out->write( |\n| ).

        DATA(div2) = 4 / 0.
        out->write( data = div2 name = `div2` ).
        out->write( |\n| ).

        DATA(div3) = 9 / 3.
        out->write( data = div3 name = `div3` ).
        out->write( |\n| ).

      CATCH cx_sy_zerodivide.
        out->write( `0 division. The exception was caught.` ).
        out->write( |\n| ).
    ENDTRY.

    "It is possible to specify multiple exception classes in a list and
    "multiple CATCH blocks.
    "Note: If there are multiple CATCH blocks for exceptions that are in an inheritance
    "relationship, you must pay attention that the more special exceptions are specified
    "before the more general ones.
    "The calculation example shows multiple CATCH blocks that themselves have more than
    "one exception class specified. Here, local exception classes are specified just for
    "demonstration purposes. They are not relevant in this TRY control structure.

    DATA int_itab TYPE TABLE OF i WITH EMPTY KEY.

    "Filling internal table of type i as basis for calculations
    int_itab = VALUE #( ( 5 ) ( 0 ) ( 987654321 ) ).

    LOOP AT int_itab ASSIGNING FIELD-SYMBOL(<fs_int>).
      TRY.
          out->write( |--- Calculations with { <fs_int> } ---| ).
          DATA(calc1) = CONV decfloat34( 1 / <fs_int> ).
          out->write( data = calc1 name = `calc1` ).
          out->write( |\n| ).
          DATA(calc2) = ipow( base = <fs_int> exp = 2 ).
          out->write( data = calc2 name = `calc2` ).
          out->write( |\n| ).
        CATCH cx_sy_arithmetic_overflow .
          out->write( `Arithmetic overflow. The exception was caught.` ).
        CATCH cx_sy_zerodivide .
          out->write( `0 division. The exception was caught.` ).
      ENDTRY.
      out->write( |\n| ).
    ENDLOOP.

    "The following example shows a catchable exception that is
    "raised if a line is not found when using table expressions.
    DATA(str_table) = VALUE string_table(  ).
    TRY.
        DATA(line_tab) = str_table[ 12345 ].

        "The predefined exception class cx_sy_itab_line_not_found
        "as suitable exception class is used here.
        "If the exception is not handled, the program is terminated
        "and the runtime error ITAB_LINE_NOT_FOUND occurs.
      CATCH cx_sy_itab_line_not_found.
        out->write( `The line was not found. The exception was caught.` ).
    ENDTRY.

    "In the following CATCH block, the predefined exception class cx_sy_arithmetic_error
    "is specified. Both cx_sy_zerodivide and cx_sy_arithmetic_overflow are derived from
    "cx_sy_arithmetic_error which is an exception class higher up in the inheritance
    "tree. Hence, cx_sy_arithmetic_error can be specified and handle both exceptions, too.
    "The following example is basically the same as above. However, only one exception
    "class is specified.

    LOOP AT int_itab ASSIGNING FIELD-SYMBOL(<fs_int_inh>).
      TRY.
          out->write( |--- Calculations with { <fs_int_inh> } ---| ).
          calc1 = 1 / <fs_int_inh>.
          out->write( data = calc1 name = `calc1` ).
          out->write( |\n| ).
          calc2 = ipow( base = <fs_int_inh> exp = 2 ).
          out->write( data = calc2 name = `calc2` ).
          out->write( |\n| ).
        CATCH cx_sy_arithmetic_error.
          out->write( `Arithmetic error. The exception was caught.` ).
      ENDTRY.
      out->write( |\n| ).
    ENDLOOP.

    "Example demonstrating the exception root class cx_root specifying after CATCH to
    "catch all catchable exception.
    DO 3 TIMES.
      TRY.
          CASE sy-index.
            WHEN 1.
              RAISE EXCEPTION TYPE cx_sy_zerodivide.
            WHEN 2.
              RAISE EXCEPTION TYPE cx_uuid_error.
            WHEN 3.
              RAISE EXCEPTION TYPE cx_sy_itab_line_not_found.
          ENDCASE.
        CATCH cx_root.
          "Instead of explicit specification of potential exception classes involved
          "CATCH cx_sy_zerodivide cx_uuid_error cx_sy_itab_line_not_found.
      ENDTRY.
    ENDDO.

    "Evaluating exception information (get_text method)

    "You can use the addition INTO plus an object reference variable to store
    "a reference to an exception object. It is, for example, relevant to
    "determine the exact exception.
    "The following example is the same as above using the more general exception
    "class cx_sy_arithmetic_error. You can carry out certain tasks, for
    "example, retrieving and displaying the exception text. To retrieve exception
    "texts, you can call, for example, the method get_text.

    DATA exception TYPE REF TO cx_root.

    LOOP AT int_itab ASSIGNING FIELD-SYMBOL(<fs_int_into>).
      TRY.
          out->write( |--- Calculations with { <fs_int_into> } ---| ).
          calc1 = 1 / <fs_int_into>.
          out->write( data = calc1 name = `calc1` ).
          out->write( |\n| ).
          calc2 = ipow( base = <fs_int_into> exp = 2 ).
          out->write( data = calc2 name = `calc2` ).
          out->write( |\n| ).
        CATCH cx_sy_arithmetic_error INTO exception.
          "Note:
          "- The object reference variable is of type cx_root.
          "- You could also create the variable inline, e. g. ... INTO DATA(exc).

          "Retrieving and displaying exception text
          DATA(exception_text) = exception->get_text( ).

          out->write( data = exception_text name = `exception_text` ).
      ENDTRY.
      out->write( |\n| ).
    ENDLOOP.

    "As above, the following example demonstrates an exception class for
    "arithmetic operations that is higher up in the inheritance tree and
    "catches zero division and arithmetic overflow errors.
    DO 2 TIMES.
      TRY.
          IF sy-index = 1.
            DATA(div) = CONV decfloat34( 1 / 0 ).
          ELSE.
            DATA(powers) = ipow( base = 10 exp = 100 ).
          ENDIF.
        CATCH cx_sy_arithmetic_error INTO DATA(error_arithm).
          DATA(text) = error_arithm->get_text( ).
          "Using RTTI to retrieve the relative name of the class
          DATA(cl_name) = CAST cl_abap_classdescr(
            cl_abap_typedescr=>describe_by_object_ref( error_arithm ) )->get_relative_name( ).

          out->write( text ).
          out->write( cl_name ).
      ENDTRY.
    ENDDO.

    "Demonstrating the instance attribute 'previous' with
    "nested TRY control structures.
    "Consider the following scenario: A method is called and
    "an exception is raised. Once evaluated, another exception
    "is raised, and the previous exception (i.e. a reference to
    "the previous exception object) is passed on to the caller.
    "The caller can then evaluate the exceptions raised.
    "The following example includes nested TRY control structures.
    "In CATCH blocks, further exceptions are raised. There, the
    "exception object is passed. In a WHILE loop, several pieces
    "of information are retrieved, including the use of RTTI.
    "Once the information has been retrieved, the previous attribute
    "is used to assign the previous exception object. Note the cast.

    DATA info TYPE string_table.

    TRY.
        TRY.
            TRY.
                RAISE EXCEPTION NEW cx_sy_zerodivide( ).
              CATCH cx_sy_zerodivide INTO DATA(err1).
                RAISE EXCEPTION NEW cx_sy_arithmetic_overflow( previous = err1 ).
            ENDTRY.
          CATCH cx_sy_arithmetic_overflow INTO DATA(err2).
            RAISE EXCEPTION NEW cx_sy_itab_line_not_found( previous = err2 ).
        ENDTRY.
      CATCH cx_sy_itab_line_not_found INTO DATA(err3).
    ENDTRY.

    DATA(acc_err) = CAST cx_root( err3 ).
    WHILE acc_err IS BOUND.
      DATA(txt) = acc_err->get_text( ).

      acc_err->get_source_position(
        IMPORTING
          program_name = DATA(prog_name)
          include_name = DATA(incl_name)
          source_line  = DATA(src_line) ).

      "Using RTTI to gather more information on the exception
      "See the Dynamic Programming cheat sheet about RTTI.
      DATA(tdo) = CAST cl_abap_classdescr( cl_abap_typedescr=>describe_by_object_ref( acc_err ) ).
      DATA(cl_relative_name) = tdo->get_relative_name( ).
      DATA(attributes) = tdo->attributes.
      DATA(superclass) = tdo->get_super_class_type( )->get_relative_name( ).

      "Populating the info table
      APPEND |--------------- { sy-index } ---------------| TO info.
      APPEND |Text: { txt }| TO info.
      APPEND |Position of raised exception: { prog_name } / { incl_name } / { src_line }| TO info.
      APPEND |Exception class name: { cl_relative_name }| TO info.
      APPEND |Superclass of exception class: { superclass }| TO info.

      "Using the 'previous' attribute to assign the previous exception
      "object
      acc_err = acc_err->previous.
      "If there was no cast to cx_root, a cast would be required here,
      "for example, as follows.
      "acc_err = CAST #( acc_err->previous ).
    ENDWHILE.

    out->write( data = info name = `info` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) CLEANUP` ) ).

    "The following example shows nested TRY control structures.
    "The inner TRY control structure includes a CLEANUP block.
    "The example demonstrates that an exception raised cannot
    "be handled by the TRY control structure where it is raised.
    "No meaningful 'cleanup' action is performed in the example's
    "CLEANUP block. For demonstration purposes, an info table is
    "populated demonstrating the execution of the block.

    DATA info_tab TYPE string_table.
    DATA cleanup TYPE REF TO cx_root.
    DO 2 TIMES.
      APPEND |---- Loop pass { sy-index } ----| TO info_tab.
      TRY.
          TRY.

              IF sy-index = 1.
                DATA(calc) = CONV decfloat34( 1 / 0 ).
              ELSE.
                DATA(strtab) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ).
                DATA(line_4) = strtab[ 4 ].
              ENDIF.

            CATCH cx_sy_zerodivide INTO cleanup.
              APPEND `---- Catching cx_sy_zerodivide ----` TO info_tab.
              APPEND cleanup->get_text( ) TO info_tab.

            CLEANUP.
              APPEND `#### Executing CLEANUP block ####` TO info_tab.
              APPEND `d` TO strtab.

              "CLEANUP block must be executed completely
              "Leaving the block prematurely causes a runtime error. If it is statically known
              "that it is not possible to return to the block, a syntax error is shown.
              "So, the following statement is not allowed in the CLEANUP block.
              "RETURN.
          ENDTRY.
        CATCH cx_sy_itab_line_not_found INTO cleanup.
          APPEND `---- Catching cx_sy_itab_line_not_found ----` TO info_tab.
          APPEND cleanup->get_text( ) TO info_tab.
      ENDTRY.
    ENDDO.

    out->write( data = info_tab name = `info_tab` ).
    out->write( |\n| ).
    out->write( |\n| ).

    "CLEANUP ... INTO
    "The example is the same as above. Here, the CLEANUP statement is specified
    "with the addition INTO. If required, you can evaluate the exception information
    "as shown above.

    DATA info_tab_b TYPE string_table.
    DATA cleanup_b TYPE REF TO cx_root.
    DO 2 TIMES.
      APPEND |---- Loop pass { sy-index } ----| TO info_tab_b.
      TRY.
          TRY.

              IF sy-index = 1.
                DATA(calc_b) = CONV decfloat34( 1 / 0 ).
              ELSE.
                DATA(strtab_b) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ).
                DATA(line_4_b) = strtab_b[ 4 ].
              ENDIF.

            CATCH cx_sy_zerodivide INTO cleanup_b.
              APPEND `---- Catching cx_sy_zerodivide ----` TO info_tab_b.
              APPEND cleanup_b->get_text( ) TO info_tab_b.

            CLEANUP INTO cleanup_b.
              APPEND `#### Executing CLEANUP block ####` TO info_tab_b.
              "Using RTTI to find out the absolute name of the class of the raised execption
              DATA(class_name) = cl_abap_classdescr=>get_class_name( p_object = cleanup_b ).
              APPEND class_name TO info_tab_b.
              APPEND `d` TO strtab_b.

              "CLEANUP block must be executed completely
              "Leaving the block prematurely causes a runtime error. If it is statically known
              "that it is not possible to return to the block, a syntax error is shown.
              "So, the following statement is not allowed in the CLEANUP block.
              "RETURN.
          ENDTRY.
        CATCH cx_sy_itab_line_not_found INTO cleanup_b.
          APPEND `---- Catching cx_sy_itab_line_not_found ----` TO info_tab_b.
          APPEND cleanup_b->get_text( ) TO info_tab_b.
      ENDTRY.
    ENDDO.

    out->write( data = info_tab_b name = `info_tab_b` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) RETRY` ) ).

    "The following example includes a division of 1 by another number.
    "In a DO loop 1 is divided by all numbers from 10 to -10.
    "When the zero division exception is caught, the exception cause is
    "removed by changing the first operand's value to 0, too, before the
    "RETRY statement. The RETRY statement triggers the execution of the TRY
    "control structure again, now resulting in 0 as division result. After
    "that, and to have a self-contained example, the operand value is changed
    "back to 1.
    DATA division_result_tab TYPE TABLE OF decfloat34 WITH EMPTY KEY.
    DATA(number1) = 1.
    DATA(number2) = 11.
    DATA division_result TYPE decfloat34.
    DO.
      number2 -= 1.
      TRY.
          division_result = number1 / number2.
          APPEND division_result TO division_result_tab.
        CATCH cx_sy_zerodivide.
          "Removing the exception cause by setting a value that
          "does not raise the zero division exception
          number1 = 0.
          DATA(retry_flag) = abap_true.
          "Processing the TRY control structure again
          RETRY.
      ENDTRY.

      "Resetting of number1 value to 1
      IF retry_flag = abap_true.
        number1 = 1.
        retry_flag = abap_false.
      ENDIF.

      IF sy-index = 21.
        EXIT.
      ENDIF.
    ENDDO.

    out->write( data = division_result_tab name = `division_result_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) RESUME` ) ).

    DATA restab TYPE string_table.
    TYPES ty_inttab TYPE TABLE OF i WITH EMPTY KEY.
    DATA(inttab) = REDUCE ty_inttab( INIT tab = VALUE ty_inttab( )
                                     FOR  i = -5 UNTIL i > 5
                                     NEXT tab = VALUE #( BASE tab ( i ) ) ).

    LOOP AT inttab INTO DATA(wa).
      TRY.
          DATA(divres) = meth_resumable(
            num1 = sy-tabix
            num2 = wa
          ).
          APPEND |{ sy-tabix } / { wa } = { divres }| TO restab.
        CATCH BEFORE UNWIND zcx_demo_abap_error_b INTO DATA(error_resume).
          DATA(is_resumable) = error_resume->is_resumable.
          IF is_resumable IS NOT INITIAL.
            APPEND |Exception raised. Is resumable? -> "{ is_resumable }"| TO restab.
            RESUME.
          ENDIF.
      ENDTRY.
    ENDLOOP.

    out->write( data = restab name = `restab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) MESSAGE` ) ).

    "The following examples demonstrate several MESSAGE statements.
    TYPES c50 TYPE c LENGTH 50.
    DATA message_attribute_tab TYPE TABLE OF c50 WITH EMPTY KEY.

    MESSAGE e001(zdemo_abap_messages) INTO DATA(msg).

    DATA(msgid) = sy-msgid.
    DATA(msgty) = sy-msgty.

    message_attribute_tab = VALUE #( BASE message_attribute_tab ( msgid ) ( msgty ) ( '--------' ) ).

    MESSAGE e004(zdemo_abap_messages)
            WITH 'A' 'B' 'C' 'D'
            INTO msg.

    msgid = sy-msgid.
    msgty = sy-msgty.
    DATA(msgv1) = sy-msgv1.
    DATA(msgv2) = sy-msgv2.
    DATA(msgv3) = sy-msgv3.
    DATA(msgv4) = sy-msgv4.

    message_attribute_tab = VALUE #( BASE message_attribute_tab ( msgid ) ( msgty ) ( msgv1 )
                                                                ( msgv2 ) ( msgv3 ) ( msgv4 )
                                                                ( '--------' ) ).

    MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
        TYPE 'E'
        NUMBER '005'
        WITH 'E' 'F' 'G' 'H'
        INTO msg.

    msgid = sy-msgid.
    msgty = sy-msgty.
    msgv1 = sy-msgv1.
    msgv2 = sy-msgv2.
    msgv3 = sy-msgv3.
    msgv4 = sy-msgv4.

    message_attribute_tab = VALUE #( BASE message_attribute_tab ( msgid ) ( msgty ) ( msgv1 )
                                                                ( msgv2 ) ( msgv3 ) ( msgv4 ) ).

    out->write( data = message_attribute_tab name = `message_attribute_tab` ).
    out->write( |\n| ).

    "Getting all messages of a message class
    "Note: When a message class/number is not found, the type
    "is put in first position followed by the specified message
    "name. Message numbers have a three-digit number.
    DATA messages TYPE string_table.
    DO 999 TIMES.
      MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
         TYPE 'E'
         NUMBER sy-index
         INTO DATA(msg_of_msgcl).

      FIND PCRE `^E:ZDEMO_ABAP_MESSAGES` IN msg_of_msgcl.
      IF sy-subrc <> 0.
        APPEND |Message number { sy-index }: "{ msg_of_msgcl }"| TO messages.
      ENDIF.
    ENDDO.

    out->write( data = messages name = `messages` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Syntax Variants of RAISE EXCEPTION/THROW` ) ).

    "In the example, the RAISE EXCEPTION/THROW statements are implemented in a method.
    "Depending on a value, specific statements are called.

    TYPES: BEGIN OF exception_info,
             idx      TYPE i,
             exc_text TYPE string,
             BEGIN OF source_position,
               prog        TYPE syrepid,
               incl        TYPE syrepid,
               source_line TYPE i,
             END OF  source_position,
           END OF exception_info,
           ty_tab_exception_info TYPE TABLE OF exception_info WITH EMPTY KEY.
    DATA tab_exception_info TYPE ty_tab_exception_info.

    "Exception class implementing interface if_t100_message
    DO.
      TRY.
          APPEND VALUE #( idx = sy-index ) TO tab_exception_info REFERENCE INTO DATA(line).
          meth_a( sy-index ).
        CATCH zcx_demo_abap_error_a INTO DATA(error_a).
          line->exc_text = error_a->get_text( ).
          error_a->get_source_position(
            IMPORTING
              program_name = line->source_position-prog
              include_name = line->source_position-incl
              source_line  = line->source_position-source_line ).
      ENDTRY.
      IF sy-index = 20.
        EXIT.
      ENDIF.
    ENDDO.

    out->write( data = tab_exception_info name = `tab_exception_info` ).

    CLEAR tab_exception_info.

    "Exception class implementing interface if_t100_dyn_message
    DO.
      TRY.
          APPEND VALUE #( idx = sy-index ) TO tab_exception_info REFERENCE INTO line.
          meth_b( sy-index ).
        CATCH zcx_demo_abap_error_b INTO DATA(error_b).
          line->exc_text = error_b->get_text( ).
          error_b->get_source_position(
            IMPORTING
              program_name = line->source_position-prog
              include_name = line->source_position-incl
              source_line  = line->source_position-source_line ).
      ENDTRY.
      IF sy-index = 15.
        EXIT.
      ENDIF.
    ENDDO.

    out->write( data = tab_exception_info name = `tab_exception_info` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Excursions` ) ).

    "Exploring the inheritance tree of exception classes
    DATA inheritance_tree TYPE string_table.

    DATA(class_name_table) = VALUE string_table( ( `CX_SY_ZERODIVIDE` )
                                                 ( `CX_SY_ITAB_LINE_NOT_FOUND` )
                                                 ( `CX_SY_CONVERSION_OVERFLOW` )
                                                 ( `CX_SY_RTTI_TYPE_NOT_RELEASED` )
                                                 ( `CX_ROOT` )
                                                 ( `CX_STATIC_CHECK` )
                                                 ( `CL_ABAP_TABLEDESCR` ) "Excursion: Not an exception class; class name of an RTTI class
                                                 ( `CX_THIS_CLASS_DOES_NOT_EXIST` )
                                               ).

    LOOP AT class_name_table INTO DATA(classname).
      DO.
        TRY.

            cl_abap_typedescr=>describe_by_name( EXPORTING p_name = classname
             RECEIVING p_descr_ref = DATA(tdo_type)
              EXCEPTIONS type_not_found  = 4 ) .
            IF  sy-subrc <> 0.
              APPEND `--- Class not found ---` TO inheritance_tree.
              EXIT.
            ELSE.
              APPEND classname TO inheritance_tree.
              DATA(tdo_cl) = CAST cl_abap_classdescr( tdo_type ).
            ENDIF.

            "This method uses classic exceptions
            tdo_cl->get_super_class_type(
              RECEIVING p_descr_ref = DATA(tdo_super_class)
              EXCEPTIONS super_class_not_found = 4 ).

            IF sy-subrc <> 0.
              EXIT.
            ELSE.
              classname = tdo_super_class->get_relative_name( ).
            ENDIF.

          CATCH cx_sy_rtti_type_not_released.
            APPEND `--- Class not released ---` TO inheritance_tree.
            EXIT.
        ENDTRY.
      ENDDO.

      out->write( `-------------------` ).
      out->write( data = inheritance_tree name = `inheritance_tree` ).
      CLEAR inheritance_tree.
    ENDLOOP.

    out->write( |\n| ).
    out->write( |\n| ).
    "Exploration down the inheritance tree (from superclass to subclasses)
    "You can use the XCO library. The example only uses examples with few
    "subclasses and classes not high up in an inheritance tree to reduce
    "the program runtime.
    class_name_table = VALUE string_table( ( `CX_SY_ZERODIVIDE` )
                                           ( `CX_SY_RTTI_NO_CHECK` )
                                           ( `CL_ABAP_TYPEDESCR ` ) "Excursion: Not an exception class; class name of an RTTI class
                                           ( `CX_THIS_CLASS_DOES_NOT_EXIST` )
                                         ).

    LOOP AT class_name_table INTO classname.
      DATA(xco_handler) = xco_cp_abap=>class( CONV sxco_ao_object_name( classname ) ).
      IF xco_handler->exists( ).
        "Getting the names of the subclasses
        DATA(subclass_names) = xco_handler->subclasses->all->get_names( ).
        IF subclass_names IS INITIAL.
          out->write( data = |The class { classname } has no subclasses.| ).
        ELSE.
          out->write( data = subclass_names name = `subclass_names` ).
        ENDIF.
        out->write( `-------------------` ).
      ELSE.
        out->write( |The class { classname } does not exist.| ).
      ENDIF.
    ENDLOOP.

    out->write( |\n| ).
    out->write( |\n| ).

    "Evaluating the return value of a non-class-based exception and raising a class-based exception
    TRY.
        cl_abap_typedescr=>describe_by_name( EXPORTING p_name = 'CL_THAT_DOES_NOT_EXIST'
                                             RECEIVING p_descr_ref = DATA(tdo_ty)
                                             EXCEPTIONS type_not_found = 4 ).

        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE e005(zdemo_abap_messages) WITH 'Type not found'.
        ELSE.
          DATA(tdo_class) = CAST cl_abap_classdescr( tdo_ty ).

          "Getting more type information; find more details in the Dynamic Programming cheat sheet
          ...
        ENDIF.
      CATCH zcx_demo_abap_error_b INTO DATA(err).
        DATA(error_text) = err->get_text( ).
        out->write( data = error_text name = `error_text` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Programmatically Raising Runtime Erros` ) ).

    out->write( `Obviously, the statements raising a runtime error are commented out :)` ).


    "RAISE SHORTDUMP TYPE cx_sy_zerodivide.

    DATA(flag) = abap_true.
    "DATA(cond_w_throw_shortdump) = COND #( WHEN flag IS INITIAL THEN `works`
    "                                       ELSE THROW SHORTDUMP zcx_demo_abap_error_b( ) ).

    "DATA(switch_w_throw_shortdump) = SWITCH #( flag WHEN '' THEN `works`
    "                                           ELSE THROW SHORTDUMP zcx_demo_abap_error_b( ) ).


    DATA(number) = 0.
    ASSERT number IS INITIAL.
    ASSERT number > -1.
    number = 1.
    ASSERT number = 1.

    flag = abap_false.
    "ASSERT flag = abap_true.
  ENDMETHOD.

  METHOD meth_resumable.

    IF num2 = 0 AND num1 <> 0.
      RAISE RESUMABLE EXCEPTION TYPE zcx_demo_abap_error_b.
      div_result = `No result. Resumed!`.
    ELSE.
      div_result = num1 / num2.
    ENDIF.

    "Statement with COND operator using RESUMABLE
    "div_result = COND #( WHEN num2 = 0 AND num1 <> 0 THEN num1 / num2
    "                     ELSE THROW RESUMABLE zcx_demo_abap_error( ) ).

  ENDMETHOD.

  METHOD meth_a.
    "Note: A selection of additions is covered.

    DATA(flag) = 'X'.

    CASE num.
      WHEN 1.
        "TYPE addition
        "Raises an exception of a specified exception class
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a.
      WHEN 2.
        "TYPE addition including EXPORTING
        "Assigns actual parameters to input parameters of the instance constructor
        "particularly for classes implementing if_t100_message. The example uses
        "a constant structure having the same name as the exception class.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a
          EXPORTING
            textid = zcx_demo_abap_error_a=>zcx_demo_abap_error_a.
      WHEN 3.
        "Assigning values to replace placeholders of a message
        "In this case, replacing the placeholders &1 and &2 in a message.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a
          EXPORTING
            textid  = zcx_demo_abap_error_a=>error_003
            p_003_a = `a`
            p_003_b = `b`.

      WHEN 4.
        "Assigning values to replace placeholders of a message
        "In this case, not all available parameters are filled.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a
          EXPORTING
            textid  = zcx_demo_abap_error_a=>error_004
            p_004_a = `c`
            p_004_b = `d`
            p_004_c = `e`.

      WHEN 5.
        "Specifying an exception object
        DATA(cx_oref) = NEW zcx_demo_abap_error_a( textid = zcx_demo_abap_error_a=>error_005
            p_005_a = `Some`
            p_005_b = `error` ).

        RAISE EXCEPTION cx_oref.
      WHEN 6.
        "Eexception object created inline
        RAISE EXCEPTION NEW zcx_demo_abap_error_a( textid  = zcx_demo_abap_error_a=>error_004
                                                   p_004_a = `f`
                                                   p_004_b = `g` ).

      WHEN 7.
        "MESSAGE addition
        "For passing message specification to an exception object
        "Note that EXPORTING can also be specified
        "After MESSAGE, a message type is specified (which is not of relevance in ABAP for Cloud
        "Development). These types can be the following: A, E, I, S, W, or X. See the ABAP Keyword
        "Documentation for information.For example, E representing an error message.
        "The character is followed by the message number. The message class name is directly
        "specified within a pair of parentheses.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a MESSAGE e002(zdemo_abap_messages).

      WHEN 8.
        "Specifying a message number that does not exist
        "The specified message type, message class, and message number are
        "used as short text in uppercase letters and separated by a colon
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a MESSAGE e999(zdemo_abap_messages).
      WHEN 9.
        "MESSAGE, ID, TYPE, NUMBER additions
        "The message class, the message type, and the message number are specified.
        "Here, literals are specified. The example is an alternative to the one above.

        "addition WITH not supported when interface not implemented
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a
          MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
          TYPE 'E'
          NUMBER '002'.

      WHEN 10.
        "Specifying the values using data objects, not as literals as above.
        "Note that uppercase letters are expected.
        DATA(msgid) = 'ZDEMO_ABAP_MESSAGES'.
        DATA(msgty) = 'E'.
        DATA(msgnum) = '002'.

        RAISE EXCEPTION TYPE zcx_demo_abap_error_a MESSAGE ID msgid TYPE msgty NUMBER msgnum.

      WHEN 11.
        "Intentionally using lowercase letters for demonstration purposes
        msgid = to_lower( 'ZDEMO_ABAP_MESSAGES'  ).
        msgty = 'E'.
        msgnum = '002'.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_a MESSAGE ID msgid TYPE msgty NUMBER msgnum.

      WHEN 12.
        "Using COND operator with various additions
        DATA(cond_w_throw_1) = COND #( WHEN flag IS INITIAL THEN `works`
                                       ELSE THROW zcx_demo_abap_error_a( ) ).

      WHEN 13.
        DATA(cond_w_throw_2) = COND #( WHEN flag IS INITIAL THEN `works`
                                       ELSE THROW zcx_demo_abap_error_a( textid  = zcx_demo_abap_error_a=>error_004
                                                                         p_004_a = `cond_a`
                                                                         p_004_b = `cond_b` )  ).
      WHEN 14.
        DATA(cond_w_throw_3) = COND #( WHEN flag IS INITIAL THEN `works`
                                       ELSE THROW zcx_demo_abap_error_a( MESSAGE e005(zdemo_abap_messages)
                                                                         p_005_a = `An exception raised with COND` ) ).
      WHEN 15.
        DATA(cond_w_throw_4) =  COND #( WHEN flag IS INITIAL THEN `works`
                                        ELSE THROW zcx_demo_abap_error_a( MESSAGE ID 'ZDEMO_ABAP_MESSAGES' TYPE 'E' NUMBER '002' ) ).

      WHEN 16.
        DATA(cond_w_throw_5) =  COND #( WHEN flag IS INITIAL THEN `works`
                                        ELSE THROW zcx_demo_abap_error_a( MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
                                                                          TYPE 'E'
                                                                          NUMBER '005'
                                                                          p_005_a = `An exception raised with COND`
                                                                          p_005_b = `additions MESSAGE ID/TYPE/NUMBER` ) ).

      WHEN 17.
        "Using SWITCH operator with various additions
        DATA(switch_w_throw_1) = SWITCH #( flag WHEN '' THEN `works`
                                           ELSE THROW zcx_demo_abap_error_a( ) ).
      WHEN 18.

        DATA(switch_w_throw_2) = SWITCH #( flag WHEN '' THEN `works`
                                           ELSE THROW zcx_demo_abap_error_a( textid  = zcx_demo_abap_error_a=>error_004
                                                                             p_004_a = `switch_a`
                                                                             p_004_b = `switch_b` )  ).
      WHEN 19.
        DATA(switch_w_throw_4) = SWITCH #( flag WHEN '' THEN `works`
                                           ELSE THROW zcx_demo_abap_error_a( MESSAGE e005(zdemo_abap_messages)
                                                                             p_005_a = `An exception raised with SWITCH` )  ).


      WHEN 20.

        DATA(switch_w_throw_3) = SWITCH #( flag WHEN '' THEN `works`
                                           ELSE THROW zcx_demo_abap_error_a( MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
                                                                             TYPE 'E'
                                                                             NUMBER '005'
                                                                             p_005_a = `An exception raised with SWITCH`
                                                                             p_005_b  = `additions MESSAGE ID/TYPE/NUMBER` ) ).

      WHEN OTHERS.
        RETURN.
    ENDCASE.
  ENDMETHOD.

  METHOD meth_b.
    "Note: A selection of additions is covered.

    DATA(flag) = 'X'.

    CASE num.
      WHEN 1.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b.
      WHEN 2.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE e002(zdemo_abap_messages).
      WHEN 3.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b
          MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
          TYPE 'E'
          NUMBER '002'.
      WHEN 4.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE e005(zdemo_abap_messages) WITH 'Hello' 'world'.
      WHEN 5.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
                                                   TYPE 'E'
                                                   NUMBER '004'
                                                   WITH 'abc' 'def' 'ghi' 'jkl'.
      WHEN 6.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
                                                   TYPE 'E'
                                                   NUMBER '005'
                                                   WITH 'Message raised at/by'
                                                        cl_abap_context_info=>get_system_date( )
                                                        cl_abap_context_info=>get_system_time( )
                                                        cl_abap_context_info=>get_user_alias( ).

      WHEN 7.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
                                                   TYPE 'E'
                                                   NUMBER '005'
                                                   WITH 'only two out of four' 'parameters specified'.
      WHEN 8.

        MESSAGE e002(zdemo_abap_messages) INTO DATA(msg).
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b USING MESSAGE.

      WHEN 9.

        MESSAGE e005(zdemo_abap_messages) WITH 'a' 'b' 'c' 'd' INTO msg.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b USING MESSAGE.

      WHEN 10.

        DATA: mid     TYPE sy-msgid VALUE 'ZDEMO_ABAP_MESSAGES',
              mtype   TYPE sy-msgty VALUE 'E',
              msg_num TYPE sy-msgno VALUE '002'.

        MESSAGE ID mid TYPE mtype NUMBER msg_num INTO msg.
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b USING MESSAGE.

      WHEN 11.
        "The following statements have the same effect as USING MESSAGE.
        MESSAGE ID 'ZDEMO_ABAP_MESSAGES'
            TYPE 'E'
            NUMBER '004'
            WITH 'mno' 'pqr' 'stu' 'vwx'
            INTO msg.

        "Explictly passing the sy values
        RAISE EXCEPTION TYPE zcx_demo_abap_error_b MESSAGE ID sy-msgid
                                                   TYPE   sy-msgty
                                                   NUMBER sy-msgno
                                                   WITH   sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.

      WHEN 12.
        DATA(cond_w_throw_1) = COND #( WHEN flag IS INITIAL THEN `works`
                                       ELSE THROW zcx_demo_abap_error_b( MESSAGE e005(zdemo_abap_messages)
                                                                         WITH `An exception raised with COND,` `MESSAGE/WITH additions` ) ).

      WHEN 13.
        MESSAGE e005(zdemo_abap_messages) WITH 'Exception raised with COND,' 'USING MESSAGE addition' INTO msg.

        DATA(cond_w_throw_2) = COND #( WHEN flag IS INITIAL THEN `works`
                                       ELSE THROW zcx_demo_abap_error_b( USING MESSAGE ) ).

      WHEN 14.
        DATA(switch_w_throw_1) = SWITCH #( flag WHEN '' THEN `works`
                                           ELSE THROW zcx_demo_abap_error_b( MESSAGE e005(zdemo_abap_messages)
                                                                             WITH `An exception raised with SWITCH,` `MESSAGE/WITH additions` )  ).

      WHEN 15.
        MESSAGE e005(zdemo_abap_messages) WITH 'Exception raised with SWITCH,' 'USING MESSAGE addition' INTO msg.

        DATA(switch_w_throw_2) = SWITCH #( flag WHEN '' THEN `works`
                                           ELSE THROW zcx_demo_abap_error_b( USING MESSAGE ) ).

      WHEN OTHERS.
        RETURN.
    ENDCASE.
  ENDMETHOD.

  METHOD divide.
    div_result = num1 / num2.
  ENDMETHOD.

  METHOD get_uuid.
    uuid = cl_system_uuid=>create_uuid_x16_static( ).
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_internal_tables DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    CLASS-METHODS class_constructor.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS fill_dbtabs.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_internal_tables IMPLEMENTATION.

  METHOD class_constructor.
    zcl_demo_abap_aux=>fill_dbtabs( ).
    fill_dbtabs( ).
  ENDMETHOD.


  METHOD fill_dbtabs.
    "Initializing and populating database tables to have data to work with

    DELETE FROM zdemo_abap_tab1.
    DELETE FROM zdemo_abap_tab2.

    MODIFY zdemo_abap_tab1 FROM TABLE @( VALUE #(
    ( key_field = 100 char1 = 'aaa' char2 = 'bbb' num1 = 1 num2 = 2 )
    ( key_field = 200 char1 = 'ccc' char2 = 'ddd' num1 = 3 num2 = 4 )
    ( key_field = 300 char1 = 'eee' char2 = 'fff' num1 = 5 num2 = 6 )
    ( key_field = 400 char1 = 'ggg' char2 = 'hhh' num1 = 7 num2 = 8 ) ) ).
    MODIFY zdemo_abap_tab2 FROM TABLE @( VALUE #(
    ( key_field = 500 char1 = 'iii' num1 = 10 numlong = 1000 )
    ( key_field = 600 char1 = 'kkk' num1 = 12 numlong = 2000 )
    ( key_field = 700 char1 = 'mmm' num1 = 14 numlong = 3000 )
    ( key_field = 800 char1 = 'ooo' num1 = 15 numlong = 4000 ) ) ).
  ENDMETHOD.

  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: Internal tables\n\n| ).

    out->write( |1) Creating Internal Tables By Inline Declaration\n\n| ).

    "Table declared inline in the context of an assignment
    "The examples show the copying of a table including the content
    "on the fly and creating the table in one step. The data type of the
    "declared variable is determined by the right side.
    "The table type here is a predefined and globally available table type.
    DATA string_tab TYPE string_table.

    DATA(it_1) = string_tab.
    DATA(it_2) = it_1.

    "Using FINAL for creating immutable variables
    FINAL(it_3) = it_1.
    "For example, it is not possible to modify such a table in the following position.
    "APPEND INITIAL LINE TO it_3.

    "As shown below and in other cheat sheets, constructor operators
    "are handy when creating internal tables in place. The following
    "examples uses the VALUE operator and an internal table type.
    DATA(it_4) = VALUE string_table( ( `aaa` )
                                     ( `bbb` ) ).

    "Not providing any table lines means the table is initial
    "and has the same effect as the declaration of it6.
    DATA(it_5) = VALUE string_table( ).
    DATA it_6 TYPE string_table.

    "Excursion
    "Table declared inline in the context of a SELECT statement;
    "a prior extra declaration of an internal table is not needed.
    SELECT * FROM zdemo_abap_fli INTO TABLE @DATA(it_7).

    "Instead of
    DATA it_8 TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY.
    SELECT * FROM zdemo_abap_fli INTO TABLE @it_8.

    "Using FINAL
    SELECT * FROM zdemo_abap_fli INTO TABLE @FINAL(it_9).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Populating internal tables by adding a line (structure) using APPEND ... TO/INSERT ... INTO` ) ).

    TYPES: BEGIN OF st_a,
             num  TYPE i,
             str  TYPE string,
             char TYPE c LENGTH 2,
           END OF st_a,
           ty_tab_a TYPE TABLE OF st_a WITH EMPTY KEY.
    DATA it_a TYPE ty_tab_a.

    "Adding a line created inline
    APPEND VALUE #( num = 1 str = `A` char = 'bb' ) TO it_a.
    INSERT VALUE #( num = 2 str = `C` char = 'dd' ) INTO TABLE it_a.

    "Adding an existing line
    DATA(struc_a) = VALUE st_a( num = 3 str =  `E` char = 'ff' ).
    "Structure whose components are assigned individually using the
    "structure component selector
    DATA struc_b TYPE st_a.
    struc_b-num = 4.
    struc_b-str =  `G`.
    struc_b-char = 'hh'.

    APPEND struc_a TO it_a.
    INSERT struc_b INTO TABLE it_a.

    out->write( data = it_a name = `it_a` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Adding an initial line` ) ).

    APPEND INITIAL LINE TO it_a.
    INSERT INITIAL LINE INTO TABLE it_a.

    out->write( data = it_a name = `it_a` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Adding a line and assigning the added line to a field symbol or data reference variable` ) ).

    "Creating field symbol inline
    APPEND VALUE st_a( num = 5 str =  `I` char = 'jj' ) TO it_a ASSIGNING FIELD-SYMBOL(<fs_a>).
    "Addressing individual components
    ASSERT <fs_a>-num = 5.
    <fs_a>-num = 123.

    FIELD-SYMBOLS <fs_b> TYPE st_a.
    DATA(struc_c) = VALUE st_a( num = 6 ).
    INSERT struc_c INTO TABLE it_a ASSIGNING <fs_b>.
    <fs_b>-str =  `K`.

    "Adding an initial line
    "The examples use data reference variables.
    "Using inline declaration
    APPEND INITIAL LINE TO it_a REFERENCE INTO DATA(dref_a).
    dref_a->num = 7.
    DATA dref_b TYPE REF TO st_a.
    INSERT INITIAL LINE INTO TABLE it_a REFERENCE INTO dref_b.
    dref_b->num = 8.

    DO 3 TIMES.
      APPEND INITIAL LINE TO it_a REFERENCE INTO dref_b.
      dref_b->* = VALUE #( num = sy-index str = sy-index char = sy-index ).
    ENDDO.

    out->write( data = it_a name = `it_a` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Adding all lines from another internal table (LINES OF addition)` ) ).

    "Adding lines to one internal table that are all added to
    "another one
    DATA it_b TYPE ty_tab_a.
    INSERT VALUE #( num = 99 str =  `L` char = 'mm' ) INTO TABLE it_b.
    INSERT VALUE #( num = 100 str =  `N` char = 'oo' ) INTO TABLE it_b.

    APPEND LINES OF it_b TO it_a.
    INSERT LINES OF it_b INTO TABLE it_a.

    out->write( data = it_a name = `it_a` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Adding multiple lines from another internal table with a specified index range` ) ).

    APPEND LINES OF it_a FROM 5 TO 7 TO it_b.
    APPEND LINES OF it_a FROM 12 TO it_b. "further lines up to the last line
    APPEND LINES OF it_a TO 3 TO it_b.  "all lines from the start up to the specified index
    INSERT LINES OF it_a FROM 8 TO 10 INTO TABLE it_b.

    out->write( data = it_b name = `it_b` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Inserting one line or multiple lines from another internal table at a specific position (INDEX addition)` ) ).

    "To be used for index tables.

    INSERT VALUE #( num = 9 str =  `P` char = 'qq' ) INTO it_b INDEX 2.
    INSERT LINES OF VALUE ty_tab_a( ( num = 10 str =  `R` ) ( num = 11 str =  `S` ) ) INTO it_b INDEX 5.
    "FROM and TO can also be used
    INSERT LINES OF it_a FROM 1 TO 3 INTO it_b INDEX 1.

    out->write( data = it_b name = `it_b` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Adding lines using the VALUE operator` ) ).

    DATA(struc_d) = VALUE st_a( num = 11 str =  `T` char = 'uu' ).
    DATA it_c TYPE ty_tab_a.

    "Populating an existing internal table by assigning an internal table that is constructed inline

    "Adding an existing line and a line created inline
    it_c = VALUE #( ( struc_d )
                    ( num = 11 str =  `V` char = 'ww' ) ).

    out->write( data = it_c name = `it_c` ).
    out->write( |\n| ).

    "Creating an internal table by inline declaration and adding lines with VALUE
    DATA(it_d) = VALUE ty_tab_a( ( num = 12 str =  `X` char = 'yy' )
                                 ( num = 13 str =  `Z` char = 'aa' )
                                 ( struc_d ) ).

    out->write( data = it_d name = `it_d` ).
    out->write( |\n| ).

    "******* BASE addition *******
    "Adding new lines without deleting existing content
    it_d =  VALUE #( BASE it_d ( num = 14 str =  `B` char = 'cc' )
                               ( num = 15 str =  `D` char = 'ee' ) ).

    out->write( data = it_d name = `it_d` ).
    out->write( |\n| ).

    "******* LINES OF addition *******
    "Adding lines of other tables
    it_d = VALUE #( ( LINES OF it_c ) ). "No BASE addition, existing content is deleted

    it_c = VALUE #( BASE it_c ( num = 16 str =  `F` char = 'gg' )
                              ( LINES OF it_d ) ).

    out->write( data = it_d name = `it_d` ).
    out->write( |\n| ).
    out->write( data = it_c name = `it_c` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) CORRESPONDING operator / MOVE-CORRESPONDING statements` ) ).

    "Creating and populating demo internal tables
    TYPES: BEGIN OF st_b,
             num    TYPE i,
             char   TYPE c LENGTH 2,
             comp_a TYPE string,
           END OF st_b,
           ty_tab_b TYPE TABLE OF st_b WITH EMPTY KEY,
           BEGIN OF st_c,
             num    TYPE i,
             char   TYPE c LENGTH 2,
             comp_b TYPE string,
           END OF st_c,
           ty_tab_c TYPE TABLE OF st_c WITH EMPTY KEY.

    DATA(it_e_original) = VALUE ty_tab_b( ( num = 1 char = 'aa' comp_a = `B` )
                                          ( num = 2 char = 'cc' comp_a = `D` ) ).
    DATA(it_f_original) = VALUE ty_tab_c( ( num = 3 char = 'ee' comp_b = `F` )
                                          ( num = 4 char = 'gg' comp_b = `H` ) ).

    DATA(it_e) = it_e_original.
    DATA(it_f) = it_f_original.

    "Copying the content of another internal table respecting identically
    "named components

    "it_f -> it_e
    it_e = CORRESPONDING #( it_f ).

    out->write( `CORRESPONDING` ).
    out->write( data = it_e name = `it_e` ).
    out->write( |\n| ).

    "it_e -> it_f
    it_e = it_e_original.
    MOVE-CORRESPONDING it_e TO it_f.

    out->write( `MOVE-CORRESPONDING` ).
    out->write( data = it_f name = `it_f` ).
    out->write( |\n| ).

    "******* BASE addition / KEEPING TARGET LINES addition *******
    "Copying content and retaining existing content
    it_e = it_e_original.
    it_f = it_f_original.

    out->write( `CORRESPONDING ... BASE ...` ).
    it_e = CORRESPONDING #( BASE ( it_e ) it_f ).

    out->write( data = it_e name = `it_e` ).
    out->write( |\n| ).

    it_e = it_e_original.
    it_f = it_f_original.

    out->write( `MOVE-CORRESPONDING ... KEEPING TARGET LINES ...` ).
    MOVE-CORRESPONDING it_e TO it_f KEEPING TARGET LINES.

    out->write( data = it_f name = `it_f` ).
    out->write( |\n| ).

    "******* MAPPING addition *******
    "Assigning components using mapping relationships
    it_e = it_e_original.
    it_f = it_f_original.

    out->write( `CORRESPONDING ... MAPPING ...` ).
    it_e = CORRESPONDING #( it_f MAPPING comp_a = comp_b ).

    out->write( data = it_e name = `it_e` ).
    out->write( |\n| ).


    out->write( `CORRESPONDING ... BASE ... MAPPING ...` ).
    it_e = it_e_original.
    it_f = CORRESPONDING #( BASE ( it_f ) it_e MAPPING comp_b = comp_a ). "Retaining content with BASE

    out->write( data = it_f name = `it_f` ).
    out->write( |\n| ).

    "******* EXCEPT addition *******
    "Excluding components from the assignment
    it_e = it_e_original.
    it_f = it_f_original.

    out->write( `CORRESPONDING ... EXCEPT ...` ).
    it_e = CORRESPONDING #( it_f EXCEPT char ).

    out->write( data = it_e name = `it_e` ).
    out->write( |\n| ).

    it_e = it_e_original.
    "EXCEPT * means that all components remain initial not specified
    "for mapping
    out->write( `CORRESPONDING ... MAPPING ... EXCEPT ...` ).
    it_f = CORRESPONDING #( it_e MAPPING comp_b = comp_a EXCEPT * ). "Mapping components

    out->write( data = it_f name = `it_f` ).
    out->write( |\n| ).

    "******* DISCARDING DUPLICATES addition *******
    "Preventing runtime errors when duplicate lines are assigned
    it_e = VALUE #( ( num = 1 char = 'aa' comp_a = `B` )
                    ( num = 1 char = 'cc' comp_a = `D` ) ).

    DATA it_g TYPE SORTED TABLE OF st_b WITH UNIQUE KEY num.

    "The statement commented out raises the runtime error ITAB_DUPLICATE_KEY.
    "it_g = CORRESPONDING #( it_e ).

    out->write( `CORRESPONDING ... DISCARDING DUPLICATES ...` ).
    it_g = CORRESPONDING #( it_e DISCARDING DUPLICATES ).

    out->write( data = it_g name = `it_g` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) DEEP addition to the CORRESPONDING operator / EXPANDING NESTED TABLES addition to MOVE-CORRESPONDING statements` ) ).

    "Handling deep components such as nested internal tables

    "Creating and populating demo internal tables
    TYPES: BEGIN OF st_d,
             char_a TYPE c LENGTH 2,
             char_b TYPE c LENGTH 2,
           END OF st_d,
           BEGIN OF st_e,
             char_b TYPE c LENGTH 2,
             char_c TYPE c LENGTH 2,
           END OF st_e,
           BEGIN OF st_f,
             comp1 TYPE c LENGTH 2,
             comp2 TYPE c LENGTH 2,
             comp3 TYPE TABLE OF st_d WITH EMPTY KEY,
           END OF st_f,
           BEGIN OF st_g,
             comp2 TYPE c LENGTH 2,
             comp3 TYPE TABLE OF st_e WITH EMPTY KEY,
             comp4 TYPE c LENGTH 2,
           END OF st_g,
           ty_tab_d TYPE TABLE OF st_f WITH EMPTY KEY,
           ty_tab_e TYPE TABLE OF st_g WITH EMPTY KEY.

    DATA(it_h_original) = VALUE ty_tab_d(
      ( comp1 = 'a1' comp2 = 'a2' comp3 = VALUE #( ( char_a = 'a3' char_b = 'a4' ) ( char_a = 'a5' char_b = 'a6' ) ) )
      ( comp1 = 'b1' comp2 = 'b2' comp3 = VALUE #( ( char_a = 'b3' char_b = 'b4' ) ( char_a = 'b5' char_b = 'b6' ) ) ) ).

    DATA(it_i_original) = VALUE ty_tab_e(
      ( comp2 = 'c1' comp3 = VALUE #( ( char_b = 'c2' char_c = 'c3' ) ( char_b = 'c4' char_c = 'c5' ) ) comp4 = 'c6' )
      ( comp2 = 'd1' comp3 = VALUE #( ( char_b = 'd2' char_c = 'd3' ) ( char_b = 'd4' char_c = 'd5' ) ) comp4 = 'd6' ) ).

    DATA(it_h) = it_h_original.
    DATA(it_i) = it_i_original.

    "Compare the output of the examples
    out->write( `******* CORRESPONDING *******` ).
    "Note: The following example uses just CORRESPONDING. The outcome of the assignment
    "is a different one compared to using DEEP. Refer to the ABAP Keyword Documentation
    "for more details.
    it_h = CORRESPONDING #( it_i ).
    out->write( it_h ).

    out->write( `******* CORRESPONDING ... DEEP *******` ).
    it_h = CORRESPONDING #( DEEP it_i ).
    out->write( it_h ).

    out->write( `******* CORRESPONDING ... DEEP BASE *******` ).
    it_h = it_h_original.
    it_h = CORRESPONDING #( DEEP BASE ( it_h ) it_i ).
    out->write( it_h ).

    out->write( `******* MOVE-CORRESPONDING ... EXPANDING NESTED TABLES *******` ).
    it_h = it_h_original.
    MOVE-CORRESPONDING it_i TO it_h EXPANDING NESTED TABLES.
    out->write( it_h ).

    out->write( `******* MOVE-CORRESPONDING ... EXPANDING NESTED TABLES KEEPING TARGET LINES *******` ).
    it_h = it_h_original.
    MOVE-CORRESPONDING it_i TO it_h EXPANDING NESTED TABLES KEEPING TARGET LINES.
    out->write( it_h ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) CORRESPONDING with lookup table` ) ).

    "The following examples construct an internal tables by joining an internal table
    "and a lookup table and comparing their components.
    TYPES:
      BEGIN OF s_lk1,
        character TYPE c LENGTH 1,
        text      TYPE string,
      END OF s_lk1,
      it_type         TYPE STANDARD TABLE OF s_lk1 WITH EMPTY KEY,
      lookup_tab_type TYPE HASHED TABLE OF s_lk1 WITH UNIQUE KEY character.

    DATA(it_lk1) = VALUE it_type( ( character = 'a' ) ( character = 'b' ) ( character = 'c' ) ( character = 'd' )
                                ( character = 'e' ) ( character = 'f' ) ).
    DATA(it_lk1_copy) = it_lk1.

    DATA(lookup_tab) = VALUE lookup_tab_type( ( character = 'a' text = `lorem` )
                                               ( character = 'c' text = `ipsum` )
                                               ( character = 'e' text = `dolor` )
                                               ( character = 'f' text = `sit` ) ).

    "In the following example assignment, the internal table used for the comparison
    "is also the target table.
    it_lk1 = CORRESPONDING #( it_lk1 FROM lookup_tab USING character = character ).

    out->write( data = it_lk1 name = `it_lk1` ).
    out->write( |\n| ).

    "In the following example, the internal table used for the comparison
    "is not the target table. Instead, a new table is created inline.
    "The pragma suppresses a syntax warning.

    DATA(it_lk2) = CORRESPONDING it_type( it_lk1_copy FROM lookup_tab USING character = character ) ##operator.
    ASSERT it_lk2 = it_lk1.
    out->write( data = it_lk2 name = `it_lk2` ).
    out->write( |\n| ).

    "Example assignments to demonstrate the KEY and MAPPING additions
    TYPES:
      BEGIN OF s_lk2,
        a TYPE string,
        b TYPE string,
        c TYPE string,
        d TYPE string,
        e TYPE string,
        f TYPE string,
      END OF s_lk2,
      BEGIN OF s_lk3,
        a TYPE string,
        b TYPE string,
        c TYPE string,
        d TYPE string,
        e TYPE string,
        g TYPE string,
      END OF s_lk3,
      BEGIN OF s_lk4,
        h TYPE string,
        i TYPE string,
        j TYPE string,
        k TYPE string,
        l TYPE string,
        m TYPE string,
      END OF s_lk4.
    DATA:
      it_lk3       TYPE STANDARD TABLE OF s_lk2,
      it_lk4       TYPE STANDARD TABLE OF s_lk2,
      it_lk5       TYPE STANDARD TABLE OF s_lk2,
      lookup_table TYPE STANDARD TABLE OF s_lk3 WITH NON-UNIQUE SORTED KEY sk COMPONENTS c d,
      it_lk6       TYPE STANDARD TABLE OF s_lk4.

    it_lk3 = VALUE #( ( a = `1a`  b = `1b`
                     c = `---` d = `---`
                     e = `---` f = `---` )
                   ( a = `2a`  b = `2b`
                     c = `---` d = `---`
                     e = `---` f = `---` )
                   ( a = `3a`  b = `3b`
                     c = `---` d = `---`
                     e = `---` f = `---` ) ).

    it_lk4 = it_lk3.
    it_lk5 = it_lk3.

    lookup_table = VALUE #( ( a = `4a` b = `4b`
                              c = `1a` d = `1b`
                              e = `5a` g = `5b` )
                            ( a = `6a` b = `6b`
                              c = `3a` d = `3b`
                              e = `7a` g = `7b` ) ).

    "Notes on the example assignment:
    "- Internal table used for the comparison is also the target table
    "- The lookup table specifies a sorted secondary table key.
    "- The key is used after the USING KEY addition.
    "- All key components must be specified.
    "- Regarding the result:
    "  - Only the first and third lines are found in the lookup table.
    "  - Therefore, the values of the identically named components in it3
    "    are assigned (which is only one component in the example).
    "  - The assignment excludes the components c and d of the lookup table,
    "    although there are identically named components in it3. The components
    "    used in the condition specification are ignored. The other components
    "    retain their original values.
    "  - In the lookup table, no line is available with the values a = `2a` b = `2b`.
    "    Therefore, the result does not include values from the lookup table. The
    "    original component values of the line in it3 are used for the result.

    it_lk3 = CORRESPONDING #( it_lk3 FROM lookup_table USING KEY sk c = a d = b ).

    out->write( data = it_lk3 name = `it_lk3` ).
    out->write( |\n| ).

    "Notes on the example assignment:
    "- See above. Here, the MAPPING addition is included. It is used to specify
    "  mapping relationships for the assignments. The example specifies a mapping
    "  relationship for all available components in the demo tables. In doing so,
    "  the default mapping is overridden, and, all previously ignored components
    "  are not ignored anymore.
    "- As a consequence, all component values in the first and third lines are
    "  are affected and assigned values.
    "- As above, the second line retains the original values of it4 as there is
    "  no line found in the lookup table.

    it_lk4 = CORRESPONDING #( it_lk4 FROM lookup_table USING KEY sk c = a d = b MAPPING a = a b = b c = c d = d f = g ).

    out->write( data = it_lk4 name = `it_lk4` ).
    out->write( |\n| ).
    "Notes on the example assignment:
    "- The target table does not have the same type as it5. But, despite having differently
    "  named components, the types are compatible, and an assignment can be performed.
    "- As not the same internal table is used for the search in the CORRESPONDING expression and
    "  the target, a syntax warning would occur (a temporary copy of it5 must be created) if not
    "  hidden by the pragma.

    it_lk6 = CORRESPONDING #( it_lk5 FROM lookup_table USING KEY sk c = a d = b ) ##operator.

    out->write( data = it_lk6 name = `it_lk6` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Creating anonymous internal tables with the NEW operator` ) ).

    TYPES: BEGIN OF s,
             a TYPE c LENGTH 3,
             b TYPE i,
           END OF s,
           tab_type TYPE TABLE OF s WITH EMPTY KEY.

    "Creating and populating an anonymous data object
    DATA(dref_tab) = NEW tab_type( ( a = 'aaa' b = 1 )
                                   ( a = 'bbb' b = 2 ) ).

    "Access by derefencing
    DATA(copy_deref_itab) = dref_tab->*.
    DATA(read_line) = dref_tab->*[ 2 ].
    DATA(read_comp) = dref_tab->*[ 1 ]-a.
    dref_tab->*[ 1 ]-a = 'zzz'.
    ASSERT dref_tab->*[ 1 ]-a = 'zzz'.
    INSERT VALUE s( a = 'yyy' b = 3 ) INTO TABLE dref_tab->*.
    out->write( data = dref_tab->* name = `dref_tab->*` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) FILTER: Filtering internal table by condition` ) ).

    "This section covers multiple examples demonstrating the syntactical variety
    "of the FILTER operator.

    TYPES: BEGIN OF fi_str,
             a TYPE i,
             b TYPE c LENGTH 3,
             c TYPE c LENGTH 3,
           END OF fi_str.

    "basic form, condition created with single values
    "itab must have at least one sorted key or one hash key used for access.
    "This variant of the filter operator is not possible for an internal table itab without a sorted key or hash key.
    DATA fi_tab1 TYPE SORTED TABLE OF fi_str WITH NON-UNIQUE KEY a.
    DATA fi_tab2 TYPE STANDARD TABLE OF fi_str WITH NON-UNIQUE SORTED KEY sec_key COMPONENTS a.
    DATA fi_tab3 TYPE HASHED TABLE OF fi_str WITH UNIQUE KEY a.

    "Filling internal tables
    fi_tab1 = VALUE #( ( a = 1 b = 'aaa' c = 'abc' )
                       ( a = 2 b = 'bbb' c = 'def' )
                       ( a = 3 b = 'ccc' c = 'hij' )
                       ( a = 4 b = 'ddd' c = 'klm' )
                       ( a = 5 b = 'eee' c = 'nop' ) ).

    fi_tab2 = fi_tab1.
    fi_tab3 = fi_tab1.

    "The lines meeting the condition are respected.
    "Note: The source table must have at least one sorted or hashed key.
    "Here, the primary key is used
    DATA(f1) = FILTER #( fi_tab1 WHERE a >= 3 ).

    out->write( data = f1 name = `f1` ).
    out->write( |\n| ).

    "USING KEY primary_key explicitly specified; same as above
    DATA(f2) = FILTER #( fi_tab1 USING KEY primary_key WHERE a >= 3 ).

    out->write( data = f2 name = `f2` ).
    out->write( |\n| ).

    "EXCEPT addition
    DATA(f3) = FILTER #( fi_tab1 EXCEPT WHERE a >= 3 ).

    out->write( data = f3 name = `f3` ).
    out->write( |\n| ).

    DATA(f4) = FILTER #( fi_tab1 EXCEPT USING KEY primary_key WHERE a >= 3 ).

    out->write( data = f4 name = `f4` ).
    out->write( |\n| ).

    "Secondary table key specified after USING KEY
    DATA(f5) = FILTER #( fi_tab2 USING KEY sec_key WHERE a >= 4 ).

    out->write( data = f5 name = `f5` ).
    out->write( |\n| ).

    DATA(f6) = FILTER #( fi_tab2 EXCEPT USING KEY sec_key WHERE a >= 3 ).

    out->write( data = f6 name = `f6` ).
    out->write( |\n| ).

    "Note: In case of a hash key, exactly one comparison expression for each key
    "component is allowed; only = as comparison operator possible.
    DATA(f7) = FILTER #( fi_tab3 WHERE a = 3 ).

    out->write( data = f7 name = `f7` ).
    out->write( |\n| ).

    "Using a filter table
    "In the WHERE condition, the columns of source and filter table are compared.
    "Those lines in the source table are used for which at least one line in the
    "filter table meets the condition. EXCEPT and USING KEY are also possible.

    "Declaring and filling filter tables
    DATA filter_tab1 TYPE SORTED TABLE OF i
      WITH NON-UNIQUE KEY table_line.

    DATA filter_tab2 TYPE STANDARD TABLE OF i
        WITH EMPTY KEY
        WITH UNIQUE SORTED KEY line COMPONENTS table_line.

    filter_tab1 = VALUE #( ( 3 ) ( 5 ) ).
    filter_tab2 = filter_tab1.

    DATA(f8) = FILTER #( fi_tab1 IN filter_tab1 WHERE a = table_line ).

    out->write( data = f8 name = `f8` ).
    out->write( |\n| ).

    "EXCEPT addition
    DATA(f9) = FILTER #( fi_tab1 EXCEPT IN filter_tab1 WHERE a = table_line ).

    out->write( data = f9 name = `f9` ).
    out->write( |\n| ).

    "USING KEY is specified for the filter table
    DATA(f10) = FILTER #( fi_tab2 IN filter_tab2 USING KEY line WHERE a = table_line ).

    out->write( data = f10 name = `f10` ).
    out->write( |\n| ).

    "USING KEY is specified for the source table, including EXCEPT
    DATA(f11) = FILTER #( fi_tab2 USING KEY sec_key EXCEPT IN filter_tab2 WHERE a = table_line ).

    out->write( data = f11 name = `f11` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) READ TABLE: Reading a single line by index` ) ).

    "Creating and populating an internal table
    TYPES: BEGIN OF st_h,
             a TYPE i,
             b TYPE c LENGTH 2,
             c TYPE string,
           END OF st_h,
           ty_tab_f TYPE SORTED TABLE OF st_h WITH UNIQUE KEY a WITH NON-UNIQUE SORTED KEY sk COMPONENTS b.

    DATA(it_j) = VALUE ty_tab_f( ( a = 1 b = 'zz' c = `B` )
                                 ( a = 2 b = 'xx' c = `D` )
                                 ( a = 3 b = 'yy' c = `F` ) ).

    DATA struc_e TYPE st_h.
    "In the following example ...
    "- a work area is specified as target area.
    "- USING KEY is not specified, i.e. the primary table index is used by default.
    READ TABLE it_j INTO struc_e INDEX 2.

    "Reading into a work area that is created inline
    READ TABLE it_j INTO DATA(struc_f) INDEX 3.

    "Specifying other target areas: Field symbols and data reference variables
    "Here, the target areas are created inline
    READ TABLE it_j ASSIGNING FIELD-SYMBOL(<fs_c>) INDEX 1.
    READ TABLE it_j REFERENCE INTO DATA(dref_c) INDEX 1.

    "******* USING KEY addition *******
    "Reading by index and specifying which table index to use

    "In the following example, the primary key is specified explicitly and
    "addressed using the default name primary_key. It has the same effect
    "as the statement below because the primary table index is used by
    "default.
    READ TABLE it_j INTO struc_e INDEX 1 USING KEY primary_key.
    READ TABLE it_j INTO struc_e INDEX 1.

    "Specifying the secondary key to use the secondary table index
    READ TABLE it_j INTO struc_e INDEX 1 USING KEY sk.

    "Using alias names
    DATA it_j_alias TYPE SORTED TABLE OF st_h
     WITH UNIQUE KEY primary_key ALIAS pk COMPONENTS a
     WITH NON-UNIQUE SORTED KEY sk ALIAS sk_alias COMPONENTS b.

    it_j_alias = it_j.
    READ TABLE it_j_alias INTO struc_e INDEX 1 USING KEY pk.
    READ TABLE it_j_alias INTO struc_e INDEX 1 USING KEY sk_alias.
    "The following examples use the other key names
    READ TABLE it_j_alias INTO struc_e INDEX 1 USING KEY primary_key.
    READ TABLE it_j_alias INTO struc_e INDEX 1 USING KEY sk.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) System field setting with READ TABLE statements` ) ).

    READ TABLE it_j INTO struc_e INDEX 999.
    IF sy-subrc = 0.
      ...
    ELSE.
      ... "This branch is executed in the example since the line is not found.
      ASSERT sy-tabix = 0.
    ENDIF.

    READ TABLE it_j INTO struc_e INDEX 1.
    ASSERT sy-subrc = 0.
    ASSERT sy-tabix = 1.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) READ TABLE: Reading a single line using table keys` ) ).

    "Creating and populating a demo internal table
    TYPES: BEGIN OF st_i,
             num  TYPE i,
             str  TYPE string,
             char TYPE c LENGTH 2,
           END OF st_i.

    DATA it_k TYPE SORTED TABLE OF st_i
      WITH NON-UNIQUE KEY primary_key ALIAS pk COMPONENTS num
      WITH NON-UNIQUE SORTED KEY sec_key ALIAS sk COMPONENTS char.

    it_k = VALUE #( ( num = 1 str = `A` char = 'zz' )
                    ( num = 2 str = `C` char = 'yy' )
                    ( num = 3 str = `E` char = 'xx' ) ).

    "The following examples use a work area as target. Other target areas are
    "possible.

    "Primary table key
    READ TABLE it_k INTO DATA(struc_i) WITH TABLE KEY primary_key COMPONENTS num = 3.
    "Primary table key alias
    READ TABLE it_k INTO struc_i WITH TABLE KEY pk COMPONENTS num = 2.
    "Secondary table key
    READ TABLE it_k INTO struc_i WITH TABLE KEY sec_key COMPONENTS char = 'xx'.
    "Secondary table key alias
    READ TABLE it_k INTO struc_i WITH TABLE KEY sk COMPONENTS char = 'yy'.

    "Reading a line based on keys specified in a work area
    "It is a work area containing primary and secondary table key values.
    "the line type must be compatible to the internal table.
    TYPES st_j LIKE LINE OF it_k.
    DATA(pr_key) = VALUE st_j( num = 1 ).
    DATA(sec_key) = VALUE st_j( char = 'yy' ).

    READ TABLE it_k FROM pr_key INTO struc_i.

    "If USING KEY is not specified, the primary table key is used by default.
    "Explicitly specifying the primary table key
    READ TABLE it_k FROM pr_key USING KEY primary_key INTO struc_i.
    "Primary table key alias
    READ TABLE it_k FROM pr_key USING KEY pk INTO struc_i.
    "Secondary table key
    READ TABLE it_k FROM sec_key USING KEY sec_key INTO struc_i.
    "Secondary table key alias
    READ TABLE it_k FROM sec_key USING KEY sk INTO struc_i.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) READ TABLE: Reading a single line using a free key` ) ).

    "Note: Instead if READ TABLE ... WITH TABLE KEY ..., it is ... WITH KEY.

    READ TABLE it_k INTO DATA(struc_j) WITH KEY str = `A`.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) Examples for addressing individual components of read lines` ) ).

    "Examples for addressing individual components of read lines
    "The assertions emphasize the difference of work areas and field
    "symbols/data reference variables as target areas. Modifying the
    "contents of the field symbols/data reference variables means
    "modifying the internal table content.

    READ TABLE it_k INTO DATA(struc_k) WITH KEY str = `A`.
    struc_k-num = 123.
    DATA(comp_b) = struc_k-num.

    READ TABLE it_k ASSIGNING FIELD-SYMBOL(<fs_e>) WITH KEY str = `C`.
    "Note: The example table is a sorted table with 'num' as part of
    "a unique key. The field value cannot be modified.
    "<fs_e>-num = 123.
    <fs_e>-char = 'hi'.
    DATA(comp_c) = <fs_e>-char.

    READ TABLE it_k REFERENCE INTO DATA(dref_e) WITH KEY str = `E`.
    dref_e->char = '##'.
    DATA(comp_d) = dref_e->num.

    "It is also possible to specify the dereferencing operator together
    "with the component selector.
    DATA(comp_e) = dref_e->*-char.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) READ TABLE: COMPARING / TRANSPORTING additions` ) ).

    "Comparing fields and specifying fields to be transported
    TYPES ty_tab_h TYPE TABLE OF st_i WITH EMPTY KEY.
    DATA(it_m) = VALUE ty_tab_h( ( num = 1 str = `Z` char = '##' )
                                 ( num = 2 str = `Y` char = 'yy' )
                                 ( num = 3 str = `X` char = '##' )
                                 ( num = 4 str = `W` char = 'ww' )
                                 ( num = 5 str = `W` char = '##' )
                                 ( num = 6 str = `V` char = '##' )
                                 ( num = 7 str = `V` char = '##' )
                                 ( num = 7 str = `V` char = '##' )
                                 ( num = 8 str = `V` char = 'vv' ) ).

    "******* TRANSPORTING NO FIELDS addition *******
    "It is only checked whether the line exists. No target area is specified.
    "The system fields sy-subrc and sy-tabix are filled. Check also the
    "line_exists and line_index functions.

    READ TABLE it_m WITH KEY str = `X` TRANSPORTING NO FIELDS.
    ASSERT sy-subrc = 0.
    DATA(sysubrc) = sy-subrc.
    ASSERT sy-tabix = 3.
    DATA(sytabix) = sy-tabix.

    READ TABLE it_m WITH KEY str = `nope` TRANSPORTING NO FIELDS.
    ASSERT sy-subrc = 4.
    ASSERT sy-tabix = 0.

    "******* TRANSPORTING ... addition *******
    "Specifying fields to be transported; cannot be used with the ASSIGNING
    "and REFERENCE additions

    READ TABLE it_m INTO DATA(struc_l) INDEX 1 TRANSPORTING num char.
    ASSERT struc_l-str IS INITIAL.

    "If ALL FIELDS is specified, all fields are assigned, which corresponds to the
    "example below.
    READ TABLE it_m INTO struc_l INDEX 1 TRANSPORTING ALL FIELDS.
    READ TABLE it_m INTO struc_l INDEX 1.

    "******* COMPARING addition *******
    "- Can be used together with and in front of TRANSPORTING ...
    "- Compares the specified components
    "- ALL FIELDS compares all components, NO FIELDS compares no components
    "- Setting of sy-subrc: 0 is set if the content of compared components is identical,
    "  otherwise it is 2. Found lines are nevertheless assigned independently of the comparison.

    "The following examples use a WHILE loop to read all table lines (sy-index represents the
    "index value of the primary table index) into a work area.
    "The work area is filled before the read for the comparison. Depending on the comparison
    "result (by checking the sy-subrc value), the lines are added to different internal tables
    "for demonstration purposes. In addition, the 'num' component value is added to a string.
    "The examples explore several syntax options.

    DATA struc_m LIKE LINE OF it_m.
    DATA it_n LIKE it_m.
    DATA it_o LIKE it_m.
    DATA nums_subrc_0 TYPE string.
    DATA nums_subrc_2 TYPE string.
    DATA(subrc) = 0.

    "Specifying ALL FIELDS
    WHILE subrc = 0.
      DATA(idx) = sy-index.
      struc_m = VALUE #( num = 7 str = `V` char = '##' ).
      READ TABLE it_m INTO struc_m INDEX idx COMPARING ALL FIELDS TRANSPORTING ALL FIELDS.
      subrc = COND #( WHEN sy-subrc = 0 THEN 0 ELSE sy-subrc ).
      IF subrc = 0.
        APPEND struc_m TO it_n.
        nums_subrc_0 &&= struc_m-num.
      ELSEIF subrc = 2.
        APPEND struc_m TO it_o.
        nums_subrc_2 &&= struc_m-num.
        subrc = 0.
      ELSE.
        EXIT.
      ENDIF.
    ENDWHILE.

    ASSERT nums_subrc_0 = `77`.
    ASSERT nums_subrc_2 = `1234568`.
    CLEAR: subrc, struc_m, it_n, it_o, nums_subrc_0, nums_subrc_2.

    "Specifying specific fields for the comparison and transport
    WHILE subrc = 0.
      idx = sy-index.
      struc_m = VALUE #( num = 1234 str = `NOPE` char = '##' ).
      READ TABLE it_m INTO struc_m INDEX idx COMPARING char TRANSPORTING num.
      subrc = COND #( WHEN sy-subrc = 0 THEN 0 ELSE sy-subrc ).
      IF subrc = 0.
        APPEND struc_m TO it_n.
        nums_subrc_0 &&= struc_m-num.
      ELSEIF subrc = 2.
        APPEND struc_m TO it_o.
        nums_subrc_2 &&= struc_m-num.
        subrc = 0.
      ELSE.
        EXIT.
      ENDIF.
    ENDWHILE.

    ASSERT nums_subrc_0 = `135677`.
    ASSERT nums_subrc_2 = `248`.
    CLEAR: subrc, struc_m, it_n, it_o, nums_subrc_0, nums_subrc_2.

    WHILE subrc = 0.
      idx = sy-index.
      struc_m = VALUE #( num = 9999 char = '##' str = `V` ).
      READ TABLE it_m INTO struc_m INDEX idx COMPARING char str TRANSPORTING num.
      subrc = COND #( WHEN sy-subrc = 0 THEN 0 ELSE sy-subrc ).
      IF subrc = 0.
        APPEND struc_m TO it_n.
        nums_subrc_0 &&= struc_m-num.
      ELSEIF subrc = 2.
        APPEND struc_m TO it_o.
        nums_subrc_2 &&= struc_m-num.
        subrc = 0.
      ELSE.
        EXIT.
      ENDIF.
    ENDWHILE.

    ASSERT nums_subrc_0 = `677`.
    ASSERT nums_subrc_2 = `123458`.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) READ TABLE: CASTING / ELSE UNASSIGN additions` ) ).

    "Additions when assigning the read result to a field symbol

    TYPES c3 TYPE c LENGTH 3.
    TYPES ty_tab_g TYPE TABLE OF c3 WITH EMPTY KEY.
    DATA(itq) = VALUE ty_tab_g( ( 'abc' ) ( 'def' ) ).

    "Field symbol created inline (i.e. with the generic type 'data' implicitly)
    "In this case, the CASTING and ELSE UNASSIGN additions are not available.
    READ TABLE itq ASSIGNING FIELD-SYMBOL(<fs_k>) INDEX 1.

    "******* CASTING addition *******
    "To use the addition, the field symbol must be either completely typed, or
    "typed with one of the generic built-in ABAP types c, n, p, or x.
    TYPES c2 TYPE c LENGTH 2.
    FIELD-SYMBOLS <fs_l> TYPE c2.

    READ TABLE itq ASSIGNING <fs_l> CASTING INDEX 2.
    ASSERT <fs_l> = 'de'.

    "******* ELSE UNASSIGN addition *******
    "The field symbol is unassigned if no table line is found. The addition
    "can be used together with the CASTING addition.
    "The following example loops 3 times across an internal table that has
    "two lines. The sy-index value is used as the index value of the READ TABLE
    "statement. The example demonstrates that when a line is not found, the field
    "symbol is unassigned. In case of the first READ TABLE statement that does not
    "specify ELSE UNASSIGN, the field symbol remains assigned.

    DATA string_a TYPE string.
    FIELD-SYMBOLS <fs_o> TYPE c2.
    DO 3 TIMES.
      READ TABLE itq ASSIGNING FIELD-SYMBOL(<fs_m>) INDEX sy-index.
      READ TABLE itq ASSIGNING FIELD-SYMBOL(<fs_n>) ELSE UNASSIGN INDEX sy-index.
      READ TABLE itq ASSIGNING <fs_o> CASTING ELSE UNASSIGN INDEX sy-index.
      IF sy-index = 3.
        ASSERT <fs_m> = `def`.
        ASSERT <fs_n> IS NOT ASSIGNED.
        ASSERT <fs_o> IS NOT ASSIGNED.
      ENDIF.
    ENDDO.

   out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) READ TABLE: Specifying a WHERE Condition` ) ).

    "Creating and populating demo internal tables
    TYPES: BEGIN OF s_where,
             comp1 TYPE i,
             comp2 TYPE c LENGTH 5,
             comp3 TYPE i,
             comp4 TYPE c LENGTH 5,
           END OF s_where,
           t_type_so TYPE SORTED TABLE OF s_where WITH UNIQUE KEY comp1 WITH NON-UNIQUE SORTED KEY sk COMPONENTS comp3.

    DATA(itab_wh) = VALUE t_type_so( ( comp1 = 1 comp2 = 'lorem' comp3 = 30 comp4 = 'ipsum' )
                                  ( comp1 = 2 comp2 = 'dolor' comp3 = 20 comp4 = 'sit' )
                                  ( comp1 = 3 comp2 = 'amet' comp3 = 40 comp4 = 'hello' )
                                  ( comp1 = 4 comp2 = 'world' comp3 = 50 comp4 = 'ABAP' )
                                  ( comp1 = 5 comp2 = 'test' comp3 = 10 comp4 = '' ) ).

    DATA wa_wh TYPE s_where.

    "--------- WHERE condition with comparison expressions ---------

    "Examples: =/EQ, <>/NE, >/GT, </LT, >=,GE, <=/LE,
    "          CO, CN, CA, NA, CS, NS, CP, NP,
    "          [NOT] BETWEEN ... AND
    "          [NOT] IN ranges_tables

    READ TABLE itab_wh INTO wa_wh WHERE comp1 > 3.
    ASSERT sy-tabix = 4.

    "'or' also available in other lines in this component, but the first found line
    "is returned (lines 1, 2, 4)
    READ TABLE itab_wh INTO wa_wh WHERE comp2 CS 'or'.
    ASSERT sy-tabix = 1.

    "'d' occurs in lines 2, 4
    READ TABLE itab_wh INTO wa_wh WHERE comp2 CS 'd'.
    ASSERT sy-tabix = 2.

    READ TABLE itab_wh INTO wa_wh WHERE comp2 CS 'd'.
    ASSERT sy-tabix = 2.

    "--------- WHERE condition with predicate expressions ---------

    "Examples: IS [NOT] INITIAL
    "          IS [NOT] BOUND
    "          IS [NOT] INSTANCE OF

    READ TABLE itab_wh INTO wa_wh WHERE comp1 > 4 AND comp4 IS INITIAL.
    ASSERT sy-tabix = 5.

    "--------- WITH KEY instead of WHERE condition ---------

    "Syntax warning in READ TABLE ... WHERE ... statements
    "READ TABLE itab_wh INTO wa_wh WHERE comp4 IS INITIAL.
    "ASSERT sy-tabix = 5.

    "For a better performance, the previous statement should be
    "replaced by a READ TABLE ... WITH KEY ... statement.
    READ TABLE itab_wh INTO wa_wh WITH KEY comp4 = ''.
    ASSERT sy-tabix = 5.

    "You can also suppress the syntax warning by a pragma.
    READ TABLE itab_wh INTO wa_wh WHERE comp4 IS INITIAL ##read_where_ok.
    ASSERT sy-tabix = 5.

    "------------------- Further additions -------------------

    "TRANSPORTING NO FIELDS addition is possible
    READ TABLE itab_wh TRANSPORTING NO FIELDS WHERE comp2 CS 'd'.
    ASSERT sy-tabix = 2.

    "USING KEY addition
    READ TABLE itab_wh USING KEY primary_key INTO wa_wh WHERE comp2 CS 't'.
    ASSERT sy-tabix = 3.

    READ TABLE itab_wh USING KEY sk INTO wa_wh WHERE comp3 > 40.
    ASSERT sy-tabix = 5.

    "------------------- Excursions -------------------

    "Note the comparison rules for character-like data types
    READ TABLE itab_wh INTO wa_wh WHERE comp2 = 'lorem' ##read_where_ok.
    ASSERT sy-tabix = 1.

    "In the following case, the length of the comp2 value increased to match the
    "length of the specified text field, i.e. the surplus characters from the right
    "side text field are not truncated. As a consequence, the line is not found.

    DATA(some_text) = 'loremXYZ'.

    READ TABLE itab_wh INTO wa_wh WHERE comp2 = some_text ##read_where_ok.
    ASSERT sy-tabix = 0 AND sy-subrc <> 0.

    "When using READ TABLE ... WITH KEY ... the behavior is different. In that
    "case, the surplus characters are truncated because of a conversion. Therefore,
    "the following statement finds a line.
    READ TABLE itab_wh INTO wa_wh WITH KEY comp2 = some_text.
    ASSERT sy-tabix = 1 AND sy-subrc = 0.

    "Note: The read target can only be placed before WHERE conditions.
    "The following statements are not possible.
    "READ TABLE itab WHERE comp2 CS 'd' INTO wa.
    "READ TABLE itab WHERE comp2 CS 'd' TRANSPORTING NO FIELDS.

    "READ TABLE ... WHERE ... statements can replace LOOP AT ... WHERE ...
    "statements including EXIT.
    LOOP AT itab_wh INTO wa_wh WHERE comp2 CS 'd'.
      ASSERT sy-tabix = 2.
      EXIT.
    ENDLOOP.

    "------------------- Dynamic WHERE condition -------------------

    "Character-like data objects or standard tables with character-like line type
    "can be specified

    DATA(dyn_where_cond_str) = `comp2 CS 'd'`.

    READ TABLE itab_wh INTO wa_wh WHERE (dyn_where_cond_str).
    ASSERT sy-tabix = 2.

    DATA(dyn_where_cond_tab) = VALUE string_table( ( `comp2` ) ( `CS` ) ( `'d'` ) ).
    READ TABLE itab_wh INTO wa_wh WHERE (dyn_where_cond_tab).
    ASSERT sy-tabix = 2.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Table expressions: Reading table lines by index` ) ).

    "Creating and populating demo internal tables
    "Note: These demo tables are relevant for most of the code snippets
    "in this section.
    TYPES: BEGIN OF s_demo,
             comp1 TYPE i,
             comp2 TYPE i,
             comp3 TYPE i,
             comp4 TYPE c LENGTH 3,
           END OF s_demo,
           ttyp        TYPE SORTED TABLE OF s_demo WITH UNIQUE KEY comp1 WITH NON-UNIQUE SORTED KEY sk COMPONENTS comp2 comp3,
           ttyp_hashed TYPE HASHED TABLE OF s_demo WITH UNIQUE KEY comp1 WITH NON-UNIQUE SORTED KEY sk COMPONENTS comp2 comp3,
           ttyp2       TYPE SORTED TABLE OF s_demo WITH UNIQUE KEY comp1 comp2 WITH NON-UNIQUE SORTED KEY sk COMPONENTS comp3.

    DATA(itab) = VALUE ttyp( ( comp1 = 1 comp2 = 30 comp3 = 31 comp4 = 'aaa' )
                             ( comp1 = 2 comp2 = 20 comp3 = 21 comp4 = 'bbb' )
                             ( comp1 = 3 comp2 = 10 comp3 = 11 comp4 = 'ccc' ) ).

    DATA itab_hashed TYPE ttyp_hashed.
    itab_hashed = itab.
    DATA itab_so TYPE ttyp2.
    itab_so = itab.

    DATA line TYPE s_demo.

    "------ Reading table line by index------
    "Just specifying the index number means referring to the primary table index.
    "In this case, the internal table must be an index table.

    "In the example, the entire table line is assigned to a variable
    line = itab[ 2 ].

    "KEY ... INDEX ... additions
    "For reading a line according to a table index.
    "The following example has the same effect as above. Here, the default
    "name of the primary key is specified explicitly.
    line = itab[ KEY primary_key INDEX 2 ].

    "Secondary table key specified, using secondary table index
    line = itab[ KEY sk INDEX 1 ].

    "This syntax is not possible for hashed tables.
    "DATA(line_hashed_tab1) = itab_hashed[ 2 ].
    "DATA(line_hashed_tab2) = itab_hashed[ KEY primary_key INDEX 2 ].
    "Secondary table index access is possible for hashed tables
    DATA(line_hashed_tab3) = itab_hashed[ KEY sk INDEX 2 ].

   out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Table expressions: Reading table lines by table key` ) ).

    "------------------ TABLE KEY addition ------------------

    "Explicitly specifying the primary table key
    line = itab[ TABLE KEY primary_key COMPONENTS comp1 = 1 ].

    "The following statement is not possible as no other components can be specified.

    "line = itab[ TABLE KEY primary_key COMPONENTS comp1 = 1 comp2 = 30 ].

    "The addition COMPONENTS is optional; the following example is the same as above
    line = itab[ TABLE KEY primary_key comp1 = 1 ].

    "Specifying a secondary table key
    line = itab[ TABLE KEY sk COMPONENTS comp2 = 20 comp3 = 21 ].

    "Optional COMPONENTS addition
    line = itab[ TABLE KEY sk comp2 = 20 comp3 = 21 ].

    "Fully specifying the table key components is required with TABLE KEY. So, the
    "following statement is not possible.

    "line = itab[ TABLE KEY sk comp2 = 20 ].

    "------------------ KEY addition ------------------

    "Using KEY and specifying all key components work like specifying TABLE KEY
    line = itab[ KEY primary_key COMPONENTS comp1 = 1 ].
    line = itab[ KEY primary_key comp1 = 1 ].
    line = itab[ KEY sk COMPONENTS comp2 = 20 comp3 = 21 ].
    line = itab[ KEY sk comp2 = 20 comp3 = 21 ].

    "Unlike TABLE KEY, KEY does not enforce all key components to be specified
    line = itab[ KEY sk comp2 = 20 ].

    "In case of sorted and secondary table keys, other components not being part
    "of the key can be specified
    line = itab[ KEY primary_key comp1 = 1 comp4 = 'aaa' ].
    line = itab[ KEY sk comp2 = 20 comp4 = 'bbb' ].

    "The following statements are not possible. The initial, left part of
    "the key must be specified. In the example case, it is comp2.

    "line = itab[ KEY sk comp3 = 21 comp4 = 'bbb' ].
    "line = itab[ KEY sk comp4 = 'bbb' ].

    "The following statement triggers a syntax warning because the initial
    "part of a table key is specified, but the key name is not specified.
    "In this case, the search is not optimized as the component is not
    "part of the primary table key of the sorted table. You may optimize
    "it by specifying the key.

    "line = itab[ comp2 = 10 ].

    "The syntax warning can be suppressed by a pragma.
    line = itab[ comp2 = 10 ] ##primkey[sk].

    "Specifying the key name
    line = itab[ KEY sk comp2 = 10 ].

    "------------------ No TABLE KEY/KEY additions ------------------

    "Specifying a free key search, but including all components of the primary
    "table key
    "For a sorted table as in the example, the search is fully optimized.
    line = itab[ comp1 = 1 ].

    "Partly optimized (only a part of the primary table key of the sorted
    "example table is specified)
    line = itab_so[ comp1 = 1 ].

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) Table expressions: Reading table lines using free keys` ) ).

    "The search is and cannot be optimized as the component is not part of
    "the primary table key of the sorted table. Plus, no appropriate
    "secondary table key can be applied.
    line = itab[ comp4 = 'ccc' ].

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) Table expressions: Assigning table lines to a field symbol, data reference variables pointing to a table line` ) ).

    "Assigning table lines to a field symbol

    "Works like READ TABLE ... ASSIGNING ...
    ASSIGN itab[ 2 ] TO FIELD-SYMBOL(<line>).
    "Note: Table expressions do not set the sy-tabix
    "value, except when used with ASSIGN.
    ASSERT sy-tabix = 2.

    "Note: Assigning a non-existent line results in sy-subrc = 4
    "An exception is not raised.
    ASSIGN itab[ 99 ] TO <line>.
    ASSERT sy-subrc = 4.

    "Data reference variables pointing to a table line
    DATA dref_te TYPE REF TO data.
    dref_te = NEW s_demo(  ).
    dref_te->* = itab[ 1 ].

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26) Table expressions: Specifying table expressions as operands in constructor expressions with VALUE and REF` ) ).

    line = VALUE #( itab[ 2 ] ).
    "Works like READ TABLE ... REFERENCE INTO ...
    DATA(line_ref) = REF #( itab[ 3 ] ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `27) Table expressions: Specifying a default value for lines that are not found to avoid an exception` ) ).

    TRY.
        line = itab[ 4 ].
      CATCH cx_sy_itab_line_not_found.
    ENDTRY.

    line = VALUE #( itab[ 4 ] OPTIONAL ).

    line = VALUE #( itab[ 5 ] DEFAULT itab[ 1 ]  ).
    line = VALUE #( itab[ 6 ] DEFAULT VALUE #( ) ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `28) Table expressions: Field symbols and dereferenced data references specified before the square brackets` ) ).

    ASSIGN itab TO FIELD-SYMBOL(<tab>).
    line = <tab>[ 1 ].

    DATA dref_t TYPE REF TO ttyp.
    dref_t = NEW #(  ).

    dref_t->* = itab.
    line = dref_t->*[ 2 ].

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `29) Table expressions: Reading individual components of table lines` ) ).

    "Read component via line read using ...
    "... index
    DATA(compa) = itab[ 1 ]-comp1.
    "... table key
    DATA(compb) = itab[ TABLE KEY primary_key comp1 = 1 ]-comp2.
    DATA(compc) = itab[ TABLE KEY sk comp2 = 30 comp3 = 31 ]-comp1.
    "... free key
    DATA(compd) = itab[ comp4 = 'ccc' ]-comp1.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `30) Table expressions: Chaining table expressions in the context of nested internal tables` ) ).

    "Creating deep internal table
    TYPES: BEGIN OF s_sub,
             comp1 TYPE i,
             comp2 TYPE i,
           END OF s_sub,
           tab_type_sub TYPE TABLE OF s_sub WITH EMPTY KEY,
           BEGIN OF s_super,
             compa TYPE i,
             compb TYPE TABLE OF tab_type_sub WITH EMPTY KEY,
           END OF s_super,
           table_type TYPE TABLE OF s_super WITH EMPTY KEY.

    "Expressions helpful when populating
    DATA(deep_tab) = VALUE table_type( ( compa = 1
                                       compb = VALUE #( ( VALUE #( ( comp1 = 3 comp2 = 4 ) ( comp1 = 5 comp2 = 6 ) ) )
                                                        ( VALUE #( ( comp1 = 7 comp2 = 8 ) ( comp1 = 9 comp2 = 10 ) ) ) ) )
                                        ( compa = 2
                                          compb = VALUE #( ( VALUE #( ( comp1 = 11 comp2 = 12 ) ( comp1 = 13 comp2 = 14 ) ) )
                                                           ( VALUE #( ( comp1 = 15 comp2 = 16 ) ( comp1 = 17 comp2 = 18 ) ) ) ) ) ).

    DATA(num1) = deep_tab[ 2 ]-compb[ 1 ][ 2 ]-comp2.
    ASSERT num1 = 14.

    "Such a statement instead of, for example, multiple statements as follows.
    READ TABLE deep_tab INDEX 2 INTO DATA(wa1).
    READ TABLE wa1-compb INDEX 1 INTO DATA(wa2).
    READ TABLE wa2 INTO DATA(wa3) INDEX 2.

    DATA(num2) = wa3-comp2.

    ASSERT num2 = num1.

    "Table expression result having a reference type enabling chainings with the object component selector

    DATA itab_ref TYPE TABLE OF REF TO s_demo WITH EMPTY KEY.
    itab_ref = VALUE #( ( NEW s_demo( comp1 = 1 comp2 = 30 comp3 = 31 comp4 = 'aaa' ) ) ).

    "Reading entire line by dereferencing
    DATA(deref_line) = itab_ref[ 1 ]->*.
    "Reading component by dereferencing
    DATA(dref_compa) = itab_ref[ 1 ]->comp3.
    "The following syntax is also possible (dereferencing operator followed
    "by the component selector).
    DATA(dref_compb) = itab_ref[ 1 ]->*-comp4.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `31) Table expressions in write positions: Writes on the entire line and writes on individual components` ) ).

    "The demo table is a key table. Therefore, writes on entire lines produce runtime errors.
    "itab[ 3 ] = VALUE #( ).

    "Creating a standard table
    DATA itab_std TYPE TABLE OF s_demo WITH NON-UNIQUE KEY comp1 WITH NON-UNIQUE SORTED KEY sk COMPONENTS comp2 comp3.
    itab_std = itab.

    "Here, writes on entire lines are allowed.
    itab_std[ 3 ] = VALUE #( comp1 = 123 comp4 = 'zzz' ).
    CLEAR itab_std[ 3 ].

    "Table expressions in write positions: Writes on individual components
    itab[ 3 ]-comp4 = 'yyy'.
    itab_ref[ 1 ]->comp3 = 123.
    "No key value change allowed in key tables
    "The following statement causes a runtime error.
    "itab[ 1 ]-comp1 = 987.

    "Key value change allowed for standard tables.
    itab_std[ 3 ]-comp1 = 456.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32) Checking the Existence of a Line in an Internal Table` ) ).

    "Read using a key
    READ TABLE itab_std WITH KEY comp1 = 2 TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.
      DATA(tab_idx2) = sy-tabix.
    ENDIF.

    "Read using the index
    READ TABLE itab_std INDEX 1 TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.
      ...
    ENDIF.

    "Read using the key
    IF line_exists( itab_std[ comp1 = 2 ] ).
      ...
    ENDIF.

    "Read using the index
    IF line_exists( itab_std[ 2 ] ).
      ...
    ENDIF.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33) Checking the index of a line in an internal table` ) ).

    DATA(itab_idx) = VALUE string_table( ( `aaa` ) ( `bbb` ) ).
    READ TABLE itab_idx WITH KEY table_line = `bbb` TRANSPORTING NO FIELDS.

    DATA(table_index) = sy-tabix.

    table_index = line_index( itab_idx[ table_line = `aaa` ] ).

    "Note: No primary table index with hashed tables
    DATA(hashed_tab) = VALUE string_hashed_table( ( `a` ) ( `b` ) ( `c` ) ).

    table_index = line_index( hashed_tab[ table_line = `c` ] ).

    "Index access in hashed tables only using a secondary table index
    DATA hashed_tab2 TYPE TABLE OF string WITH EMPTY KEY WITH NON-UNIQUE SORTED KEY sk COMPONENTS table_line.
    hashed_tab2 = hashed_tab.

    DATA(hashed_secondary_idx) = line_index( hashed_tab2[ KEY sk table_line = `c` ] ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `34) Checking How Many Lines Exist in an Internal Table` ) ).


    DATA(itab_li1) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ( `e` ) ).

    DATA(number_of_lines) = lines( itab_li1 ).

    "Excursion: Finding out the number of lines in a table by specifying concrete
    "component values, e.g. you want to find out how many lines exist in the table
    "that have the value 1 for comp2
    TYPES: BEGIN OF struct,
             comp1 TYPE c LENGTH 3,
             comp2 TYPE i,
           END OF struct,
           ttype TYPE TABLE OF struct WITH EMPTY KEY.

    DATA(itab_li2) = VALUE ttype( ( comp1 = 'a' comp2 = 1  )
                               ( comp1 = 'b' comp2 = 1  )
                               ( comp1 = 'c' comp2 = 1  )
                               ( comp1 = 'd' comp2 = 2  )
                               ( comp1 = 'e' comp2 = 3  )
                               ( comp1 = 'f' comp2 = 4  )
                               ( comp1 = 'g' comp2 = 5  ) ).


    DATA(line_num) = lines( itab_li2 ).

    "Finding out the number of lines in a table by component value, e.g.
    "using constructor expressions and specifying a WHERE clause.
    "The example creates an new internal table inline using VALUE and a FOR loop,
    "specified with a WHERE clause. The lines function is applied to the
    "table created inline.

    DATA(line_num_filtered1) = lines( VALUE ttype( FOR wa IN itab_li2 WHERE ( comp2 = 1 ) ( wa ) ) ).

    "Using the REDUCE operator
    "The example adds 1 to the resulting integer if the comp2 value of the iterated line is greater than 1.
    "The lines function is not relevant in the example.

    DATA(line_num_filtered2) = REDUCE i( INIT var = 0
                                         FOR <tline> IN itab_li2
                                         WHERE ( comp2 > 1 )
                                         NEXT var += 1 ).

    "Using the FILTER operator
    "Note: The source table must have at least one sorted key or a hash key for accessing.
    "If the table does not have such a primary table key, a secondary table key must be available.
    TYPES: tab_type_sorted TYPE TABLE OF struct WITH NON-UNIQUE SORTED KEY sec_key COMPONENTS comp2.
    DATA it_sorted TYPE tab_type_sorted.
    it_sorted = itab_li2.

    "The example creates an new internal table inline using FILTER,
    "specified with a WHERE clause. The lines function is applied to the
    "table created inline.

    DATA(line_num_filtered3) = lines( FILTER #( it_sorted USING KEY sec_key WHERE comp2 = 1 ) ).

    DATA(line_num_filtered4) = lines( FILTER #( it_sorted USING KEY sec_key WHERE comp2 > 1 ) ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `35) Getting Table (Type) Information at Runtime` ) ).

    TYPES tab_info_type TYPE SORTED TABLE OF zdemo_abap_flsch
           WITH UNIQUE KEY carrid connid
           WITH NON-UNIQUE SORTED KEY sec_key ALIAS sk COMPONENTS countryfr cityfrom.
    DATA it_rtti TYPE tab_info_type.

    DATA(tdo_d) = cl_abap_typedescr=>describe_by_data( it_rtti ).
    "DATA(tdo_d) = cl_abap_typedescr=>describe_by_name( 'TAB_INFO_TYPE' ).

    "Cast to get more specific information
    DATA(tdo_itab) = CAST cl_abap_tabledescr( cl_abap_typedescr=>describe_by_data( it_rtti ) ).
    "DATA(tdo_itab) = CAST cl_abap_tabledescr( tdo_d ).

    DATA(type_category_itab) = tdo_itab->kind.
    DATA(relative_name_itab) = tdo_itab->get_relative_name( ).
    ... "Explore more options by positioning the cursor behind -> and choosing CTRL + Space
    DATA(table_kind_itab) = tdo_itab->table_kind.
    DATA(table_keys_itab) = tdo_itab->key.
    DATA(table_keys_more_details_itab) = tdo_itab->get_keys( ).
    DATA(table_has_unique_key_itab) = tdo_itab->has_unique_key.
    DATA(table_key_alias_itab) = tdo_itab->get_key_aliases( ).
    DATA(line_type_itab) = tdo_itab->get_table_line_type( ).
    DATA(table_component_info_itab) = CAST cl_abap_structdescr( tdo_itab->get_table_line_type( ) ).
    DATA(table_components_itab) = CAST cl_abap_structdescr( tdo_itab->get_table_line_type( ) )->components.
    DATA(table_comps_more_info_itab) = CAST cl_abap_structdescr( tdo_itab->get_table_line_type( ) )->get_components( ).
    DATA(applies_to_data_itab) = tdo_itab->applies_to_data( VALUE tab_type( ) ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Processing Multiple Internal Table Lines Sequentially` ) ).

    out->write( `36) Loop statements with different targets` ).

    TYPES: BEGIN OF s_loop,
             compa TYPE i,
             compb TYPE string,
             compc TYPE i,
           END OF s_loop,
           ttype_loop TYPE SORTED TABLE OF s_loop WITH UNIQUE KEY primary_key ALIAS pk COMPONENTS compa
           WITH NON-UNIQUE SORTED KEY sec_key ALIAS sk COMPONENTS compc.

    DATA(it_loop) = VALUE ttype_loop( ( compa = 1 compb = `aaa` compc = 50 )
    ( compa = 2 compb = `bbb` compc = 20 )
    ( compa = 3 compb = `ccc` compc = 40 )
    ( compa = 4 compb = `ddd` compc = 30 )
    ( compa = 5 compb = `eee` compc = 10 )
    ).

    DATA(tabix_counter) = 0.

    "The target is an existing work area.
    DATA wal LIKE LINE OF it_loop.

    LOOP AT it_loop INTO wal.
      "No addition of the loop statement; all lines are processed
      "Statements in this block are relevant for each individual table line.

      tabix_counter += 1.
    ENDLOOP.

    ASSERT tabix_counter = lines( it_loop ).
    CLEAR tabix_counter.

    "Work area declared inline
    LOOP AT it_loop INTO DATA(wal_inl).
      tabix_counter += 1.
    ENDLOOP.

    ASSERT tabix_counter = lines( it_loop ).
    CLEAR tabix_counter.

    "Field symbols
    FIELD-SYMBOLS <fslo> LIKE LINE OF it_loop.

    LOOP AT it_loop ASSIGNING <fslo>.
      tabix_counter += 1.
    ENDLOOP.

    ASSERT tabix_counter = lines( it_loop ).
    CLEAR tabix_counter.

    LOOP AT it_loop ASSIGNING FIELD-SYMBOL(<fslo_inl>).
      tabix_counter += 1.
    ENDLOOP.

    ASSERT tabix_counter = lines( it_loop ).
    CLEAR tabix_counter.

    "Data reference variables
    DATA dref_lo TYPE REF TO s_loop.

    LOOP AT it_loop REFERENCE INTO dref_lo.
      tabix_counter += 1.
    ENDLOOP.

    ASSERT tabix_counter = lines( it_loop ).
    CLEAR tabix_counter.

    LOOP AT it_loop REFERENCE INTO DATA(dref_lo_inl).
      tabix_counter += 1.
    ENDLOOP.

    ASSERT tabix_counter = lines( it_loop ).
    CLEAR tabix_counter.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `37) Loop statements with different table key specifications` ) ).
    "The specified table key affects the order in which the table lines
    "are accessed and the evaluation of the other conditions.

    DATA loop_str TYPE string.

    LOOP AT it_loop INTO wal USING KEY primary_key.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    LOOP AT it_loop INTO wal USING KEY pk.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    LOOP AT it_loop INTO wal USING KEY sec_key.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    LOOP AT it_loop INTO wal USING KEY sk.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `38) Restricting the Area of a Table to Be Looped Over` ) ).
    "FROM/TO: Only for index tables

    "Specifying an index range
    LOOP AT it_loop INTO wal FROM 2 TO 4.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    "From specified line until the end
    LOOP AT it_loop INTO wal FROM 2.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    "From first line until the specified line
    LOOP AT it_loop INTO wal TO 4.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    LOOP AT it_loop INTO wal WHERE compa >= 3 AND compb IS NOT INITIAL.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    "No interest in the table content; only relevant system fields are populated

    "Mandatory WHERE clause
    LOOP AT it_loop TRANSPORTING NO FIELDS WHERE compa < 4.
      loop_str &&= sy-tabix.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `39) Defining the Step Size and the Direction of Loop Passes` ) ).

    "STEP addition for defining the step size and the direction of the loop
    "- Step size: Specified by the absolute value of an integer
    "- Direction: Specified by a positive (forward loop) or negative
    "  (loop in reverse order) integer

    "Reversing the loop order using a negative integer
    "Each line is read indicated by the absolute value 1
    LOOP AT it_loop INTO wal STEP -1.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.

    "Forward loop by specifiying a positive integer
    "In the example, every second line is read.
    "Note: Omitting STEP means STEP 1 by default.
    LOOP AT it_loop INTO wal STEP 2.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).
    CLEAR loop_str.
*
    "STEP with other additions
    "The example uses the additions FROM and TO.
    "Note: If the value after STEP is negative, the value
    "after FROM must be greater than the value after TO.
    LOOP AT it_loop INTO wal FROM 5 TO 1 STEP 2.
      loop_str &&= wal-compa.
    ENDLOOP.
    out->write( loop_str ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `40) Interrupting and Exiting Loops` ) ).

    DATA(str_table) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ( `e` ) ( `f` ) ).
    LOOP AT str_table INTO DATA(wa_exit).
      DATA(tab_idx) = sy-tabix.
      IF wa_exit = `e`.
        EXIT.
      ENDIF.
    ENDLOOP.
    ASSERT tab_idx = 5.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `41) Iteration Expressions` ) ).

    TYPES ty_int_tab TYPE TABLE OF i WITH EMPTY KEY.
    DATA(int_table_a) = VALUE ty_int_tab( ( 1 ) ( 2 ) ( 3 ) ( 4 ) ( 5 ) ).
    DATA int_table_b TYPE ty_int_tab.
    int_table_b = VALUE #( FOR wa_b IN int_table_a ( wa_b * 2 ) ).

    out->write( data = int_table_b name = `int_table_b` ).
    out->write( |\n| ).

    "Instead of, for example, a LOOP statement as follows:
    DATA int_table_c TYPE ty_int_tab.
    LOOP AT int_table_a INTO DATA(wa_c).
      INSERT wa_c * 3 INTO TABLE int_table_c.
    ENDLOOP.
    out->write( data = int_table_c name = `int_table_c` ).
    out->write( |\n| ).

    "Table comprehension: Content of an internal table is created by
    "evaluating a table using a table iteration with an iteration
    "expressions within a constructor expression.
    DATA(lv_num_a) = VALUE ty_int_tab( FOR ls1 IN it_loop
                                       ( ls1-compa ) ).

    out->write( data = lv_num_a name = `lv_num_a` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `41) Retrieving values of one column in ` &&
      `an internal table based on conditions` ) ).

    DATA(lv_num_b) = VALUE ty_int_tab( FOR ls2 IN it_loop
                                       WHERE ( compa < 3 ) ( ls2-compc ) ).

    out->write( data = lv_num_b name = `lv_num_b` ).
    out->write( |\n| ).

    out->write( zcl_demo_abap_aux=>heading( `42) Looping across 2 tables ` &&
         `and retrieving values based on conditions` ) ).
    "Internal table type
    DATA(it_int) = VALUE ty_int_tab( FOR x = 1 WHILE x <= 4 ( x ) ).

    DATA(itab_for_2tab) =
      VALUE  ttype_loop(
                     FOR ls3 IN it_int
                     FOR ls4 IN it_loop WHERE ( compa = ls3 )
                                              ( compa = ls3 compb = ls4-compb ) ).

    out->write( data = itab_for_2tab name = `itab_for_2tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `43) Inserting and Deleting Lines in Internal Tables in Loops` ) ).

    "Inserting and Deleting Lines in Internal Tables in Loops

    "Creating and populating a demo standard internal table to
    "work with in the example loops
    TYPES: BEGIN OF s_loop_mod,
             text TYPE string,
             num  TYPE i,
           END OF s_loop_mod,
           t_loop_mod TYPE TABLE OF s_loop_mod WITH EMPTY KEY.

    "Inserting 10 entries into the demo table
    DATA(itab_original) = VALUE t_loop_mod( FOR x = 1 WHILE x <= 10 ( text = x ) ).
    DATA(itab_loop) = itab_original.

    "---------- Inserting a line after the current line ----------

    "The example inserts a line after the currently processed line
    "using an INSERT statement and specifying the index value
    "(sy-tabix value + 1). The 'num' component is assigned the
    "current sy-tabix value.
    "Note: In all statements, the sy-tabix value is stored in a
    "variable right after the LOOP statement. Assume that multiple
    "statements are included before the statement that actually uses
    "the current sy-tabix value. Other statements that potentially
    "change the sy-tabix value might interfere.
    "An EXIT statement takes care of exiting the loop. In the example,
    "all values of the 'num' component in the original table lines
    "(except the first line) are initial as the loop is exited.
    LOOP AT itab_loop ASSIGNING FIELD-SYMBOL(<fs>).
      DATA(tabix) = sy-tabix.
      <fs>-num = tabix.
      INSERT VALUE #( text = tabix ) INTO itab_loop INDEX tabix + 1.
      IF tabix = 50.
        EXIT.
      ENDIF.
    ENDLOOP.

    out->write( data = itab_loop name = `itab_loop` ).
    out->write( |\n| ).

    "---------- Deleting a line after the current line ----------

    "The example deletes a line after the current line using a
    "DELETE statement and the INDEX addition. The index value
    "is specified using the current sy-tabix value + 1.
    "The 'num' value in the resulting internal table includes
    "the sy-tabix value.

    itab_loop = itab_original.
    LOOP AT itab_loop ASSIGNING <fs>.
      tabix = sy-tabix.
      <fs>-num = tabix.
      DELETE itab_loop INDEX tabix + 1.
    ENDLOOP.

    out->write( data = itab_loop name = `itab_loop` ).
    out->write( |\n| ).

    "---------- Inserting a line before the current line ----------

    "The example insert a line before the currently processed line using
    "an INSERT statement. The current sy-tabix value is used as INDEX value,
    "moving down the currently processed table line one position.
    "In that case, the sy-tabix value increases accordingly.
    "Logic:
    "- For example, the first line is processed, sy-tabix has the value 1.
    "- A line is inserted at this position, moving down the currently processed line
    "  one position. The moved line is then in the second position (as a new line exists
    "  in the first position).
    "- In the next loop pass, the loop is continued with the third line, i.e.
    "  sy-tabix has the value 3 in the second loop pass.
    "The example includes modifications of the table components. The 'num' value
    "is assigned the table index value after inserting the new line. The
    "'num' value of existing table lines includes the value of the index before
    "inserting the new line + 1.

    itab_loop = itab_original.
    FIELD-SYMBOLS <line_loop> TYPE s_loop_mod.
    DATA new_line_counter TYPE i.
    DATA tabix_copy TYPE i.

    LOOP AT itab_loop ASSIGNING <fs>.
      tabix = sy-tabix.
      new_line_counter += 1.

      "Asserting that sy-tabix value has changed accordingly.
      IF tabix <> 1.
        ASSERT tabix = tabix_copy + 2.
      ENDIF.

      DATA(new_line_text) = |---- New line { new_line_counter } ----|.
      INSERT VALUE #( text = new_line_text ) INTO itab_loop INDEX tabix ASSIGNING <line_loop>.

      DATA(idx_new) = line_index( itab_loop[ text = new_line_text num = 0 ] ).
      <line_loop>-num = idx_new.

      DATA(idx_existing) = line_index( itab_loop[ text = <fs>-text num = 0 ] ).
      DATA(new_text) = |{ <fs>-text }(existing line, index before insertion: { tabix })|.
      <fs>-text = new_text.
      <fs>-num = idx_existing.

      tabix_copy = tabix.
    ENDLOOP.

    out->write( data = itab_loop name = `itab_loop` ).
    out->write( |\n| ).

    "---------- Deleting a line before the current line ----------

    "The example explores the deletion of a line before the currently
    "processed line. The previous line in the table is deleted if
    "the value of 'text' (an integer was inserted) is an even number.
    "The DELETE statement specifies the index with the current sy-tabix
    "value - 1. On deletion, the sy-tabix value is decreased accordingly.
    "Before a potential deletion, the currently processed table line is
    "copied to another table to visualize the current sy-tabix value in
    "the 'num' component.

    itab_loop = itab_original.
    DATA itab_copy LIKE itab_loop.

    LOOP AT itab_loop ASSIGNING <fs>.
      tabix = sy-tabix.

      <fs>-num = tabix.
      INSERT <fs> INTO TABLE itab_copy.

      TRY.
          IF CONV i( <fs>-text ) MOD 2 = 0.
            DELETE itab_loop INDEX tabix - 1.
          ENDIF.
        CATCH cx_sy_conversion_no_number .
      ENDTRY.

    ENDLOOP.

    out->write( data = itab_loop name = `itab_loop` ).
    out->write( |\n| ).
    out->write( data = itab_copy name = `itab_copy` ).
    out->write( |\n| ).

    "---------- Deleting the currently processed table line ----------

    "The example explores deleting the currently processed table line using
    "a string table. So, the DELETE statement specifies the current sy-tabix
    "value for INDEX. In that case, the next line moves up one position, and
    "the sy-tabix value remains the same, i.e. when sy-tabix is 2, and the
    "line is deleted, the value remains 2 and processes the line moved up.

    "Creating and populating a demo internal table
    DATA(str_tab) = VALUE string_table( ( `a` ) ( `#` ) ( `c` ) ( `#` ) ( `e` )
                                        ( `f` ) ( `g` ) ( `#` ) ( `i` ) ( `j` ) ).

    LOOP AT str_tab REFERENCE INTO DATA(dref).
      tabix = sy-tabix.
      IF dref->* CS `#`.
        DELETE str_tab INDEX tabix.
      ENDIF.
    ENDLOOP.

    out->write( data = str_tab name = `str_tab` ).
    out->write( |\n| ).

    "---------- Statements clearing the entire internal table are not allowed in loops ----------

    "The entire internal table cannot be deleted within loops.
    "The following statements commented out are not possible.
    LOOP AT str_tab REFERENCE INTO dref.
      "CLEAR str_tab.
      "str_tab = VALUE #( ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `44) Selecting multiple rows from a database table into an internal table` ) ).

    SELECT FROM zdemo_abap_tab1
      FIELDS key_field, char1, char2, num1, num2
      WHERE num1 > 3
      INTO TABLE @DATA(itab_select1).

    out->write( data = itab_select1 name = `itab_select1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading(  `45) Sequentially adding multiple rows from a database table to an internal table` ) ).

    DATA itab_sql TYPE TABLE OF zdemo_abap_tab1 WITH NON-UNIQUE KEY client key_field.

    SELECT FROM zdemo_abap_tab1
      FIELDS *
      WHERE num1 > 3
      INTO @DATA(struc_select).

      IF sy-subrc = 0.
        "Some modifications on the read lines (capitalizing letters)
        struc_select-char1 = to_upper( struc_select-char1 ).
        struc_select-char2 = to_upper( struc_select-char2 ).

        "Adding modified line to an internal table
        APPEND struc_select TO itab_sql.
      ENDIF.
    ENDSELECT.

    out->write( data = itab_sql name = `itab_sql` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `46) Adding multiple rows from a database table ` &&
      `to an internal table that has a different line type than the ` &&
      `database table and keeping existing table content` ) ).

    SELECT FROM zdemo_abap_tab2
      FIELDS *
      WHERE num1 > 10
      APPENDING CORRESPONDING FIELDS OF TABLE @itab_sql.

    out->write( data = itab_sql name = `itab_sql` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `47) Adding multiple rows from a database table ` &&
      `to an internal table that has a different line type than the ` &&
      `database table and deleting existing table content` ) ).

    SELECT FROM zdemo_abap_tab2
      FIELDS *
      WHERE num1 > 10
      INTO CORRESPONDING FIELDS OF TABLE @itab_sql.

    out->write( data = itab_sql name = `itab_sql` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `48) Adding multiple rows from an internal table ` &&
      `to an internal table using SELECT` ) ).

    SELECT key_field, char1, char2, num1, num2
      FROM @itab_sql AS itab_alias
      INTO TABLE @DATA(itab_clone).

    out->write( data = itab_clone name = `itab_clone` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `49) Combining data of multiple tables into an` &&
      ` internal table using an inner join` ) ).

    "Filling table to be selected from
    itab_sql =  VALUE #( ( key_field = 500 char1 = 'uuu' char2 = 'vvv'
                       num1      = 501 num2  = 502 )
                     ( key_field = 600 char1 = 'www' char2 = 'xxx'
                       num1      = 601 num2  = 602 ) ).

    "SELECT list includes fields from both tables
    "If there are no equivalent entries in the first or second table,
    "the rows are not joined.
    SELECT itab_alias1~key_field, itab_alias1~char2,
           zdemo_abap_tab2~numlong
      FROM @itab_sql AS itab_alias1
      INNER JOIN zdemo_abap_tab2
        ON itab_alias1~key_field = zdemo_abap_tab2~key_field
      INTO TABLE @DATA(join_result).

    out->write( data = join_result name = `join_result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `50) Filling internal table ` &&
      `using a subquery (1)` ) ).

    "A subquery is specified in the WHERE clause
    "Here, data is selected from a database table depending on
    "whether the value of a certain field is not among the
    "values specified in parentheses.
    SELECT key_field, char1, numlong
      FROM zdemo_abap_tab2
      WHERE char1 NOT IN ( 'iii', 'mmm', 'ooo', 'ppp' )
      INTO TABLE @DATA(subquery_result1).

    out->write( data = subquery_result1 name = `subquery_result1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `51) Filling internal table ` &&
      `using a subquery (2)` ) ).

    "A subquery using EXISTS in the WHERE clause.
    "In the example, data is selected from a database table depending
    "on the existence of data in an internal table. Only if a line
    "with a matching value of the specified field exists in both
    "database and internal table, data is read.
    SELECT key_field, numlong
      FROM zdemo_abap_tab2
      WHERE EXISTS
         ( SELECT 'X' FROM @itab_sql AS itab_alias2
           WHERE key_field = zdemo_abap_tab2~key_field )
      INTO TABLE @DATA(subquery_result2).

    out->write( data = subquery_result2 name = `subquery_result2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `52) Filling an internal table from a table ` &&
      `depending on the existence of data in another internal table ` &&
      `using the addition FOR ALL ENTRIES` ) ).

    "In the example, data is selected from a database table depending
    "on the existence of data in an internal table. Only if a line
    "with a matching value of the specified field exists in both
    "database and internal table, data is read.
    "Ensure that the internal table from which to read is not initial.
    IF ( 0 < lines( itab ) ).
      SELECT key_field, char1, numlong
        FROM zdemo_abap_tab2
        FOR ALL ENTRIES IN @itab_sql
        WHERE key_field = @itab_sql-key_field
        INTO TABLE @DATA(select_result).
    ENDIF.

    out->write( data = select_result name = `select_result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `53) Adding content from a database to internal` &&
      ` table by using alias names in the SELECT list` ) ).

    DATA itab_sql2 TYPE TABLE OF zdemo_abap_tab2 WITH EMPTY KEY.

    "Specifying alias names can help fill an existing internal
    "table that has not a matching line type to the database table.
    "Here, two fields are specified with an alias name to match the
    "names of components contained in the existing internal table.
    "The individual types of the fields match, too.
    SELECT key_field, char2 AS char1, num2 AS num1
        FROM zdemo_abap_tab1
      INTO CORRESPONDING FIELDS OF TABLE @itab_sql2 UP TO 3 ROWS.

    out->write( data = itab_sql2 name = `itab_sql2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `54) SELECT Queries with Internal Tables as Data Sources` ) ).

    TYPES int_tab_type TYPE TABLE OF i WITH EMPTY KEY.
    DATA(itab_a) = VALUE int_tab_type( ( 1 ) ( 32 ) ( 100 ) ( -24 ) ( 17 ) ( 99 ) ).

    "SELECT query with an internal table as data source
    "The example uses an aggregate expression. It is statically
    "detected that the query cannot be processed by the ABAP SQL
    "engine. The data must be passed to the database. Consequently,
    "a syntax warning is displayed. It can be suppressed by a pragma.
*    SELECT MAX( table_line ) AS max_val
*      FROM @itab_a AS it
*      INTO @DATA(max_a).

    SELECT MAX( table_line ) AS max_val ##itab_db_select
     FROM @itab_a AS it
     INTO @DATA(max_b).

    out->write( data = max_b name = `max_b` ).
    out->write( |\n| ).

    "Using the LIKE addition in the WHERE clause to extract internal table
    "entries matching a specific pattern.
    TYPES: BEGIN OF s1,
             a TYPE c LENGTH 3,
             b TYPE i,
           END OF s1,
           it_type_1 TYPE TABLE OF s1 WITH EMPTY KEY.
    DATA(itab_b) = VALUE it_type_1( ( a = 'abc' b = 1 )
                                    ( a = 'zbc' b = 2 )
                                    ( a = 'bde' b = 3 )
                                    ( a = 'yde' b = 4 ) ).

    SELECT a, b
      FROM @itab_b AS it_alias
      WHERE a LIKE '%bc'
      INTO TABLE @DATA(select_like_result).

    out->write( data = select_like_result name = `select_like_result` ).
    out->write( |\n| ).

    "----------- Using a SELECT loop with an internal table as data source -----------

    TYPES: BEGIN OF s2,
             comp1 TYPE c LENGTH 2,
             comp2 TYPE i,
           END OF s2,
           it_type_2 TYPE TABLE OF s2 WITH EMPTY KEY.

    DATA(itab_c) = VALUE it_type_2( ( comp1 = 'aa' comp2 = 2 )
                                    ( comp1 = 'zz' comp2 = 9 )
                                    ( comp1 = 'dd' comp2 = 1 )
                                    ( comp1 = 'rr' comp2 = 7 )
                                    ( comp1 = 'tt' comp2 = 5 )
                                    ( comp1 = 'bb' comp2 = 6 ) ).

    DATA itab_d TYPE int_tab_type.

    "The following SELECT loop specifies an internal table as data source.
    "The loop sequence is defined by a sort order. Such a functionality is
    "not available with LOOP AT.
    SELECT comp2
           FROM @itab_c AS it
           ORDER BY comp2 DESCENDING
           INTO @DATA(wa_select).
      INSERT wa_select INTO TABLE itab_d.
    ENDSELECT.

    out->write( data = itab_d name = `itab_d` ).
    out->write( |\n| ).

    "------------------- Joins with internal tables -------------------

    TYPES: BEGIN OF s3,
             a TYPE c LENGTH 3,
             b TYPE c LENGTH 3,
             c TYPE i,
           END OF s3,
           it_type_3 TYPE TABLE OF s3 WITH EMPTY KEY.

    DATA(itab_e) = VALUE it_type_3( ( a = 'aaa' b = 'bbb' c = 1 )
                                    ( a = 'ccc' b = 'ddd' c = 1 )
                                    ( a = 'eee' b = 'fff' c = 2 ) ).

    DATA(itab_f) = VALUE it_type_3( ( a = 'ggg' b = 'hhh' c = 1 )
                                    ( a = 'iii' b = 'jjj' c = 1 )
                                    ( a = 'kkk' b = 'lll' c = 3 ) ).

    "No syntax warning. The internal tables can be processed by the
    "ABAP SQL engine.
    SELECT it_alias1~a, it_alias2~b
      FROM @itab_e AS it_alias1
      INNER JOIN @itab_f AS it_alias2 ON it_alias1~c = it_alias2~c
      INTO TABLE @DATA(itab_g).

    out->write( data = itab_g name = `itab_g` ).
    out->write( |\n| ).

    "Join with a database table and an internal table

    "Preparing a demo database table and an internal table
    DELETE FROM zdemo_abap_tab1.
    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 char1 = 'aaa' )
                                                  ( key_field = 2 char1 = 'bbb' )
                                                  ( key_field = 3 char1 = 'ccc' ) ) ).

    TYPES it_type_4 TYPE TABLE OF zdemo_abap_tab1 WITH EMPTY KEY.
    DATA(itab_h) = VALUE it_type_4( ( key_field = 1 char2 = 'zzz' )
                                    ( key_field = 2 char2 = 'yyy' ) ).

    SELECT db~key_field, db~char1, it~char2
      FROM zdemo_abap_tab1 AS db
      INNER JOIN @itab_h AS it ON it~key_field = db~key_field
      INTO TABLE @DATA(itab_i).


    out->write( data = itab_i name = `itab_i` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `55) Excursion: Joining/Merging Internal Tables into Internal Tables` ) ).

    "Excursion: Joining/Merging Internal Tables into Internal Tables

    "Creating two internal tables whose content will be joined. The shared
    "value is represented by the key1 and key2 components.
    "Sorted tables are used in the example (having key1/key2 as unique keys)
    "to have unique values to perform joins.
    TYPES: BEGIN OF struct1,
             key1 TYPE i,
             a    TYPE c LENGTH 1,
             b    TYPE c LENGTH 1,
             c    TYPE c LENGTH 1,
           END OF struct1,
           tab_type1 TYPE SORTED TABLE OF struct1 WITH UNIQUE KEY key1,
           BEGIN OF struct2,
             key2 TYPE i,
             d    TYPE c LENGTH 1,
             e    TYPE c LENGTH 1,
           END OF struct2,
           tab_type2 TYPE SORTED TABLE OF struct2 WITH UNIQUE KEY key2.

    "Populating demo internal tables
    DATA(itab1) = VALUE tab_type1( ( key1 = 1 a = 'a' b = 'b'  c = 'c' )
                                   ( key1 = 2 a = 'd' b = 'e'  c = 'f' )
                                   ( key1 = 3 a = 'g' b = 'h'  c = 'i' ) ).

    DATA(itab2) = VALUE tab_type2( ( key2 = 1 d = `j` e = `k` )
                                   ( key2 = 2 d = `l` e = `m` ) ).

    "SELECT statement, inner join
    "Note: With the inner join, the target table contains all
    "combinations of rows for whose columns the join condition
    "is true.
    SELECT a~key1, a~a, a~b, b~d, b~e
        FROM @itab1 AS a
        INNER JOIN @itab2 AS b ON a~key1 = b~key2
        INTO TABLE @DATA(itab3).

    out->write( data = itab3 name = `itab3` ).
    out->write( |\n| ).

    "SELECT statement, left outer join
    "In contrast to the inner join above, the target table here
    "also contains the table row of the first table for which
    "no equivalent row exists in the second table.
    SELECT a~key1, a~a, a~b, b~d, b~e
        FROM @itab1 AS a
        LEFT OUTER JOIN @itab2 AS b ON a~key1 = b~key2
        INTO TABLE @DATA(itab4).

    out->write( data = itab4 name = `itab4` ).
    out->write( |\n| ).

    "Common table expression
    WITH +it1 AS ( SELECT a~key1, a~a, a~b FROM @itab1 AS a ),
         +it2 AS ( SELECT b~key2, b~d, b~e FROM @itab2 AS b )
    SELECT +it1~key1, +it1~a, +it1~b, +it2~d, +it2~e FROM +it1 LEFT JOIN +it2 ON +it1~key1 = +it2~key2
    INTO TABLE @DATA(itab5).

    out->write( data = itab5 name = `itab5` ).
    out->write( |\n| ).

    "LOOP statements
    "Using the CORRESPONDING operator to assign identically named components,
    "BASE retains existing content
    "The assignment with CORRESPONDING ... BASE ... includes a table expression
    "in which table lines are read and inserted based on the key mapping. With the
    "OPTIONAL addition, errors can be avoided if a line does not exist.
    DATA itab6 LIKE itab4.
    LOOP AT itab1 INTO DATA(w1).
      INSERT CORRESPONDING #( w1 ) INTO TABLE itab6 REFERENCE INTO DATA(ref).
      ref->* = CORRESPONDING #( BASE ( ref->* ) VALUE #( itab2[ key2 = ref->key1 ] OPTIONAL ) ).
    ENDLOOP.

    out->write( data = itab6 name = `itab6` ).
    out->write( |\n| ).

    "Assume the second table's shared component was also key1. In the second CORRESPONDING
    "you could then work with the EXCEPT addition to not overwrite the identicall named
    "component.

    "Example similar to the previous one
    "Also here, a table expression is used to read a line from
    "the second internal table. The INSERT statement (without
    "CORRESPONDING) includes the concrete value assignments
    "with the VALUE operator.
    DATA itab7 LIKE itab4.
    LOOP AT itab1 INTO DATA(w2).
      DATA(lin) = VALUE #( itab2[ key2 = w2-key1 ] OPTIONAL ).

      INSERT VALUE #( key1 = w2-key1
                      a = w2-a
                      b = w2-b
                      d = lin-d
                      e = lin-e ) INTO TABLE itab7.
    ENDLOOP.

    out->write( data = itab7 name = `itab7` ).
    out->write( |\n| ).

    "Example using a FOR loop with the VALUE operator
    TYPES tt_type3 LIKE itab4.
    DATA(itab8) = VALUE tt_type3( FOR w3 IN itab1
                                  ( key1 = w3-key1
                                    a = w3-a
                                    b = w3-b
                                    d = VALUE #( itab2[ key2 = w3-key1 ]-d OPTIONAL )
                                    e = VALUE #( itab2[ key2 = w3-key1 ]-e OPTIONAL ) ) ).

    out->write( data = itab8 name = `itab8` ).
    out->write( |\n| ).

    "Similar example that includes a LET expression
    DATA(itab9) = VALUE tt_type3( FOR w4 IN itab1
                                  LET tab_line = VALUE #( itab2[ key2 = w4-key1 ] OPTIONAL ) IN
                                  ( key1 = w4-key1
                                    a = w4-a
                                    b = w4-b
                                    d = tab_line-d
                                    e = tab_line-e ) ).

    out->write( data = itab9 name = `itab9` ).
    out->write( |\n| ).

    "Example using a FOR loop with the REDUCE operator and LET
    DATA(itab10) = REDUCE tt_type3( INIT tab = VALUE #( )
                                    FOR w5 IN itab1
                                    LET tableline = VALUE #( itab2[ key2 = w5-key1 ] OPTIONAL ) IN
                                    NEXT tab = VALUE #( BASE tab
                                    ( key1 = w5-key1
                                      a = w5-a
                                      b = w5-b
                                      d = tableline-d
                                      e = tableline-e ) ) ).

    out->write( data = itab10 name = `itab10` ).
    out->write( |\n| ).

**********************************************************************

    "Sorting internal tables

    out->write( zcl_demo_abap_aux=>heading( `56) Sorting internal tables` ) ).

    "Creating structured data types
    TYPES: BEGIN OF struc_sort1,
             a TYPE i,
             b TYPE string,
             c TYPE c LENGTH 1,
             d TYPE i,
           END OF struc_sort1.

    TYPES: BEGIN OF struc_sort2,
             a TYPE i,
             b TYPE i,
           END OF struc_sort2.

    "Creating internal tables
    DATA it1 TYPE TABLE OF struc_sort1 WITH NON-UNIQUE KEY a.
    DATA it2 TYPE TABLE OF struc_sort1 WITH DEFAULT KEY.

    "Filling internal tables
    it1 = VALUE #( ( a = 1 b = `c` c = 'z' d = 4 )
                   ( a = 3 b = `b` c = 'f' d = 3 )
                   ( a = 2 b = `d` c = 'r' d = 9 )
                   ( a = 4 b = `a` c = 'p' d = 3 )
                   ( a = 5 b = `b` c = 'x' d = 2 )
                   ( a = 5 b = `a` c = 'x' d = 0 )
                   ( a = 1 b = `c` c = 'y' d = 8 ) ).

    it2 = it1.

    out->write( `Original internal table content ` &&
      `(it1 and it2 have the same content)` ).
    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = it1 name = `it1` ).
    out->write( |\n| ).
    out->write( data = it2 name = `it2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `57) Sorting by primary table key` ) ).

    "Primary key: component a
    SORT it1.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `58) Sorting by primary table key in ascending` &&
      ` order` ) ).

    "The sorting result is the same as above (where ASCENDING is used
    "implicitly). Here, it is explicitly specified.
    SORT it1 ASCENDING.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `59) Sorting by primary table key respecting all ` &&
      `non-numeric fields` ) ).

    "Primary key: standard table key (all non-numeric fields)
    SORT it2.

    out->write( data = it2 name = `it2` ).

    "The following code is commented out on purpose because it
    "produces a syntax warning. The primary table key is empty.
    "A sorting has no effect.
    "SORT it3.
    "out->write( data = it3 name = `it3` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `60) Sorting by primary table key in ` &&
      `descending order` ) ).

    "Sorting in descending order and by primary table key
    SORT it1 DESCENDING.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `61) Sorting by explicitly specified component (1)` ) ).
    "Here, the component is the primary table key.
    "The sorting result is the same as above.
    SORT it1 BY a DESCENDING.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `62) Sorting by explicitly specified component (2)` ) ).

    "Sorting by arbitrary, non-key field
    SORT it1 BY d DESCENDING.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `63) Sorting by multiple explicitly specified` &&
      ` components` ) ).

    "Sorting by multiple components and specifying the sort order
    SORT it1 BY b ASCENDING c DESCENDING.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `64) Sorting by respecting the values of all` &&
      ` components` ) ).

    "Sorting by considering the values of each field of the table line
    SORT it1 BY table_line.

    out->write( data = it1 name = `it1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `65) Modifying Internal Table Content: Direct modification of recently read table lines` ) ).



    "direct modification of recently read table lines:

    "Declaring and populating demo internal tables
    TYPES: BEGIN OF ty_struc,
             comp1 TYPE i,
             comp2 TYPE string,
             comp3 TYPE c LENGTH 3,
           END OF ty_struc.

    DATA it_st TYPE TABLE OF ty_struc WITH NON-UNIQUE KEY comp1.
    DATA it_so TYPE SORTED TABLE OF ty_struc WITH UNIQUE KEY comp1.
    DATA it_ha TYPE HASHED TABLE OF ty_struc WITH UNIQUE KEY comp1.

    it_st = VALUE #( ( comp1 = 1 comp2 = `AAAAAA` comp3 = 'bbb' )
                     ( comp1 = 2 comp2 = `CCCCCC` comp3 = 'ddd' )
                     ( comp1 = 3 comp2 = `EEEEEE` comp3 = 'fff' )
                     ( comp1 = 4 comp2 = `GGGGGG` comp3 = 'hhh' )
                   ).

    it_so = it_st.
    it_ha = it_st.

    "---- Modifying internal table content by changing the ----
    "---- content of READ TABLE statement target areas --------
    "Reading table line into a target area
    READ TABLE it_st INTO DATA(workarea) INDEX 1.
    READ TABLE it_so ASSIGNING FIELD-SYMBOL(<f>) INDEX 2.
    READ TABLE it_ha REFERENCE INTO DATA(drf) WITH TABLE KEY comp1 = 3. "No reading by index in case of hashed tables

    "------ Modification examples -------
    "Modifying all non-key components using the VALUE operator and
    "the BASE addition
    <f> = VALUE #( BASE <f> comp2 = `IIIIII` comp3 = 'jjj' ).

    "In the following example, the key value is assigned a new
    "value. Key values are protected against change in case of key tables.
    "A runtime error occurs.
    "<f> = VALUE #( comp1 = 5 comp2 = `IIIIII` comp3 = 'jjj' ).

    drf->* = VALUE #( BASE drf->* comp2 = `KKKKKK` comp3 = 'lll' ).

    "Same as above. Key values cannot be changed in this case.
    "drf->* = VALUE #( comp1 = 5 comp2 = `MMMMMM` comp3 = 'nnn' ).

    "Using a MODIFY statement outlined below for changing internal
    "table content based on a read line in a work area
    MODIFY TABLE it_st FROM VALUE #( BASE workarea comp2 = `OOOOOO` comp3 = 'ppp' ).

    "Modifying individual components
    READ TABLE it_st INTO workarea INDEX 2.
    READ TABLE it_so ASSIGNING <f> INDEX 3.
    READ TABLE it_ha REFERENCE INTO drf WITH TABLE KEY comp1 = 4.

    "Using VALUE/BASE
    <f> = VALUE #( BASE <f> comp2 = `QQQQQQ` ).
    drf->* = VALUE #( BASE drf->* comp2 = `RRRRRR` ).
    MODIFY TABLE it_st FROM VALUE #( BASE workarea comp2 = `SSSSSS` ).

    "Using the component selector
    <f>-comp3 = 'ttt'.

    READ TABLE it_st INTO workarea INDEX 3.
    workarea-comp3 = 'uuu'.
    MODIFY TABLE it_st FROM workarea.

    "Object component selector in case of dereferencing ...
    drf->comp2 = `VVVVVV`.
    "... which is a more comfortable option compared to using the
    "dereferencing and component selector operators in the following workareay.
    drf->*-comp3 = 'www'.

    "---- Modifying internal table content using table expressions -----

    "Changing the entire table line of a standard table
    "In standard tables, the key value change is allowed.
    it_st[ 3 ] = VALUE #( comp1 = 9 comp2 = `XXXXXX` comp3 = 'yyy' ).
    "As above, the sorted table is a key table having a unique key,
    "therefore a write cannot be performed on the entire entry. Runtime
    "errors can occur.
    "it_so[ 3 ] = VALUE #( comp2 = `XXXXXX` comp3 = 'yyy' ).
    "The same applies to hashed tables.
    "it_ha[ comp2 = `OOOOOO` ] = VALUE #( comp2 = `XXXXXX` comp3 = 'yyy' ).

    "Changing individual components
    it_st[ 3 ]-comp2 = `ZZZZZZ`.
    it_so[ 3 ]-comp3 = 'A1'.
    it_ha[ comp2 = `CCCCCC` ]-comp2 = `B2`.
    "As above, no key field change in key tables. Allowed in standard
    "tables.
    "it_so[ 3 ]-comp1 = 10.
    "it_ha[ comp2 = `AAAAAA` ]-comp1 = `C3`.
    it_st[ 1 ]-comp1 = 99.

    "---- Modifying table content in all table rows in a loop ----
    "For more syntax options regarding loops, check the section above.
    "Target area: field symbol
    LOOP AT it_st ASSIGNING FIELD-SYMBOL(<lo>).
      <lo>-comp2 = sy-tabix.
    ENDLOOP.

    "---- Modifying table content restricting the rows that are looped across ----
    "Target area: data reference variable
    LOOP AT it_st REFERENCE INTO DATA(lo) FROM 2 TO 3.
      lo->comp3 = sy-tabix.
    ENDLOOP.

    "Target area: work area
    LOOP AT it_so INTO DATA(workarea_lo) WHERE comp1 < 4.
      workarea_lo-comp2 = sy-tabix.
      MODIFY TABLE it_so FROM workarea_lo.
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `66) Modifying Internal Table Content: MODIFY statements` ) ).

    "Creating structured data types.
    TYPES: "Line types for internal tables
      BEGIN OF struc1,
        a TYPE i,
        b TYPE c LENGTH 3,
        c TYPE c LENGTH 3,
        d TYPE c LENGTH 3,
      END OF struc1.

    "Declaring demo sorted/hashed tables having primary and
    "secondary keys as well as alias names defined

    DATA it_std TYPE TABLE OF struc1 WITH NON-UNIQUE KEY a.
    DATA it_so_sec TYPE SORTED TABLE OF struc1
      WITH NON-UNIQUE KEY primary_key ALIAS pk COMPONENTS a
      WITH NON-UNIQUE SORTED KEY sec_key ALIAS sk COMPONENTS b.

    DATA it_ha_sec TYPE HASHED TABLE OF struc1
      WITH UNIQUE KEY primary_key ALIAS pkh COMPONENTS a
      WITH NON-UNIQUE SORTED KEY sec_key_h ALIAS skh COMPONENTS b.

    "Filling internal table
    it_so_sec = VALUE #( ( a = 1 b = 'bbb' c = '###' d = '###' )
                         ( a = 2 b = 'ccc' c = '###' d = '###' )
                         ( a = 3 b = 'aaa' c = 'zzz' d = '###' )
                         ( a = 4 b = 'ddd' c = '###' d = '###' ) ).

    "Filling internal table with the content above
    it_ha_sec = it_so_sec.

    DATA(mod_line) = VALUE struc1( a = 2 b = 'zzz' c = 'yyy' ).

    "Standard table
    "With the addition FROM wa, the key values in wa determine the line
    "to be modified.
    "Note: Component d is not specified in "line". The value is
    "initialized.
    MODIFY TABLE it_std FROM mod_line.

    "Example in which the work area is constructed inline.
    "Components b and c not specified. The values are initialized.
    MODIFY TABLE it_std FROM VALUE #( a = 3 d = 'xxx' ).

    "Addition TRANSPORTING: Only specified fields are respected
    "Note: In case of sorted/hasehd tables, key values cannot be
    "specified.
    MODIFY TABLE it_std
      FROM VALUE #( a = 4 b = '###' c = '###' d = '###' )
      TRANSPORTING b c.

    "Modifying table lines via index
    "Note: It is only MODIFY, not MODIFY TABLE as above.
    "The following statement modifies the line with number 1 in the
    "primary table index. Without the addition TRANSPORTING, the
    "entire line is changed.
    MODIFY it_std
      FROM VALUE #( a = 1 b = 'aaa' c = 'aaa' d = 'aaa' )
      INDEX 1.

    "USING KEY: Determines the table key and thus which table index
    "to respect
    MODIFY it_so_sec
      FROM VALUE #( a = 1 b = 'EEE' c = 'EEE' d = 'EEE' )
      INDEX 1
      USING KEY primary_key
      TRANSPORTING c d.

    "Note: Without TRANSPORTING, the statement would overwrite the
    "secondary key which is not allowed.
    MODIFY it_ha_sec
      FROM VALUE #( a = 1 b = 'FFF' c = 'FFF' d = 'FFF' )
      INDEX 1
      USING KEY sec_key_h
      TRANSPORTING d.

    out->write( data = it_st name = `it_st` ).
    out->write( |\n| ).
    out->write( data = it_so_sec name = `it_so_sec` ).
    out->write( |\n| ).
    out->write( data = it_ha_sec name = `it_ha_sec` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `67) Deleting internal table content` ) ).

    "Deleting via index
    "Primary table index is used implicitly.
    DELETE it_st INDEX 1.

    "If USING KEY is not used, INDEX can only be used with index
    "tables. If a secondary key is specified, the secondary table
    "index is respected.
    "The following example has the same effect as above.
    DELETE it_st INDEX 1 USING KEY primary_key.

    "Hashed table. The secondary table index is respected.
    DELETE it_ha_sec INDEX 1 USING KEY sec_key_h.

    "Deleting multiple lines by specifying an index range
    "FROM or TO alone can also be specified
    DELETE it_so_sec FROM 2 TO 3.

    "Deleting via keys
    "When using the addition FROM wa, the line wa must have a
    "compatible type to the table's line type and include key values.
    "The first found line with the corresponding keys is deleted.
    "If the key is empty, no line is deleted.
    DELETE TABLE it_so_sec FROM VALUE #( a = 4 ).

    "Explicitly specifying the table key
    DELETE TABLE it_so_sec WITH TABLE KEY a = 1.

    DELETE TABLE it_ha_sec
      WITH TABLE KEY sec_key_h COMPONENTS b = 'bbb'.

    "Deleting multiple lines based on conditions
    "Note: Specifying the additions USING KEY/FROM/TO is also possible
    DELETE it_std WHERE a > 3.

    out->write( data = it_st name = `it_st` ).
    out->write( |\n| ).
    out->write( data = it_so_sec name = `it_so_sec` ).
    out->write( |\n| ).
    out->write( data = it_ha_sec name = `it_ha_sec` ).
    out->write( |\n| ).

    "Excursion: Deleting in a LIKE-like fashion you may know from
    "ABAP SQL statements.
    "The LIKE addition is not available for the WHERE clause in DELETE
    "statements for internal tables as is the case for ABAP SQL DELETE statements.
    DATA(stringtable) = VALUE string_table( ( `abcZ` ) ( `Zdef` ) ( `gZhi` )
                                            ( `Zjkl` ) ( `Zmno` ) ( `pqrZ` ) ).

    "You can, for example, use logical operators such as CP (conforms to pattern)
    "All lines that begin with Z are to be deleted.
    DELETE stringtable WHERE table_line CP `Z*`.

    out->write( data = stringtable name = `stringtable` ).
    out->write( |\n| ).

    "---------- Deleting the current line inside a LOOP statement ----------

    "The following example illustrates deleting the current table line
    "using a DELETE statement within a LOOP statement. Lines with even
    "numbers are deleted.
    "Note:
    "- The short form of the DELETE statement always deletes the
    "  current first line implicitly. It is only possible within a LOOP
    "  statement and the delete operation is performed on the same internal
    "  table.
    "- The field symbol (or reference variable) should not be used after
    "  the DELETE statement any more.
    DATA itab_del_loop1 TYPE TABLE OF i WITH EMPTY KEY.
    itab_del_loop1 = VALUE #( ( 1 ) ( 2 ) ( 3 ) ( 4 ) ( 5 ) ( 6 ) ( 7 ) ( 8 ) ( 9 ) ( 10 ) ).

    LOOP AT itab_del_loop1 ASSIGNING FIELD-SYMBOL(<fs_del_loop>).
      IF <fs_del_loop> MOD 2 = 0.
        DELETE itab_del_loop1.
      ENDIF.
    ENDLOOP.

    out->write( data = itab_del_loop1 name = `itab_del_loop1` ).
    out->write( |\n| ).

    "The following, similar example (uneven numbers are deleted) uses a
    "table which is looped over by specifying the addition USING KEY.
    "In this case (using LOOP ... USING KEY ...), the short form of the
    "DELETE statement cannot be used. Use the DELETE statement with the
    "addition USING KEY loop_key to delete the current first line.
    "loop_key is a predefined name to be used with DELETE and within
    "loops that specify LOOP ... USING KEY .... No other key name is
    "possible here.
    DATA itab_del_loop2 TYPE TABLE OF i WITH NON-UNIQUE KEY table_line.
    itab_del_loop2 = VALUE #( ( 1 ) ( 2 ) ( 3 ) ( 4 ) ( 5 ) ( 6 ) ( 7 ) ( 8 ) ( 9 ) ( 10 ) ).

    LOOP AT itab_del_loop2 USING KEY primary_key REFERENCE INTO DATA(dref2).
      IF dref2->* MOD 2 <> 0.
        DELETE itab_del_loop2 USING KEY loop_key.
      ENDIF.
    ENDLOOP.

    out->write( data = itab_del_loop2 name = `itab_del_loop2` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `68) Deleting adjacent duplicate entries` ) ).
    out->write( `Original table content (restored before` &&
      ` each of the following examples)` ).
    out->write( |\n| ).
    out->write( |\n| ).

    it_std = VALUE #( ( a = 1 b = 'BBB' c = '###' d = '###' )
                     ( a = 2 b = '###' c = '###' d = '###' )
                     ( a = 1 b = '###' c = '###' d = '###' )
                     ( a = 3 b = '###' c = '###' d = '###' )
                     ( a = 4 b = '###' c = 'CCC' d = '###' )
                     ( a = 1 b = 'BBB' c = '###' d = '###' )
                     ( a = 2 b = 'BBB' c = '###' d = '###' )
                     ( a = 4 b = 'BBB' c = '###' d = '###' )
                     ( a = 2 b = 'BBB' c = '###' d = '###' )
                     ( a = 3 b = '###' c = '###' d = '###' ) ).

    SORT it_std BY table_line.

    "Filling another table so that the same content above
    "is available for the examples below.
    DATA(it_std2) = it_std.

    out->write( data = it_std2 name = `it_std2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `69) Deleting adjacent duplicates based on` &&
      ` primary table key` ) ).

    "Note: Using the primary table key can have unexpected consequences
    "if the primary table key is the standard key or if it is empty.
    DELETE ADJACENT DUPLICATES FROM it_std2.

    out->write( data = it_std2 name = `it_std2` ).

    it_std2 = it_std.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `70) Deleting adjacent duplicates by comparing ` &&
      `all field values` ) ).

    DELETE ADJACENT DUPLICATES FROM it_std2 COMPARING ALL FIELDS.

    out->write( data = it_std2 name = `it_std2` ).

    it_std2 = it_std.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `71) Deleting adjacent duplicates by comparing ` &&
      `specific field values` ) ).

    DELETE ADJACENT DUPLICATES FROM it_std2 COMPARING a c.

    out->write( data = it_std2 name = `it_std2` ).

    it_std2 = it_std.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `72) Deleting adjacent duplicates by using a` &&
      ` table key` ) ).

    "In this case, the result is the same as in the first example.
    DELETE ADJACENT DUPLICATES FROM it_std2 USING KEY primary_key.

    out->write( data = it_std2 name = `it_std2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `73) Deleting the entire internal table content` ) ).

    CLEAR it_std.

    "Additionally, FREE releases memory space.
    FREE it_std2.

    "Excursion: Assigning an empty constructor expression with VALUE clears
    "the internal table.
    DATA(it_stdr) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ).

    it_stdr = VALUE #( ).

    "Same applies to NEW
    DATA(it_stdr_new) = NEW string_table( ( `a` ) ( `b` ) ( `c` ) ).
    it_stdr_new = NEW #( ).

    out->write( data = it_std name = `it_std` ).
    out->write( |\n| ).
    out->write( data = it_std2 name = `it_std2` ).
    out->write( |\n| ).
    out->write( data = it_stdr name = `it_stdr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `74) Grouping Internal Tables` ) ).


    TYPES: BEGIN OF demo_struct,
             comp1 TYPE c LENGTH 1,
             comp2 TYPE i,
             comp3 TYPE abap_boolean,
             comp4 TYPE string,
           END OF demo_struct,
           tab_type_for_grouping TYPE TABLE OF demo_struct WITH EMPTY KEY.
    DATA string_table TYPE string_table.

    "Populating a demo internal table as the basis of the syntax example
    "Note: The example loops only use data objects as targets, not data references
    "or field symbols.
    DATA(it) = VALUE tab_type_for_grouping( ( comp1 = 'd' comp2 = 0 comp3 = abap_false )
                               ( comp1 = 'a' comp2 = 1 comp3 = abap_true )
                               ( comp1 = 'a' comp2 = 2 comp3 = abap_false )
                               ( comp1 = 'e' comp2 = 11 comp3 = abap_true )
                               ( comp1 = 'b' comp2 = 5 comp3 = abap_true )
                               ( comp1 = 'b' comp2 = 6 comp3 = abap_false )
                               ( comp1 = 'a' comp2 = 3 comp3 = abap_false )
                               ( comp1 = 'b' comp2 = 4 comp3 = abap_true )
                               ( comp1 = 'c' comp2 = 10 comp3 = abap_true )
                               ( comp1 = 'e' comp2 = 1 comp3 = abap_false )
                               ( comp1 = 'd' comp2 = 7 comp3 = abap_true )
                               ( comp1 = 'a' comp2 = 4 comp3 = abap_true )
                               ( comp1 = 'e' comp2 = 111 comp3 = abap_true ) ).

    "The following example (and several others below) does not specify a nested loop.
    "It does not specify a group key binding either. This means that the work area
    "contains the first line of each group, representing the group in the loop
    "(representative binding). The comp4 component is assigned the sy-tabix value,
    "which is the number of the line in the table without the grouping.
    DATA ita LIKE it.
    LOOP AT it INTO DATA(waa) GROUP BY waa-comp1.
      waa-comp4 = sy-tabix.
      APPEND waa TO ita.
    ENDLOOP.
    out->write( data = ita name = `ita` ).
    out->write( |\n| ).

    "Specifying sort order
    DATA itb LIKE it.
    LOOP AT it INTO DATA(wab) GROUP BY wab-comp1 ASCENDING.
      wab-comp4 = sy-tabix.
      APPEND wab TO itb.
    ENDLOOP.
    out->write( data = itb name = `itb` ).
    out->write( |\n| ).

    "WITHOUT MEMBERS addition; a group key binding is required
    "after WITHOUT MEMBERS
    "The group key binding is added to a string table for visualizing its
    "content.
    "Note: The component values are initial when the group key binding is
    "specified.
    LOOP AT it INTO DATA(wac) GROUP BY wac-comp1 WITHOUT MEMBERS INTO DATA(keyc).
      ASSERT wac IS INITIAL.
      APPEND keyc TO string_table.
    ENDLOOP.
    out->write( data = string_table name = `string_table` ).
    out->write( |\n| ).

    "Using a structured group key
    "The following example just assigns component values to the group key. In this case,
    "the grouping is performed with more than just one criterion as in the previous examples.
    "As a result, table lines are added to the other table in descending order based on the
    "two component values.
    DATA itd LIKE it.
    LOOP AT it INTO DATA(wad) GROUP BY ( key1 = wad-comp1 key2 = wad-comp2 ) DESCENDING.
      APPEND wad TO itd.
    ENDLOOP.
    out->write( data = itd name = `itd` ).
    out->write( |\n| ).

    "In the following example, the group is sorted in ascending order. Note that the
    "group index value uses the original position in the group index. The group key
    "binding information is added to a string table for visualizing its content.
    CLEAR str_table.
    LOOP AT it INTO DATA(wae) GROUP BY ( key = wae-comp1 gi = GROUP INDEX gs = GROUP SIZE ) ASCENDING INTO DATA(keye).
      APPEND |Key component: '{ keye-key }', group index: '{ keye-gi }', group size: '{ keye-gs }'| TO string_table.
    ENDLOOP.
    out->write( data = string_table name = `string_table` ).
    out->write( |\n| ).

    "LOOP AT GROUP: Nested loop across group members
    "Unlike the previous example, the example uses a nested loop across the groups (the group key binding is
    "specified after LOOP AT GROUP). There, the component values of the members can be accessed.
    DATA itf LIKE it.
    LOOP AT it INTO DATA(waf) GROUP BY ( key = waf-comp1 gi = GROUP INDEX gs = GROUP SIZE ) ASCENDING INTO DATA(keyf).
      LOOP AT GROUP keyf INTO DATA(memberf).
        APPEND VALUE #( comp1 = memberf-comp1 comp2 = memberf-comp2 comp3 = memberf-comp3
        comp4 = |Key component: '{ keyf-key }', group index: '{ keyf-gi }', group size: '{ keyf-gs }'|
        ) TO itf.
      ENDLOOP.
    ENDLOOP.
    out->write( data = itf name = `itf` ).
    out->write( |\n| ).

    "The objective of this example is to extract the line with the highest value in a particular
    "column within a group from the original table to another.
    "The example uses representative binding, i.e. the representative of the group is specified
    "in the work area, not in a group key binding.
    DATA itg LIKE it.
    LOOP AT it INTO DATA(wag) GROUP BY wag-comp1 ASCENDING.
      LOOP AT GROUP wag INTO DATA(memberg) GROUP BY memberg-comp2 DESCENDING.
        APPEND memberg TO itg.
        EXIT.
      ENDLOOP.
    ENDLOOP.
    out->write( data = itg name = `itg` ).
    out->write( |\n| ).

    "The following example is similar to the previous example, and yields the same result.
    "Here, the group key binding is specified after LOOP AT GROUP.
    DATA ith LIKE it.
    LOOP AT it INTO DATA(wah) GROUP BY wah-comp1 ASCENDING.
      LOOP AT GROUP wah INTO DATA(memberh) GROUP BY memberh-comp2 DESCENDING.
        APPEND memberh TO ith.
        EXIT.
      ENDLOOP.
    ENDLOOP.
    ASSERT itg = ith.
    out->write( data = ith name = `ith` ).
    out->write( |\n| ).

    "Additional syntax options, like specifying a WHERE condition in both nested and outer
    "loops, are possible. The example below shows that the LOOP AT GROUP statement assigns
    "the value of sy-tabix to the value that would be set for the current line in the LOOP
    "without grouping.
    DATA iti LIKE it.
    LOOP AT it INTO DATA(wai) GROUP BY wai-comp1 ASCENDING.
      LOOP AT GROUP wai INTO DATA(memberi) WHERE comp3 = abap_true.
        APPEND VALUE #( comp1 = memberi-comp1 comp2 = memberi-comp2 comp3 = memberi-comp3
        comp4 = |sy-tabix: '{ sy-tabix }'|
        ) TO iti.
      ENDLOOP.
    ENDLOOP.
    out->write( data = iti name = `iti` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `75) Collecting Values` ) ).

    "This example demonstrates how to insert data from a database table
    "into an internal table in a compressed way. Within a SELECT loop,
    "a COLLECT statement is used to consolidate lines with identical
    "primary key components (carrid and connid) by summing the number
    "of occupied seats in the numeric component (seatsocc).
    "Additionally, an internal table is filled by adding all read lines.
    "This table is looped across to simulate the effect of the COLLECT
    "statement.

    DATA: BEGIN OF seats,
            carrid   TYPE zdemo_abap_fli-carrid,
            connid   TYPE zdemo_abap_fli-connid,
            seatsocc TYPE zdemo_abap_fli-seatsocc,
          END OF seats,
          seats_tab_col      LIKE HASHED TABLE OF seats WITH UNIQUE KEY carrid connid,
          seats_tab_all      LIKE TABLE OF seats WITH EMPTY KEY,
          seats_tab_loop_grp LIKE seats_tab_col.

    SELECT carrid, connid, seatsocc
            FROM zdemo_abap_fli
            INTO @seats.
      COLLECT seats INTO seats_tab_col.
      APPEND seats TO seats_tab_all.
    ENDSELECT.

    out->write( data = seats_tab_all name = `seats_tab_all` ).
    out->write( |\n| ).

    LOOP AT seats_tab_all INTO DATA(wa_coll) GROUP BY ( key1 = wa_coll-carrid key2 = wa_coll-connid ).
      INSERT VALUE #( carrid = wa_coll-carrid connid = wa_coll-connid ) INTO TABLE seats_tab_loop_grp ASSIGNING FIELD-SYMBOL(<fsgr>).
      LOOP AT GROUP wa_coll INTO DATA(member).
        <fsgr>-seatsocc = <fsgr>-seatsocc + member-seatsocc.
      ENDLOOP.
    ENDLOOP.

    ASSERT seats_tab_loop_grp = seats_tab_col.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Excursions` ) ).
    out->write( |76) Secondary table keys and hashed tables\n\n| ).

    "Declaring a hashed table
    DATA hashed_table
        TYPE HASHED TABLE OF zdemo_abap_tab1
           WITH UNIQUE KEY primary_key COMPONENTS key_field
           WITH NON-UNIQUE SORTED KEY sec_key COMPONENTS char1 char2.

    "Retrieving data to work with
    SELECT * FROM zdemo_abap_tab1 INTO TABLE @hashed_table UP TO 3 ROWS.

    "Integer table to display the table index
    DATA int_itab TYPE TABLE OF i.

    "Note: There is no primary table index in hashed tables.
    LOOP AT hashed_table INTO DATA(hwa) USING KEY primary_key.
      APPEND sy-tabix TO int_itab.
    ENDLOOP.

    out->write( data = int_itab name = `int_itab` ).
    out->write( |\n| ).

    CLEAR int_itab.

    "Demonstrating the secondary table index when using
    "the secondary key
    LOOP AT hashed_table INTO DATA(hwa2) USING KEY sec_key.
      APPEND sy-tabix TO int_itab.
    ENDLOOP.

    out->write( data = int_itab name = `int_itab` ).
    out->write( |\n| ).

    "Retrieving a table line via index access to the secondary index
    "of the sorted secondary key
    DATA(line_of_ht) = hashed_table[ KEY sec_key INDEX 2 ].

    out->write( data = line_of_ht name = `line_of_ht` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `77) Empty keys in internal table created inline` ) ).
    "This example visualizes the fact that when using an inline
    "construction like INTO TABLE @DATA(itab) in SELECT statements, the
    "resulting table has an empty table key. Here, the key information
    "is retrieved using RTTI. The output shows the key information:
    "the information on the first internal table includes the key as
    "specified (key_field as the primary key, non-unique - since
    "key_kind is U and is_unique is not flagged. The result for the
    "other internal table shows that there is no key name at all and
    "key_kind is E (= empty).

    "An internal table representing an existing table having table keys
    "defined in contrast to an internal table created inline.
    DATA it_with_key TYPE TABLE OF zdemo_abap_tab1
           WITH NON-UNIQUE KEY key_field.

    "Retrieving data to work with
    SELECT * FROM zdemo_abap_tab1 INTO TABLE @it_with_key UP TO 3 ROWS.
    SELECT * FROM zdemo_abap_tab1 INTO TABLE @DATA(it_inline)
      UP TO 3 ROWS.

    "Using RTTI to retrieve the key information
    DATA(k1) = CAST cl_abap_tabledescr(
                        cl_abap_typedescr=>describe_by_data(
                          it_with_key )
                            )->get_keys( ).


    out->write( data = k1 name = `k1` ).
    out->write( |\n| ).

    DATA(k2) = CAST cl_abap_tabledescr(
                        cl_abap_typedescr=>describe_by_data(
                          it_inline )
                            )->get_keys( ).

    out->write( data = k2 name = `k2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `78) Ranges tables` ) ).

    "Populating an integer table with values from 1 to 20
    TYPES intgr_tab_type TYPE TABLE OF i WITH EMPTY KEY.
    DATA(inttab) = VALUE intgr_tab_type( FOR x = 1 WHILE x <= 20 ( x ) ).

    "Declaring a ranges table
    DATA rangestab TYPE RANGE OF i.

    "Populating a ranges table using VALUE
    rangestab = VALUE #( sign   = 'I'
                         option = 'BT' ( low = 1  high = 3 )
                                       ( low = 6  high = 8 )
                                       ( low = 12 high = 15 )
                         option = 'GE' ( low = 18 ) ).

    "Using a SELECT statement and the IN addition to retrieve internal table
    "content based on the ranges table specifications
    SELECT * FROM @inttab AS tab
        WHERE table_line IN @rangestab
        INTO TABLE @DATA(result).

    out->write( data = result name = `result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `79) Creating Internal Tables Dynamically` ) ).

    DATA(some_type) = 'STRING'.
    DATA dataref TYPE REF TO data.

    "Creating an internal table using a CREATE DATA statement
    "by specifying the type name dynamically.
    "In the example, a standard table with elementary line type
    "and standard key is created.
    CREATE DATA dataref TYPE TABLE OF (some_type).

    TYPES: BEGIN OF demo_struc,
             comp1 TYPE c LENGTH 10,
             comp2 TYPE i,
             comp3 TYPE i,
           END OF demo_struc.

    "Internal table with structured line type and empty key.
    CREATE DATA dataref TYPE TABLE OF ('DEMO_STRUC') WITH EMPTY KEY.

    "Using a globally available table type
    CREATE DATA dataref TYPE ('STRING_TABLE').

    out->write( zcl_demo_abap_aux=>no_output ).

  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_objects DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC
  GLOBAL FRIENDS zcl_demo_abap_objects_friend.

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun,
      zdemo_abap_objects_interface.
    ALIASES triple FOR zdemo_abap_objects_interface~triple.

    METHODS: hallo_instance_method,
      "Demo method for self-reference me
      me_ref_meth EXPORTING e1 TYPE string e2 TYPE string.

    DATA: another_string TYPE string VALUE `I'm just a public string.`.

    CLASS-METHODS:
      hallo_static_method.

    CLASS-DATA: string        TYPE string,
                public_string TYPE string VALUE `I'm a string from a friend's public section. I'm accessible anyway.`.

  PROTECTED SECTION.
    CLASS-DATA: protected_string TYPE string VALUE `I'm a string from a friend's protected section.`.

  PRIVATE SECTION.

    CLASS-DATA:
      private_string TYPE string VALUE `I'm a string from a friend's private section.`.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_objects IMPLEMENTATION.


  METHOD hallo_instance_method.
    string = |Hallo { sy-uname }. | &&
             |I'm an instance method of class zcl_demo_abap_objects.|.
  ENDMETHOD.


  METHOD hallo_static_method.
    string = |Hallo { sy-uname }. | &&
             |I'm a static method of class zcl_demo_abap_objects.|.
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: ABAP Object Orientation (1)\n\n| ).
    out->write( |Working with objects and components\n\n| ).
    out->write( |1) Declaring reference variables\n\n| ).

    "To create an object, a reference variable must be declared. This
    "variable is also necessary for accessing objects, i. e. objects
    "are not directly accessed but only via references that "point to"
    "those objects. And this reference is stored in the reference
    "variables. The example below demonstrate multiple reference
    "variables that are created using statements with TYPE REF TO.
    "LIKE is also possible. You can also create a type with
    "TYPE REF TO.

    DATA: ref1a TYPE REF TO local_class,
          ref1b TYPE REF TO local_class,
          ref1c LIKE ref1a.

    TYPES: ref_type TYPE REF TO local_class.
    DATA: ref1d TYPE ref_type.

    IF  ref1a IS INITIAL
    AND ref1b IS INITIAL
    AND ref1c IS INITIAL
    AND ref1d IS INITIAL.
      out->write( `The declared reference variables are initial.` ).
    ELSE.
      out->write( `One or more of the declared reference ` &&
                    `variables are not initial.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Creating objects` ) ).

    "You create an object in the memory of an application by using the
    "instance operator NEW. In doing so, a new instance of a
    "class is created and the "address" of the instance is put into the
    "reference variable. The # sign means to use the type (TYPE REF TO)
    "of the reference variable. You can also omit the explicit
    "declaration of a reference variable by declaring a new reference
    "variable inline. In this case, the name of the class must be
    "placed after NEW. As an alternative to the NEW operator, you can
    "also use the older CREATE OBJECT statements.

    DATA ref2a TYPE REF TO local_class.

    ref2a = NEW #( ).
    DATA(ref2b) = NEW local_class( ).

    "NEW replaces the following statement
    CREATE OBJECT ref2a.

    IF ref2a IS INSTANCE OF local_class
    AND ref2b IS INSTANCE OF local_class.
      out->write( `ref2a and ref2b point to instances ` &&
                    `of the class local_class.` ).
    ELSE.
      out->write( `One or more of the reference variables ` &&
      `do not point to instances of the class local_class.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Assigning object references` ) ).

    "Without an assignment, the reference variable is empty.
    "To assign or copy reference variable, use the assignment operator
    "=. In the example below, both reference variables have the same
    "type.

    DATA: ref3a TYPE REF TO local_class,
          ref3b TYPE REF TO local_class.

    ref3a = ref3b.

    IF ref3a = ref3b.
      out->write( `ref3b has been assigned to ref3a.` ).
    ELSE.
      out->write( `ref3b has not been assigned to ref3a.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Overwriting object references` ) ).

    "An object reference is overwritten when a new object is created
    "with a reference variable already pointing to an instance.
    "The class is implemented in a way that the number of instances
    "that are created is counted. In this example, the output is
    "just to visualize that the first ref4 is indeed overwritten.

    DATA ref4 TYPE REF TO local_class.

    ref4 = NEW #( ).

    out->write( data = ref4->no_of_instances name = `ref4->no_of_instances` ).
    out->write( |\n| ).

    ref4 = NEW #( ).

    out->write( data = ref4->no_of_instances name = `ref4->no_of_instances` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Keeping references variables in internal tables` ) ).

    "The following code shows that the reference variable is
    "overwritten in the course of the loop multiple times.
    "Since the reference variables are stored in an internal table, the
    "current state of the object is not lost once the reference
    "variable is overwritten. The difference in the retained state of
    "the object is visible in the timestamp und uuid field. The values
    "are created in the constructor when an instance is instantiated.

    DATA: ref5  TYPE REF TO local_class,
          itab5 TYPE TABLE OF REF TO local_class.

    DO 3 TIMES.
      ref5 = NEW #( ).
      itab5 = VALUE #( BASE itab5 ( ref5 ) ).
    ENDDO.

    out->write( data = itab5 name = `itab5` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Clearing object references` ) ).

    "Use CLEAR statements to explicitly clear a reference variable.
    "Since objects use up space in the memory, they should be cleared
    "if they are no longer needed. Actually, the garbage collector
    "takes over this task automatically, i. e. all objects without any
    "reference are cleared and the memory space is released.

    DATA ref6 TYPE REF TO local_class.

    ref6 = NEW #( ).

    CLEAR ref6.

    IF ref6 IS INITIAL.
      out->write( `ref6 is initial.` ).
    ELSE.
      out->write( `ref6 is not initial.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Accessing and using attributes` ) ).

    "Instance attributes are accessed using the object component
    "selector -> via a reference variable. Visible static attributes
    "are accessed using the class component selector => via the class
    "name. You can also declare data objects and types by referring
    "to those attributes.

    DATA ref7 TYPE REF TO local_class.
    ref7 = NEW #( ).

    "Instance + static attribute from individual objects.
    DATA(obj_instance_attr) = ref7->num_inst.
    DATA(obj_static_attr_obj) = ref7->num_stat.

    "Static attributes
    DATA(class_static_attr) = local_class=>num_stat.

    "Data objects and types whose type definitions can be based on
    "static class attributes
    DATA  some_int       LIKE local_class=>num_stat.
    DATA  some_other_int TYPE local_class=>type_i.
    TYPES int_type       TYPE local_class=>type_i.

    out->write( data = obj_instance_attr name = `obj_instance_attr` ).
    out->write( |\n| ).
    out->write( data = obj_static_attr_obj name = `obj_static_attr_obj` ).
    out->write( |\n| ).
    out->write( data = class_static_attr name = `class_static_attr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Calling static and instance methods` ) ).

    "Similar to accessing attributes, instance methods are called
    "using -> via a reference variable. Static methods are called
    "using => via the class name. When used within the class in which
    "it is declared, the static method can also be called without
    "class_name=>.... You might also see method calls with CALL
    "METHOD statements which are not used here. When methods are
    "called, the parameters must be specified within the parentheses.
    "If methods are within the class where they are called, a class
    "specification is not needed. In the example below, the methods
    "have no parameters defined, hence, there is no specification
    "within the parentheses. The methods just change the value of
    "a public static variable.

    "Instance methods
    DATA(ref8) = NEW zcl_demo_abap_objects( ).
    ref8->hallo_instance_method( ).

    out->write( data = string name = `string` ).
    out->write( |\n| ).

    "Static methods
    lcl_demo=>hallo_static_ext( ).

    out->write( data = lcl_demo=>string name = `lcl_demo=>string` ).
    out->write( |\n| ).

    "If methods are within the class where they are called,
    "the class name can be omitted.
    zcl_demo_abap_objects=>hallo_static_method( ).

    hallo_static_method( ).

    out->write( data = string name = `string` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Calling methods: Examples` &&
                  ` with importing parameters` ) ).

    "The example shows method calls. The methods used have only one or
    "two importing parameters.
    "One importing parameter:
    "- Note that you export the values to the method (which has
    "  importing parameters), hence, the method call includes
    "  EXPORTING.
    "- If the method has only one importing parameter, you can omit the
    "  explicit assignment of the value to the parameter and just specify
    "  the value that you want to pass. The specification of EXPORTING
    "  can be omitted, too.
    "- Hence, the first three method calls do all the same.
    "Two importing parameters:
    "- All mandatory parameters must be specified.
    "- Also here, the specification of EXPORTING can be omitted.
    "- The last method includes an optional parameter. In this case, it
    "  is of type i. Hence, its value remains initial ('0') since it is
    "  not specified.
    "To keep the code lean, only static methods are covered.

    "Method with one importing parameter.
    lcl_demo=>powers_of_two( 4 ).

    out->write( data = lcl_demo=>calc_result name = `lcl_demo=>calc_result` ).
    out->write( |\n| ).

    lcl_demo=>powers_of_two( i_pow = 5 ).

    out->write( data = lcl_demo=>calc_result name = `lcl_demo=>calc_result` ).
    out->write( |\n| ).

    lcl_demo=>powers_of_two( EXPORTING i_pow = 6 ).

    out->write( data = lcl_demo=>calc_result name = `lcl_demo=>calc_result` ).
    out->write( |\n| ).

    "Method with two importing parameters
    lcl_demo=>addition( i_add1 = 1 i_add2 = 4 ).

    out->write( data = lcl_demo=>calc_result name = `lcl_demo=>calc_result` ).
    out->write( |\n| ).

    lcl_demo=>addition_optional( i_add_mand = 1 ).

    out->write( data = lcl_demo=>calc_result name = `lcl_demo=>calc_result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Calling methods: Examples ` &&
                  `with exporting parameters` ) ).

    "Note: The methods have exporting parameters defined in the signature,
    "hence, when calling the method, the ABAP word IMPORTING must be used to
    "address the values.
    "In the first method call below, the variable that holds the imported
    "value is declared inline. It receives the type automatically.
    "The second method below has two importing parameters and one exporting
    "parameter (which is actually the result of a calculation). If a method
    "has, for example, importing and exporting parameters but you do not
    "want to take the exporting parameters into your program, you can write
    "the method call as though the method had only importing parameters.
    "Likewise, if a method has a single obligatory importing parameter and
    "several optional parameters and you do not want to specify the optional
    "parameters, you can write the method call as if the method had only one
    "importing parameter.

    lcl_demo=>exporting_hallo( IMPORTING text = DATA(hallo) ).

    lcl_demo=>subtraction( EXPORTING i_sub1 = 10 i_sub2 = 7
                           IMPORTING e_sub_result = DATA(subtraction_result) ).

    out->write( data = hallo name = `hallo` ).
    out->write( |\n| ).
    out->write( data = subtraction_result name = `subtraction_result` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Calling methods: Example with changing parameter` ) ).

    "Changing parameters define one or multiple parameters that can
    "be both imported and exported. They should be reserved for
    "changing an existing local variable and value.

    DATA num TYPE decfloat34 VALUE '144'.

    lcl_demo=>square_root( CHANGING i_sqr = num ).

    out->write( data = num name = `num` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Calling methods: Examples with returning parameters` ) ).

    "Methods having a returning parameter are called functional methods.
    "Returning parameters are preferable to exporting parameters since they
    "not only make the call shorter, they also allow method chaining and
    "they do not require the use of temporary variables because they can be
    "used in conjunction with other statements.
    "Functional methods can be called directly from within various
    "expressions (e. g. logical expressions with IF) without temporarily
    "storing values.
    "The use of receiving parameters is only possible for standalone method
    "calls and not for functional method calls.
    "The code below also includes an example for method chaining. Here, the
    "global class cl_abap_random_int is used with which random integers can
    "be created.

    DATA(mult_result) = lcl_demo=>multiplication( i_mult1 = 4
                                                   i_mult2 = 5 ).

    out->write( data = mult_result name = `mult_result` ).
    out->write( |\n| ).

    "Comparing a method having exporting parameters doing the same.
    lcl_demo=>multiplication_exp_param( EXPORTING i_multa = 5
                                                  i_multb = 6
                                        IMPORTING e_mult_result = DATA(mult_res_exp) ).

    out->write( data = mult_res_exp name = `mult_res_exp` ).
    out->write( |\n| ).

    "Example with a logical expression
    IF lcl_demo=>multiplication( i_mult1 = 5 i_mult2 = 3 ) < 20.
      out->write( |The value is lower than 20.| ).
    ELSE.
      out->write( |The value is greater than 20.| ).
    ENDIF.

    out->write( |\n| ).

    "Receiving parameter
    lcl_demo=>multiplication( EXPORTING i_mult1 = 10
                                        i_mult2 = 11
                              RECEIVING r_mult_result = DATA(res_received) ).

    out->write( data = res_received name = `res_received` ).
    out->write( |\n| ).

    "Example for method chaining using a global class.
    DATA(random_no1) = cl_abap_random_int=>create( )->get_next( ).

    "Specifying the optional min and max importing parameters.
    DATA(random_no2) = cl_abap_random_int=>create( seed = cl_abap_random=>seed( )
                                                   min  = 1
                                                   max  = 10 )->get_next( ).

    "Using method chaining as above saves the extra declaration
    "of variables.
    DATA(ref_randnom_no) = cl_abap_random_int=>create( seed = cl_abap_random=>seed( )
                                                       min  = 20
                                                       max  = 30 ).

    DATA(random_no3) = ref_randnom_no->get_next( ).

    out->write( data = random_no1 name = `random_no1` ).
    out->write( |\n| ).
    out->write( data = random_no2 name = `random_no2` ).
    out->write( |\n| ).
    out->write( data = random_no3 name = `random_no3` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Calling methods: Examples with error handling` ) ).

    "The examples show two method calls for a method that includes a
    "raising parameter. For this method, a class-based exception is
    "specified. The exception is raised for the second method
    "call. The third method call just gives
    "a rough idea on raising exceptions: The current time is checked
    "and if it is currently a certain time of the day, an exception
    "is raised.

    "Method with raising parameter (class-based exception)
    DATA(div_result1) = lcl_demo=>division( i_div1 = 5
                                            i_div2 = 2 ).

    IF lcl_demo=>string IS INITIAL.
      out->write( data = div_result1 name = `div_result1` ).
    ELSE.
      out->write( |Calculation error: { lcl_demo=>string }| ).
    ENDIF.

    out->write( |\n| ).

    DATA(div_result2) = lcl_demo=>division( i_div1 = 1 i_div2 = 0 ).
    IF lcl_demo=>string IS INITIAL.
      out->write( data = div_result2 name = `div_result2` ).
    ELSE.
      out->write( |Calculation error: { lcl_demo=>string }| ).
    ENDIF.

    out->write( |\n| ).

    "Method with RAISING addition (class-based exceptions)
    TRY.
        lcl_demo=>check_daytime(
          EXPORTING time = cl_abap_context_info=>get_system_time( )
          IMPORTING greetings = DATA(greets) ).
      CATCH cx_afternoon.
        DATA(subrc) = 11.
      CATCH cx_night.
        subrc = 33.
    ENDTRY.

    out->write( data = greets name = `greets` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) Constructors` ) ).

    "Constructors cannot be explicitly called like other methods.
    "The examples demonstrate instance and static constructors.
    "The first three method calls show instance constructors. The
    "implementation of the instance constructor includes several things.
    "Among them, getting a time stamp and a uuid, counting the number of
    "instances, updating a string, and carrying out a division. The output
    "also shows the effect of calling the static constructor. Check the
    "string in the field stat_text and see that it has not changed compared
    "to the instance attribute in_text. The third method call shows that an
    "instance cannot be created if an error occurs in the instance
    "constructor method (initial reference variable).
    "The effect of the static constructor is demonstrated by the fourth
    "method call. The value of the variable stat_text has not changed
    "compared to the other method calls before when outputting it. The
    "value of variable stat_number only changes when calling this particular
    "method (it explicitly changes the value of the variable).

    "Instance constructor
    TRY.
        DATA(ref14a) = NEW lcl_constructors( num1 = 10 num2 = 5 ).
      CATCH cx_sy_zerodivide INTO DATA(error).
        out->write( data = error->get_text( ) name = `error->get_text( )` ).
    ENDTRY.

    out->write( data = ref14a name = `ref14a` ).
    out->write( |\n| ).

    TRY.
        DATA(ref14b) = NEW lcl_constructors( num1 = 18 num2 = 6 ).
      CATCH cx_sy_zerodivide INTO error.
        out->write( data = error->get_text( ) name = `error->get_text( )` ).
    ENDTRY.

    out->write( data = ref14b name = `ref14b` ).
    out->write( |\n| ).

    TRY.
        DATA(ref14c) = NEW lcl_constructors( num1 = 1 num2 = 0 ).
      CATCH cx_sy_zerodivide INTO error.
        out->write( |Error with ref14c: { error->get_text( ) }| ).
    ENDTRY.

    out->write( data = ref14c name = `ref14c` ).
    out->write( |\n| ).

    "Static constructor
    lcl_constructors=>add_1( ).

    out->write( data = lcl_constructors=>stat_text name = `lcl_constructors=>stat_text` ).
    out->write( |\n| ).
    out->write( data = lcl_constructors=>stat_number name = `lcl_constructors=>stat_number` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Parameters: Generic types` ) ).

    "The use of generic types in method signatures is particularly relevant
    "for dynamic programming. The code shows various examples of parameters
    "typed with DATA and ANY TABLE. In the method implementation, all values
    "of the variables are stored in a data reference variable that is
    "displayed.

    DATA(int) = 4.

    lcl_demo=>generic_data( EXPORTING i_data = int ).

    out->write( data = lcl_demo=>some_data->* name = `lcl_demo=>some_data->*` ).
    out->write( |\n| ).

    DATA strtab TYPE TABLE OF string.

    strtab = VALUE #( ( `I'm a ` ) ( `string table.` ) ).

    lcl_demo=>generic_data( EXPORTING i_data = strtab ).

    out->write( data = lcl_demo=>some_data->* name = `lcl_demo=>some_data->*` ).
    out->write( |\n| ).

    DATA int_tab TYPE TABLE OF i.

    int_tab = VALUE #( ( 1 ) ( 2 ) ( 3 ) ).

    DATA c_tab TYPE TABLE OF c.

    c_tab = VALUE #( ( 'a' ) ( 'b' ) ( 'c' ) ).

    lcl_demo=>generic_tab( EXPORTING i_anytab = int_tab ).

    out->write( data = lcl_demo=>some_data->* name = `lcl_demo=>some_data->*` ).
    out->write( |\n| ).

    lcl_demo=>generic_tab( EXPORTING i_anytab = c_tab ).

    out->write( data = lcl_demo=>some_data->* name = `lcl_demo=>some_data->*` ).
    out->write( |\n| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Inheritance: Method redefinition` ) ).

    "The example demonstrates inheritance in a very rudimentary way.
    "Class 1 is the superclass of class 2 that inherits from class 1. The
    "same is true for class 2 and class 3. Class 3 is defined with the
    "addition FINAL, so another class cannot inherit from this one. All
    "classes implement or redefine respectively a certain method. In this
    "case, it is a method that adapts a string. The redefined methods
    "access the method of the superclass by specifying super->....

    "Class 1
    DATA(ref_inh1) = NEW lcl_class1( ).

    DATA(first_string) = ref_inh1->get_string( ).

    "Class 2
    DATA(ref_inh2) = NEW lcl_class2a( ).

    DATA(second_string) = ref_inh2->get_string( ).

    "Class 3
    DATA(ref_inh3) = NEW lcl_class3a( ).

    DATA(third_string) = ref_inh3->get_string( ).

    out->write( data = first_string name = `first_string` ).
    out->write( |\n| ).
    out->write( data = second_string name = `second_string` ).
    out->write( |\n| ).
    out->write( data = third_string name = `third_string` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) Polymorphism and Casting` ) ).

    "The ref_pol1 object reference variable is created and points to class
    "lcl_class1, i. e. the superclass. The ref_pol2 object reference
    "variable points to class lcl_class2, i. e. the subclass of lcl_class1.
    "At this stage, both the static type and dynamic type of the object
    "reference variable ref_pol1 are the same. Then, the object reference
    "variable with the type of the subclass is assigned to this reference
    "variable, i. e. an upcast is triggered. The output shows the outcome of
    "a method call using this object reference variable before and after the
    "upcast. The first method call before the upcast demonstrates that the
    "method from the superclass is called. The second method call after the
    "upcast shows the polymorphism concept since the method call happens via
    "the same object reference variable as before. However, at this stage,
    "the reference variable points to another object, i. e. the dynamic type
    "of the reference variable is now lcl_class2. Hence, the redefined
    "method in the subclass having the same name as the method in the
    "superclass is called. It is also shown that the casting might be done
    "when creating the object.

    DATA(ref_pol1) = NEW lcl_class1( ).

    DATA(ref_pol2) = NEW lcl_class2a( ).

    DATA(str1) = ref_pol1->get_string( ).

    "Upcast
    ref_pol1 = ref_pol2.

    DATA(str2) = ref_pol1->get_string( ).

    "The casting might be done when creating the object
    DATA ref_pol_super TYPE REF TO lcl_class1.

    ref_pol_super = NEW lcl_class2a( ).

    out->write( data = str1 name = `str1` ).
    out->write( |\n| ).
    out->write( data = str2 name = `str2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18a) Downcast` ) ).

    "In this example, the possibility of downcasts are checked, i. e. the
    "assignment of a more generic object reference variable to a specific
    "one. At the beginning, an internal table is just created for displaying
    "purposes. The classes lcl_class2a and lcl_class2b are both subclasses
    "of lcl_class1. Various objects with reference to these subclasses are
    "created providing a "name" for the objects. Here, some of the objects
    "are created separately, some are directly declared when adding them to
    "the table. An internal table with reference to the superclass
    "lcl_class1 is created. All of the objects are then inserted into this
    "internal table. In doing so, an implicit upcast takes place here (it is
    "basically the assignment of an object reference variable pointing to
    "the subclass to a variable pointing to a superclass). As a next step,
    "all objects in the internal table are looped across. In each iteration,
    "checks are implemented to find out if downcasts are possible. First, a
    "check is implemented using a TRY ... ENDTRY block. This statement checks if
    "an object reference variable of lcl_class1 can be cast down to one of
    "lcl_class2a. If it is possible, a message is written into a dedicated
    "field of the display table. Plus, a method is called that is only
    "available in lcl_class2a. Note: The method just returns a random
    "number. The return value is written to the display table, too. If the
    "downcast is not possible, a message is written to the table, too. The
    "second check is implemented in a similar way, however, the check is
    "implemented using the predicate expression IS INSTANCE OF. Using this
    "syntax, the code gets leaner while achieving the same as using a TRY ...
    "ENDTRY block without handling the cx_sy_move_cast_error error
    "separately.

    "Creating an internal table for displaying purposes
    TYPES: BEGIN OF dc_check_struc,
             object_name TYPE string,
             a_check     TYPE string,
             b_check     TYPE string,
             a_number    TYPE i,
             b_number    TYPE i,
           END OF dc_check_struc.

    DATA dc_check TYPE TABLE OF dc_check_struc.

    "Creating internal table to hold various objects
    DATA: obj_itab TYPE TABLE OF REF TO lcl_class1.

    "Creating various objects ...
    DATA(oref1) = NEW lcl_class2a( `Object A1` ).
    DATA(oref2) = NEW lcl_class2a( `Object A2` ).

    "... and adding them to the internal table.
    "Some of the objects are directly declared when assigning them.
    obj_itab = VALUE #( ( oref1 )
                        ( oref2 )
                        ( NEW lcl_class2a( `Object A3` ) )
                        ( NEW lcl_class2b( `Object B1` ) )
                        ( NEW lcl_class2b( `Object B2` ) )
                        ( NEW lcl_class2b( `Object B3` ) ) ).

    "Looping across all objects in the internal table.
    LOOP AT obj_itab ASSIGNING FIELD-SYMBOL(<fs1>).
      "Adding an entry for the display table.
      "Here, only the name of the object.
      dc_check = VALUE #( BASE dc_check
          ( object_name = <fs1>->get_obj_name( ) ) ).

      "First check if downcasts are possible using TRY ENDTRY block.
      TRY.
          "lcl_class1 to be cast down to lcl_class2a
          DATA(o_dc_a) = CAST lcl_class2a( <fs1> ).

          "If downcast works, write a message into a table field.
          "Plus, return the number received via the method available
          "in lcl_class2a only.
          dc_check[ object_name = <fs1>->get_obj_name( ) ]-a_check =
            `Downcast works.`.
          dc_check[ object_name = <fs1>->get_obj_name( ) ]-a_number =
             o_dc_a->get_number_2a( ).

        CATCH cx_sy_move_cast_error.
          "If downcast does not work, write a message into a table field.
          dc_check[ object_name = <fs1>->get_obj_name( ) ]-a_check =
            `Downcast does not work.`.
      ENDTRY.

      "Second check if downcasts are possible using IS INSTANCE OF
      IF <fs1> IS INSTANCE OF lcl_class2b.
        "If downcast works, write a message into a table field.
        "Plus, return the number received via the method available
        "in lcl_class2b only.
        DATA(o_dc_b) = CAST lcl_class2b( <fs1> ).
        dc_check[ object_name = <fs1>->get_obj_name( ) ]-b_check =
          `Downcast works.`.
        dc_check[ object_name = <fs1>->get_obj_name( ) ]-b_number =
          o_dc_b->get_number_2b( ).
      ELSE.
        "If downcast does not work, write a message into a table field.
        dc_check[ object_name = <fs1>->get_obj_name( ) ]-b_check =
          `Downcast does not work.`.
      ENDIF.
    ENDLOOP.

    out->write( data = dc_check name = `dc_check` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18b) Excursion RTTI: Downcasts and Method Chaining` ) ).

    "Downcasts particularly play, for example, a role in the context of
    "retrieving type information using RTTI. Method chaining is handy
    "because it reduces the lines of code in this case.
    "The example contains the retrieval of type information for a
    "structure (structure components).
    "Due to the method chaining in the second example, the three
    "statements in the first example are reduced to one statement.

    DATA struct4cast TYPE zdemo_abap_carr.

    DATA(rtti_a) = cl_abap_typedescr=>describe_by_data( struct4cast ).
    DATA(rtti_b) = CAST cl_abap_structdescr( rtti_a ).
    DATA(rtti_c) = rtti_b->components.

    out->write( data = rtti_c name = `rtti_c` ).
    out->write( |\n| ).

    DATA(rtti_d) = CAST cl_abap_structdescr(
      cl_abap_typedescr=>describe_by_data( struct4cast )
          )->components.

    out->write( data = rtti_d name = `rtti_d` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) Interfaces` ) ).

    "Addressing instance interface components using interface reference variable
    DATA ref_if1 TYPE REF TO zdemo_abap_objects_interface.
    DATA ref_if2 TYPE REF TO zdemo_abap_objects_interface.

    "Object reference variable for a class implementing the interface
    DATA ref_cl1 TYPE REF TO zcl_demo_abap_objects.

    "An interface variable can contain references to objects of classes
    "that implement the corresponding interface.
    "Creating an object
    ref_cl1 = NEW zcl_demo_abap_objects( ).

    "Assigning the object reference to the interface object variable
    ref_if1 = ref_cl1.

    "This can also be done directly, i. e. directly creating an object to
    "which the interface reference variable points
    ref_if2 = NEW zcl_demo_abap_objects( ).

    "Instance method via the interface reference variable (i_ref->meth( ))
    DATA(inst_intf_meth_via_iref1) = ref_if1->double( 5 ).
    DATA(inst_intf_meth_via_iref2) = ref_if2->double( 10 ).

    "Instance attribute via the interface reference variable (i_ref->attr)
    DATA(inst_intf_attr_via_iref) = ref_if1->in_str.

    "Addressing instance components using the class reference variable
    "is also possible but it's not the recommended way
    "c_ref->intf~meth
    DATA(inst_intf_meth_via_cref) = ref_cl1->zdemo_abap_objects_interface~double( 20 ).

    "c_ref->intf~attr
    DATA(inst_intf_attr_via_cref) = ref_cl1->zdemo_abap_objects_interface~in_str.

    "Addressing static interface components
    "Static methods
    "class=>intf~meth( )
    DATA(stat_intf_meth1) = zcl_demo_abap_objects=>zdemo_abap_objects_interface~halve( 10 ).

    "Since we are in this very class here, the class name can be dropped.
    DATA(stat_intf_meth2) = zdemo_abap_objects_interface~halve( 100 ).

    "Just for the record: Static methods can be called via reference variables, too.
    DATA(stat_intf_meth3) = ref_if2->halve( 50 ).
    DATA(stat_intf_meth4) = ref_cl1->zdemo_abap_objects_interface~halve( 70 ).

    "Static attributes
    "class=>intf~attr
    DATA(stat_intf_attr1) = zcl_demo_abap_objects=>zdemo_abap_objects_interface~stat_str.
    DATA(stat_intf_attr2) = zdemo_abap_objects_interface~stat_str.
    "Accessing static attribute via reference variable
    DATA(stat_intf_attr3) = ref_if2->stat_str.

    "Constants
    "Can be accessed directly using this pattern: intf=>const
    DATA(intf_const1) = zdemo_abap_objects_interface=>const_intf.
    "Other options are possible
    DATA(intf_const2) = zcl_demo_abap_objects=>zdemo_abap_objects_interface~const_intf.
    DATA(intf_const3) = ref_if2->const_intf.

    out->write( data = inst_intf_attr_via_iref name = `inst_intf_attr_via_iref` ).
    out->write( |\n| ).
    out->write( data = inst_intf_meth_via_iref1 name = `inst_intf_meth_via_iref1` ).
    out->write( |\n| ).
    out->write( data = inst_intf_meth_via_iref2 name = `inst_intf_meth_via_iref2` ).
    out->write( |\n| ).
    out->write( data = inst_intf_attr_via_cref name = `inst_intf_attr_via_cref` ).
    out->write( |\n| ).
    out->write( data = inst_intf_meth_via_cref name = `inst_intf_meth_via_cref` ).
    out->write( |\n| ).

    out->write( data = stat_intf_attr1 name = `stat_intf_attr1` ).
    out->write( |\n| ).
    out->write( data = stat_intf_meth1 name = `stat_intf_meth1` ).
    out->write( |\n| ).
    out->write( data = stat_intf_meth2 name = `stat_intf_meth2` ).
    out->write( |\n| ).
    out->write( data = stat_intf_attr2 name = `stat_intf_attr2` ).
    out->write( |\n| ).
    out->write( data = stat_intf_meth3 name = `stat_intf_meth3` ).
    out->write( |\n| ).
    out->write( data = stat_intf_meth4 name = `stat_intf_meth4` ).

    out->write( data = intf_const1 name = `intf_const1` ).
    out->write( |\n| ).
    out->write( data = intf_const2 name = `intf_const2` ).
    out->write( |\n| ).
    out->write( data = intf_const3 name = `intf_const3` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) Singleton` ) ).

    "The demonstrates an implementation of the singleton design pattern.
    "A static method allows access to the only object of the class.
    "An instance is tried to be created three times. The method is
    "implemented in a way that prevents the creation of more than one
    "instance of the class. Hence, the result of all three method call shows
    "the same values (the time stamp that is set initially and the number of
    "instances that is always one).

    DATA: obj1 TYPE REF TO lcl_singleton,
          obj2 LIKE obj1.

    "Getting an instance of the class lcl_singleton
    obj1 = lcl_singleton=>get_instance( ).

    "Setting a time stamp
    obj1->set_timestamp( ).

    "Getting time stamp and the overall number of instances of the class
    DATA(timestamp) = obj1->get_timestamp( ).
    DATA(no_of_instances) = lcl_singleton=>no_of_instances.

    out->write( data = timestamp name = `timestamp` ).
    out->write( |\n| ).
    out->write( data = no_of_instances name = `no_of_instances` ).
    out->write( |\n| ).

    "Trying to get another instance
    obj2 = lcl_singleton=>get_instance( ).

    "Getting time stamp and the overall number of instances of the class
    timestamp =  obj2->get_timestamp( ).
    no_of_instances = lcl_singleton=>no_of_instances.

    out->write( data = timestamp name = `timestamp` ).
    out->write( |\n| ).
    out->write( data = no_of_instances name = `no_of_instances` ).
    out->write( |\n| ).

    "Trying to get another instance
    DATA(obj3) = lcl_singleton=>get_instance( ).

    "Getting time stamp and the overall number of instances of the class
    timestamp =  obj3->get_timestamp( ).
    no_of_instances = lcl_singleton=>no_of_instances.

    out->write( data = timestamp name = `timestamp` ).
    out->write( |\n| ).
    out->write( data = no_of_instances name = `no_of_instances` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) Factory method in an abstract class` ) ).

    "The example demonstrates a factory method in an abstract class. An
    "instance is tried to be created two times. The factory method is
    "implemented in a way that prevents the creation of an instance if a
    "certain condition is not met. In this simplistic example, the creation
    "is only allowed if the value '1' is passed to the factory method. The
    "second instance creation fails on purpose.

    out->write( `First try: inst_1` ).
    out->write( |\n| ).
    out->write( |\n| ).

    TRY.
        DATA(inst_1) = lcl_abstract=>factory_method( 1 ).
        DATA(str_1) = inst_1->return_string( `inst_1` ).
        out->write( data = str_1 name = `str_1` ).
      CATCH cx_sy_ref_is_initial INTO DATA(error1).
        out->write( |Error message: { error1->get_text( ) }| ).
    ENDTRY.

    out->write( |\n| ).
    out->write( data = lcl_abstract=>message name = `lcl_abstract=>message` ).
    out->write( |\n| ).

    out->write( `Second try: inst_2` ).
    out->write( |\n| ).

    TRY.
        DATA(inst_2) = lcl_abstract=>factory_method( 2 ).
        DATA(str_2) = inst_2->return_string( `inst_2` ).
        out->write( data = str_2 name = `str_2` ).
      CATCH cx_sy_ref_is_initial INTO DATA(error2).
        out->write( |Error message: { error2->get_text( ) }| ).
    ENDTRY.

    out->write( |\n| ).
    out->write( |\n| ).
    out->write( data = lcl_abstract=>message name = `lcl_abstract=>message` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Friendship: Accessing components of friends` ) ).

    "Classes can grant friendship to other classes and interfaces to enable
    "the access to protected and private components. However, the friendship
    "is not reciprocal. If class a grants friendship to class b, class b
    "must also explicitly grant friendship to class a if the components
    "should be made accessible also the other way round. In this simple example,
    "this class has a class declared as a friend. To visualize the concept,
    "strings are available in the public, protected and private section
    "here. The befriended class can access the strings not only in the public section
    "but of all other sections, too. The strings are stored in a string table. The content
    "of this string table is retrieved from the befriended class via a method.

    DATA(string_table) = zcl_demo_abap_objects_friend=>get_strings( ).

    out->write( data = string_table name = `string_table` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Self-reference me` ) ).

    "This example demonstrates the use of the self-reference 'me' in an
    "instance method. The method implementation includes a variable of type
    "string that has the same name as a variable that is declared in the
    "public section of the class. The method has two exporting parameters to
    "include both the value of the local variable and the value of the
    "equally named variable from the public section. The latter one is
    "referred to using the self-reference me within the method implementation.

    DATA(ref_var) = NEW zcl_demo_abap_objects( ).

    ref_var->me_ref_meth( IMPORTING e1 = DATA(string_without_me)
                                    e2 = DATA(string_with_me) ).

    out->write( data = string_without_me name = `string_without_me` ).
    out->write( |\n| ).
    out->write( data = string_with_me name = `string_with_me` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) Events` ) ).

    "The example covers the use of instance events. Event handler methods
    "are registered for a particular instance. Events are raised in a method
    "based on the daytime. Various event handler methods are implemented
    "which return a string.

    DATA(ref_events) = NEW lcl_events( ).

    "Registering event handler methods.
    SET HANDLER: ref_events->morning_greets
                 ref_events->afternoon_greets
                 ref_events->evening_greets
                 ref_events->night_greets
                 FOR ref_events.

    "Calling method that raises an event
    ref_events->greetings( ).

    out->write( data = ref_events->greets name = `ref_events->greets` ).

  ENDMETHOD.


  METHOD me_ref_meth.
    DATA another_string TYPE string VALUE `I'm a local string.`.
    "e1 gets assigned the local string.
    e1 = another_string.
    "e2 gets assigned the variable from the public section.
    e2 = me->another_string.
  ENDMETHOD.


  METHOD triple.
    zdemo_abap_objects_interface~in_str = `The result of calling triple (i. e. zdemo_abap_objects_interface~triple) is: `.
    r_triple = i_op * 3.
  ENDMETHOD.


  METHOD zdemo_abap_objects_interface~double.
    zdemo_abap_objects_interface~in_str = `The result of calling zdemo_abap_objects_interface~double is: `.
    r_double = i_op * 2.
  ENDMETHOD.


  METHOD zdemo_abap_objects_interface~halve.
    zdemo_abap_objects_interface~stat_str = `The result of calling zdemo_abap_objects_interface~halve is: `.
    r_halve = i_op / 2.
  ENDMETHOD.

  METHOD zdemo_abap_objects_interface~addition.
    ... 
  ENDMETHOD.

  METHOD zdemo_abap_objects_interface~subtraction.
    ... 
  ENDMETHOD.

  METHOD zdemo_abap_objects_interface~meth_fail.
    ...
  ENDMETHOD.

  METHOD zdemo_abap_objects_interface~meth_ignore.
    ... "See the comment in the method implementation of zdemo_abap_objects_interface~meth_fail.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS cx_afternoon DEFINITION INHERITING FROM cx_static_check.
ENDCLASS.

CLASS cx_night DEFINITION INHERITING FROM cx_static_check.
ENDCLASS.""",
    r"""CLASS lcl_demo DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      "No parameters
      hallo_static_ext,

      "One importing parameter
      powers_of_two IMPORTING i_pow TYPE i,

      "Two importing parameters
      "Specifying REFERENCE(p) is optional; a formal parameter
      "without VALUE(p) or REFERENCE(p) is REFERENCE(p) by default
      addition IMPORTING i_add1            TYPE i
                         REFERENCE(i_add2) TYPE i,

      "Two importing parameters, one of them is optional.
      addition_optional IMPORTING i_add_mand TYPE i
                                  i_add_opt  TYPE i OPTIONAL,

      "Importing and exporting parameters
      subtraction IMPORTING i_sub1       TYPE i
                            i_sub2       TYPE i
                  EXPORTING e_sub_result TYPE i,

      "One exporting parameter
      exporting_hallo EXPORTING text TYPE string,

      "Changing parameter
      square_root CHANGING i_sqr TYPE decfloat34,

      "Importing and returning parameters
      multiplication IMPORTING i_mult1              TYPE i
                               i_mult2              TYPE i
                     RETURNING VALUE(r_mult_result) TYPE i,

      "Importing and exporting parameters
      "for comparing the signature with method 'multiplication'
      multiplication_exp_param IMPORTING i_multa       TYPE i
                                         i_multb       TYPE i
                               EXPORTING e_mult_result TYPE i,

      "Includes RAISING
      division IMPORTING i_div1              TYPE i
                         i_div2              TYPE i
               RETURNING VALUE(r_div_result) TYPE decfloat34
               RAISING   cx_sy_arithmetic_error,

      check_daytime IMPORTING time      TYPE t
                    EXPORTING greetings TYPE string
                    RAISING   cx_afternoon cx_night,

      "Include parameters with generic types
      generic_data IMPORTING i_data TYPE data,
      generic_tab IMPORTING i_anytab TYPE ANY TABLE.

    CLASS-DATA: calc_result TYPE i,
                string      TYPE string,
                some_data   TYPE REF TO data.

ENDCLASS.""",
    r"""CLASS lcl_demo IMPLEMENTATION.

  METHOD hallo_static_ext.
    string = |Hallo { sy-uname }. | &&
             |I'm a static method of class lcl_demo.|.
  ENDMETHOD.

  METHOD square_root.
    i_sqr = sqrt( i_sqr ).
  ENDMETHOD.

  METHOD powers_of_two.
    calc_result = i_pow * i_pow.
  ENDMETHOD.

  METHOD addition.
    calc_result = i_add1 + i_add2.
  ENDMETHOD.

  METHOD addition_optional.
    calc_result = i_add_mand + i_add_opt.
  ENDMETHOD.

  METHOD subtraction.
    e_sub_result = i_sub1 - i_sub2.
  ENDMETHOD.

  METHOD exporting_hallo.
    text = |Hallo { sy-uname }. | && |I'm a static method of class lcl_demo with one exporting parameter.|.
  ENDMETHOD.

  METHOD multiplication.
    r_mult_result = i_mult1 * i_mult2.
  ENDMETHOD.

  METHOD multiplication_exp_param.
    e_mult_result = i_multa * i_multb.
  ENDMETHOD.

  METHOD division.
    CLEAR string.

    TRY.
        r_div_result = i_div1 / i_div2.
      CATCH cx_sy_arithmetic_error INTO DATA(exc).
        string = exc->get_text( ).
    ENDTRY.

  ENDMETHOD.

  METHOD check_daytime.
   CLEAR string.

    "Morning: 5 am to 12 pm
    IF time BETWEEN '050001' AND '120000'.
      DATA(subrc) = 0.
    ENDIF.

    "Afternoon: 12 pm to 5 pm.
    IF time BETWEEN '120001' AND '170000'.
      subrc = 11.
    ENDIF.

    "Evening 5 pm to 9 pm.
    "Commented out on purpose to have a time range for OTHERS :)
    "IF time BETWEEN '170001' AND '210000'.
    " subrc = 22.
    "ENDIF.

    "Night: 9 pm to 4 am.
    IF time BETWEEN '210001' AND '235959' OR time BETWEEN '000000' AND '050000'.
      subrc = 33.
    ENDIF.

    IF subrc <> 0.
      CASE subrc.
        WHEN 11.
          greetings = |Good afternoon.|.
        WHEN 33.
          greetings = |Good night.|.
        WHEN OTHERS.
          greetings = |It's neither morning, afternoon or night. | &&
                      |Hence, wishing you a good evening.|.
      ENDCASE.
    ELSE.
      greetings = |Good morning.|.
    ENDIF.

  ENDMETHOD.

  METHOD generic_data.
    "A data reference variable is created that has the type of the
    "imported variable. Its content is store in the variable
    "some_data in the public section to be able to access the content.
    CREATE DATA some_data LIKE i_data.
    some_data->* = i_data.
  ENDMETHOD.

  METHOD generic_tab.
    "See implementation of generic_data.
    "Here, an internal table is handled.
    CREATE DATA some_data LIKE i_anytab.
    some_data->* = i_anytab.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS local_class DEFINITION.
  PUBLIC SECTION.

    METHODS: constructor.

    DATA: num_inst  TYPE i,
          uuid      TYPE sysuuid_x16,
          timestamp TYPE timestampl.

    CLASS-DATA: no_of_instances TYPE i READ-ONLY,
                num_stat        TYPE i VALUE 33.

    CONSTANTS: const_number TYPE i VALUE 11.

    TYPES type_i TYPE i.

ENDCLASS.

CLASS local_class IMPLEMENTATION.
  METHOD constructor.
    "Number of instances of the class are counted.
    no_of_instances = no_of_instances + 1.
    "Set a time stamp.
    GET TIME STAMP FIELD timestamp.
    "Increase the number.
    num_inst = num_inst + 1.
    "Get a random UUID.
    TRY.
        uuid = cl_system_uuid=>create_uuid_x16_static( ) .
      CATCH cx_uuid_error.
    ENDTRY.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS lcl_events DEFINITION.
  PUBLIC SECTION.
    DATA: greets TYPE string.

    "Events declaration.
    EVENTS: morning, afternoon, evening, night.

    "Event handler methods
    METHODS: morning_greets FOR EVENT morning OF lcl_events,
      afternoon_greets FOR EVENT afternoon OF lcl_events,
      evening_greets FOR EVENT evening OF lcl_events,
      night_greets FOR EVENT night OF lcl_events.

    "Method to raise events
    METHODS: greetings.
ENDCLASS.""",
    r"""CLASS lcl_events IMPLEMENTATION.

  METHOD greetings.

    DATA(syst_time) = cl_abap_context_info=>get_system_time( ).

    "Morning: 5 am to 12 pm
    IF syst_time BETWEEN '050001' AND '120000'.
      RAISE EVENT morning.

      "Afternoon: 12 pm to 5 pm.
    ELSEIF syst_time BETWEEN '120001' AND '170000'.
      RAISE EVENT afternoon.

      "Evening 5 pm to 9 pm.
    ELSEIF syst_time BETWEEN '170001' AND '210000'.
      RAISE EVENT evening.

      "Night: 9 pm to 5 am.
    ELSEIF syst_time BETWEEN '210001' AND '050000'.
      RAISE EVENT night.
    ENDIF.

  ENDMETHOD.

  METHOD morning_greets.
    greets = |Good morning, { sy-uname }.|.
  ENDMETHOD.

  METHOD afternoon_greets.
    greets = |Good afternoon, { sy-uname }.|.
  ENDMETHOD.

  METHOD evening_greets.
    greets = |Good evening, { sy-uname }.|.
  ENDMETHOD.

  METHOD night_greets.
    greets = |Good night, { sy-uname }.|.
  ENDMETHOD.

ENDCLASS.

CLASS lcl_constructors DEFINITION.
  PUBLIC SECTION.

    METHODS: constructor IMPORTING num1 TYPE i
                                  num2 TYPE i RAISING cx_sy_zerodivide.

    DATA: uuid          TYPE sysuuid_x16,
          in_div_result TYPE i,
          in_text       TYPE string.


    CLASS-METHODS: class_constructor,
      add_1.

    CLASS-DATA: no_of_instances TYPE i READ-ONLY,
                stat_number     TYPE i,
                stat_text       TYPE string.

ENDCLASS.""",
    r"""CLASS lcl_constructors IMPLEMENTATION.

  METHOD constructor.
    "Get time stamp.
    DATA(ts1) = utclong_current( ).
    "Provide message.
    in_text = |The instance constructor of the class | &&
              |lcl_constructors was called on { ts1 }.|.

    "Count number of instances.
    no_of_instances = no_of_instances + 1.
    "Get random UUID.
    TRY.
        uuid = cl_system_uuid=>create_uuid_x16_static( ) .
      CATCH cx_uuid_error.
    ENDTRY.

    CLEAR in_div_result.
    "Do calculation.
    in_div_result = num1 / num2.
  ENDMETHOD.

  METHOD class_constructor.
    "Set a number.
    stat_number = 999.
    "Get time stamp.
    DATA(ts2) = utclong_current( ).
    "Provide message.
    stat_text = |The static constructor of the class | &&
                |lcl_constructors was called on { ts2 } and the | &&
                |value for the variable 'stat_number' was set to | &&
                |{ stat_number }.|.
  ENDMETHOD.

  METHOD add_1.
    stat_number += 1.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_class1 DEFINITION.

  PUBLIC SECTION.
    "Note: All methods are purposely included in the public section.
    "Otherwise, it cannot be called in the demo's main class.
    METHODS: constructor IMPORTING i_obj TYPE string OPTIONAL,
      get_string RETURNING VALUE(str) TYPE string,
      get_obj_name RETURNING VALUE(obj) TYPE string.

  PRIVATE SECTION.
    DATA: obj_name TYPE string.

ENDCLASS.""",
    r"""CLASS lcl_class1 IMPLEMENTATION.

  METHOD constructor.
    obj_name = i_obj.
  ENDMETHOD.

  METHOD get_obj_name.
    obj = obj_name.
  ENDMETHOD.

  METHOD get_string.
    str = `Hallo`.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_class2a DEFINITION INHERITING FROM lcl_class1.

  PUBLIC SECTION.

    METHODS: get_string REDEFINITION,
      get_number_2a RETURNING VALUE(num) TYPE i..

ENDCLASS.""",
    r"""CLASS lcl_class2a IMPLEMENTATION.

  METHOD get_string.
    str = |{ super->get_string( ) }, { sy-uname }!|.
  ENDMETHOD.

  METHOD get_number_2a.
    num = cl_abap_random_int=>create(
     seed = cl_abap_random=>seed( ) min = 1 max = 100 )->get_next( ).
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_class2b DEFINITION INHERITING FROM lcl_class1 FINAL.

  PUBLIC SECTION.

    METHODS: get_string REDEFINITION,
      get_number_2b RETURNING VALUE(num) TYPE i.

ENDCLASS.""",
    r"""CLASS lcl_class2b IMPLEMENTATION.

  METHOD get_string.
    str = |{ super->get_string( ) } from lcl_class2b, { sy-uname }!|.
  ENDMETHOD.

  METHOD get_number_2b.
    num = cl_abap_random_int=>create(
     seed = cl_abap_random=>seed( ) min = 1 max = 100 )->get_next( ).
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_class3a DEFINITION INHERITING FROM lcl_class2a FINAL.

  PUBLIC SECTION.

    METHODS: get_string REDEFINITION.

ENDCLASS.""",
    r"""CLASS lcl_class3a IMPLEMENTATION.

  METHOD get_string.
    str = |{ super->get_string( ) } How are you doing?|.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_singleton DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.

    METHODS: constructor,
      "Methods for setting and getting a time stamp.
      get_timestamp RETURNING VALUE(res_timestamp)
                                TYPE timestampl,
      set_timestamp.

    CLASS-METHODS:
      "Factory method that returns an instance of the class.
      get_instance RETURNING VALUE(res_instance) TYPE REF TO lcl_singleton.

    CLASS-DATA: "Holds the number of overall instances.
                no_of_instances TYPE i READ-ONLY.

  PRIVATE SECTION.
    CLASS-DATA: obj TYPE REF TO lcl_singleton.

    DATA: timestamp TYPE timestampl.

ENDCLASS.""",
    r"""CLASS lcl_singleton IMPLEMENTATION.

  METHOD get_instance.
    "Checking if an instance of the class already exists.
    "An instance should only be created if no instance exists
    "to make sure that there is only a single instance overall.
    IF obj IS NOT BOUND.
      obj = NEW #( ).
    ENDIF.
    "In case an instance already exists, the existing one is
    "always returned.
    res_instance = obj.
  ENDMETHOD.

  METHOD constructor.
    "Counts the number of instances of the class.
    no_of_instances = no_of_instances + 1.
  ENDMETHOD.

  METHOD get_timestamp.
    res_timestamp = timestamp.
  ENDMETHOD.

  METHOD set_timestamp.
    GET TIME STAMP FIELD timestamp.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_sub DEFINITION DEFERRED.

CLASS lcl_abstract DEFINITION ABSTRACT.

  PUBLIC SECTION.

    CLASS-METHODS: factory_method IMPORTING check_num  TYPE i
                                  RETURNING VALUE(obj) TYPE REF TO lcl_abstract.

    CLASS-DATA: message TYPE string.

    "Abstract method: There's no implementation in this class.
    METHODS: return_string ABSTRACT
      IMPORTING i_str             TYPE string
      RETURNING VALUE(res_string) TYPE string.

ENDCLASS.

CLASS lcl_sub DEFINITION INHERITING FROM lcl_abstract.

  PUBLIC SECTION.

    METHODS: return_string REDEFINITION.

ENDCLASS.


CLASS lcl_abstract IMPLEMENTATION.

  METHOD factory_method.
    "Purpose of factory method: An instance can only be created
    "if a certain condition is met.
    CASE check_num.
      WHEN 1.
        obj = NEW lcl_sub( ).
        message = `Great! I was able to create an instance.`.
      WHEN OTHERS.
        message = `What a pity. I'm not allowed to create an instance.`.
    ENDCASE.
  ENDMETHOD.

ENDCLASS.
CLASS lcl_sub IMPLEMENTATION.

  METHOD return_string.
    res_string = |I'm a returned string. | &&
                 |The object reference variable is { i_str }.|.
  ENDMETHOD.

ENDCLASS.""",
    r""" CLASS zcl_demo_abap_objects_friend DEFINITION PUBLIC FINAL CREATE PUBLIC.

   PUBLIC SECTION.
     CLASS-METHODS get_strings RETURNING VALUE(res_string) TYPE string_table.

protected section.
private section.
ENDCLASS.""",
    r"""CLASS ZCL_DEMO_ABAP_OBJECTS_FRIEND IMPLEMENTATION.


  METHOD get_strings.
    "Getting the strings and adding them to the string table.
    "Accessing an attribute in a public visibility section.
    APPEND zcl_demo_abap_objects=>public_string TO res_string.

    "Accessing an attribute in a protected visibility section.
    APPEND zcl_demo_abap_objects=>protected_string TO res_string.

    "Accessing an attribute in a private visibility section.
    APPEND zcl_demo_abap_objects=>private_string TO res_string.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_objects_misc DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    INTERFACES zdemo_abap_objects_interface.
    METHODS constructor IMPORTING text TYPE string OPTIONAL.
    CLASS-METHODS class_constructor.
  PROTECTED SECTION.
  PRIVATE SECTION.
    DATA instance_timestamp TYPE utclong.
    CLASS-DATA static_timestamp TYPE utclong.
    DATA instance_name TYPE string.
    CLASS-DATA stat_constr_call_count TYPE i.
    CLASS-DATA instance_constr_call_count TYPE i.
    METHODS meth_opt_1 IMPORTING num        TYPE i OPTIONAL
                       RETURNING VALUE(str) TYPE string.
    METHODS meth_opt_2 IMPORTING num        TYPE i DEFAULT 1
                       RETURNING VALUE(str) TYPE string.
    METHODS meth_opt_3 IMPORTING num1       TYPE i
                                 num2       TYPE i OPTIONAL
                                 num3       TYPE i DEFAULT 1
                       RETURNING VALUE(str) TYPE string.
    METHODS meth_pref
      IMPORTING num1        TYPE i OPTIONAL
                num2        TYPE i OPTIONAL
                num3        TYPE i DEFAULT 1
                  PREFERRED PARAMETER num1
      RETURNING VALUE(text) TYPE string.
    CLASS-METHODS meth1 IMPORTING i_str        TYPE string
                                  i_tab        TYPE string_table OPTIONAL
                        EXPORTING e_dec        TYPE decfloat34
                                  e_tab        TYPE string_table
                        RETURNING VALUE(r_int) TYPE i.
    CLASS-METHODS meth2 RETURNING VALUE(r_tab) TYPE string_table.
    DATA str TYPE string.
    METHODS meth RETURNING VALUE(text) TYPE string.
    METHODS add_text IMPORTING str        TYPE string
                     RETURNING VALUE(ref) TYPE REF TO zcl_demo_abap_objects_misc.
    METHODS add_space RETURNING VALUE(ref) TYPE REF TO zcl_demo_abap_objects_misc.
    METHODS add_period RETURNING VALUE(ref) TYPE REF TO zcl_demo_abap_objects_misc.
    METHODS return_text RETURNING VALUE(str) TYPE string.
    METHODS display_text IMPORTING cl_run_ref TYPE REF TO if_oo_adt_classrun_out.
    DATA text TYPE string.
    ALIASES res FOR zdemo_abap_objects_interface~add_result.
    ALIASES add FOR zdemo_abap_objects_interface~addition.
    ALIASES subtr FOR zdemo_abap_objects_interface~subtraction.
    TYPES str4friend TYPE string.
    CLASS-METHODS get_hello RETURNING VALUE(hello) TYPE str4friend.
    TYPES c3 TYPE c LENGTH 3.
    TYPES der_type TYPE TABLE FOR CREATE zdemo_abap_rap_ro_m.
    DATA int TYPE i.
    DATA itab TYPE TABLE OF zdemo_abap_fli_ve WITH EMPTY KEY.

    METHODS formal_params_compl_types IMPORTING
                                        "---- Non-generic built-in ABAP types ----
                                        i_a TYPE i
                                        i_b TYPE string
                                        "---- ABAP DDIC types ----
                                        i_c TYPE land1           "elementary type
                                        i_d TYPE timestampl      "elementary type
                                        i_e TYPE zdemo_abap_fli "structured type based on DDIC database table
                                        i_f TYPE string_hashed_table "table type
                                        "---- ABAP CDS types (all of the examples are structured types) ----
                                        i_g TYPE zdemo_abap_fli_ve "CDS view entity
                                        i_h TYPE zdemo_abap_abstract_ent "CDS abstract entity
                                        i_i TYPE zdemo_abap_table_function "CDS table function
                                        "---- Data types declared in public section of a class ----
                                        i_j TYPE zcl_demo_abap_dtype_dobj=>t_pub_text_c30 "elementary type
                                        i_k TYPE zcl_demo_abap_amdp=>carr_fli_struc "structured type
                                        i_l TYPE zcl_demo_abap_amdp=>carr_fli_tab "table type
                                        "---- Data types declared in an interface ----
                                        i_m TYPE zdemo_abap_get_data_itf=>occ_rate "elementary type
                                        i_n TYPE zdemo_abap_get_data_itf=>carr_tab "table type
                                        "---- Local types ----
                                        i_o TYPE c3 "elementary type
                                        i_p TYPE der_type "table type (BDEF derived type)
                                        "---- Note: Examples such as the following are not allowed type specifications of formal parameters. ----
                                        "---- In the following cases, extra (local) type declarations with TYPES are required before the --------
                                        "---- method declaration to type the formal parameters. -------------------------------------------------
                                        "i_no1 TYPE c LENGTH 3
                                        "i_no2 TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY
                                        "---- Reference types ----
                                        i_q TYPE REF TO i "Data reference
                                        i_r TYPE REF TO zdemo_abap_carr "Data reference
                                        i_s TYPE REF TO zcl_demo_abap_unit_test "Object reference
                                        i_t TYPE REF TO data "Data reference (considered as complete typing, too)
                                        i_u TYPE REF TO object "Object reference (considered as complete typing, too)
                                        "---- TYPE LINE OF addition (structured type based on a table type) ----
                                        i_v TYPE LINE OF zcl_demo_abap_amdp=>carr_fli_tab
                                        i_w TYPE LINE OF der_type
                                        "---- LIKE addition (types based on existing data objects) ----
                                        i_x LIKE int "Local data object
                                        i_y LIKE zcl_demo_abap_dtype_dobj=>comma "Constant specified in a class
                                        i_z LIKE zdemo_abap_objects_interface=>stat_str "Data object specified in an interface
                                        "---- LIKE LINE OF addition (types based on existing internal tables) ----
                                        i_1 LIKE LINE OF itab "Local internal table
                                        "---- LIKE REF TO addition (reference types based on existing data object) ----
                                        i_2 LIKE REF TO int "Local elementary data object
                                        i_3 LIKE REF TO itab "Local internal table
                                      .

    METHODS formal_params_generic_types IMPORTING
                                          "---- Any data type ----
                                          i_data           TYPE data
                                          i_any            TYPE any

                                          "---- Character-like types ----
                                          i_c              TYPE c         "Text field with a generic length
                                          i_clike          TYPE clike     "Character-like (c, n, string, d, t, and character-like flat structures)
                                          i_csequence      TYPE csequence "Text-like (c, string)
                                          i_n              TYPE n         "Numeric text with generic length
                                          i_x              TYPE x         "Byte field with generic length
                                          i_xsequence      TYPE xsequence "Byte-like (x, xstring)

                                          "---- Numeric types ----
                                          i_decfloat       TYPE decfloat "decfloat16 decfloat34
                                          i_numeric        TYPE numeric  "Numeric (i, int8, p, decfloat16, decfloat34, f, (b, s))
                                          i_p              TYPE p        "Packed number (generic length and number of decimal places)

                                          "---- Internal table types ----
                                          i_any_table      TYPE ANY TABLE      "Internal table with any table type
                                          i_hashed_table   TYPE HASHED TABLE
                                          i_index_table    TYPE INDEX TABLE
                                          i_sorted_table   TYPE SORTED TABLE
                                          i_standard_table TYPE STANDARD TABLE
                                          i_table          TYPE table          "Standard table

                                          "---- Other types ----
                                          i_simple         TYPE simple "Elementary data type including enumerated types and
                                          "structured types with exclusively character-like flat components
                                        .
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_objects_misc IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: ABAP Object Orientation (2)\n\n| ).
    out->write( |1) Complete Typing of Formal Parameters\n\n| ).

    out->write( `No output for this section. See the signature of the formal_params_compl_types method, `
    && `which demonstrates multiple syntax variants for typing formal parameters completely.` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Generic Typing of Formal Parameters` ) ).

    "Structure including various components of specific types
    "They represent actual parameters in the method call below
    DATA: BEGIN OF s,
            c3        TYPE c LENGTH 3,
            c10       TYPE c LENGTH 10,
            n4        TYPE n LENGTH 4,
            str       TYPE string,
            time      TYPE t,
            date      TYPE d,
            dec16     TYPE decfloat16,
            dec34     TYPE decfloat34,
            int       TYPE i,
            pl4d2     TYPE p LENGTH 4 DECIMALS 2,
            tab_std   TYPE STANDARD TABLE OF string WITH EMPTY KEY,
            tab_so    TYPE SORTED TABLE OF string WITH NON-UNIQUE KEY table_line,
            tab_ha    TYPE HASHED TABLE OF string WITH UNIQUE KEY table_line,
            xl1       TYPE x LENGTH 1,
            xstr      TYPE xstring,
            structure TYPE zdemo_abap_carr, "character-like flat structure
          END OF s.

    "The following method call specifies various actual parameters for the
    "generic formal parameters.
    "Note the comments for allowed and not allowed example assignments of
    "actual parameters.
    formal_params_generic_types(
      "------------- Any data type -------------
      "--- data/any: Allowed (examples) ---
      i_data = s-c3
      "i_data = s-time
      "i_data = s-tab_std
      "i_data = s-xstr

      i_any = s-c3
      "i_any = s-time
      "i_any = s-tab_std
      "i_any = s-xstr

      "------------- Character-like types -------------
      "--- c: Allowed (examples) ---
      i_c = s-c3
      "i_c = s-c10
      "--- c: Not allowed (examples) ---
      "i_c = s-str
      "i_c = s-n4

      "--- clike: Allowed (examples) ---
      i_clike = s-c3
      "i_clike = s-c10
      "i_clike = s-str
      "i_clike = s-structure
      "i_clike = s-time
      "i_clike = s-date
      "i_clike = s-n4
      "--- clike: Not allowed (examples) ---
      "i_clike = s-xstr
      "i_clike = s-xl1
      "i_clike = s-pl4d2

      "--- csequence: Allowed (examples) ---
      i_csequence  = s-c3
      "i_csequence  = s-c10
      "i_csequence  = s-str
      "--- csequence: Not allowed (examples) ---
      "i_csequence  = s-time
      "i_csequence  = s-date
      "i_csequence  = s-structure

      "--- n: Allowed ---
      i_n = s-n4
      "--- n: Not allowed (examples) ---
      "i_n = s-c3
      "i_n = s-int

      "--- x: Allowed ---
      i_x = s-xl1
      "--- x: Not allowed (examples) ---
      "i_x = s-xstr
      "i_x = s-c3

      "--- xsequence: Allowed ---
      i_xsequence = s-xstr
      "i_xsequence = s-xl1
      "--- xsequence: Not allowed (examples) ---
      "i_xsequence = s-c3
      "i_xsequence = s-str

      "--- decfloat: Allowed ---
      i_decfloat = s-dec16
      "i_decfloat = s-dec34
      "--- decfloat: Not allowed (examples) ---
      "i_decfloat = s-int
      "i_decfloat = s-pl4d2

      "--- numeric: Allowed (examples) ---
      i_numeric  = s-int
      "i_numeric = s-dec16
      "i_numeric = s-dec34
      "i_numeric = s-pl4d2
      "--- numeric: Not allowed (examples) ---
      "i_numeric = s-n4
      "i_numeric = s-date

      "--- p: Allowed ---
      i_p = s-pl4d2
      "--- p: Not allowed (examples) ---
      "i_p = s-dec16
      "i_p = s-dec34

      "--- any table: Allowed ---
      i_any_table = s-tab_std
      "i_any_table = s-tab_ha
      "i_any_table = s-tab_so
      "--- any table: Not allowed (examples) ---
      "i_any_table = s-structure
      "i_any_table = s-c3

      "--- hashed table: Allowed ---
      i_hashed_table = s-tab_ha
      "--- hashed table: Not allowed ---
      "i_hashed_table = s-tab_std
      "i_hashed_table = s-tab_so

      "--- index table: Allowed ---
      i_index_table = s-tab_std
      "i_index_table = s-tab_so
      "--- index table: Not allowed ---
      "i_index_table = s-tab_ha

      "--- sorted table: Allowed ---
      i_sorted_table = s-tab_so
      "--- sorted table: Not allowed ---
      "i_sorted_table = s-tab_std
      "i_sorted_table = s-tab_ha

      "--- standard table/table: Allowed ---
      i_standard_table = s-tab_std
      i_table = s-tab_std
      "--- standard table/table: Not allowed ---
      "i_standard_table = s-tab_so
      "i_standard_table = s-tab_ha
      "i_table = s-tab_so
      "i_table = s-tab_ha

     "--- simple: Allowed (examples) ---
      i_simple = s-structure
      "i_simple = s-c3
      "i_simple = s-n4
      "i_simple = s-int
      "i_simple = s-pl4d2
      "i_simple = s-xstr
      "i_simple = s-str
      "--- simple: Not allowed (examples) ---
      "i_simple = s-tab_ha
      "i_simple = s-tab_so

       ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Defining Parameters as Optional` ) ).

    DATA(meth_opt_1_result_a) = meth_opt_1( ).
    DATA(meth_opt_1_result_b) = meth_opt_1( 2 ).

    DATA(meth_opt_2_result_a) = meth_opt_2( ).
    DATA(meth_opt_2_result_b) = meth_opt_2( 3 ).

    "The commented out statement is not possible as there is one
    "non-optional parameter.
    "DATA(meth_opt_3_result_a) = meth_opt_3( ).
    DATA(meth_opt_3_result_b) = meth_opt_3( 4 ).
    DATA(meth_opt_3_result_c) = meth_opt_3( num1 = 5 num2 = 6 ).
    DATA(meth_opt_3_result_d) = meth_opt_3( num1 = 7 num3 = 8 ).

    out->write( data = meth_opt_1_result_a name = `meth_opt_1_result_a` ).
    out->write( |\n| ).
    out->write( data = meth_opt_1_result_b name = `meth_opt_1_result_b` ).
    out->write( |\n| ).
    out->write( data = meth_opt_2_result_a name = `meth_opt_2_result_a` ).
    out->write( |\n| ).
    out->write( data = meth_opt_2_result_b name = `meth_opt_2_result_b` ).
    out->write( |\n| ).
    out->write( data = meth_opt_3_result_b name = `meth_opt_3_result_b` ).
    out->write( |\n| ).
    out->write( data = meth_opt_3_result_c name = `meth_opt_3_result_c` ).
    out->write( |\n| ).
    out->write( data = meth_opt_3_result_d name = `meth_opt_3_result_d` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Defining Input Parameters as Preferred` ) ).

    DATA(text1) = meth_pref( num1 = 3 num2 = 3 num3 = 3 ).
    out->write( text1 ).

    DATA(text2) = meth_pref( num1 = 3 num2 = 3 ).
    out->write( text2 ).

    DATA(text3) = meth_pref( num2 = 3 num3 = 3 ).
    out->write( text3 ).

    DATA(text4) = meth_pref( num1 = 3 num3 = 3 ).
    out->write( text4 ).

    DATA(text5) = meth_pref( num2 = 3 ).
    out->write( text5 ).

    DATA(text6) = meth_pref( num3 = 3 ).
    out->write( text6 ).

    DATA(text7) = meth_pref( ).
    out->write( text7 ).

    "Not specifying the name of the formal parameter. The
    "actual parameter is assigned to the preferred input
    "parameter.
    DATA(text8) = meth_pref( 3 ).
    out->write( text8 ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Constructors` ) ).

    "Notes:
    "- The static constructor is called only once, even when multiple class instances are created,
    "  leading to a constant static_timestamp value and stat_constr_call_count value, which remains 1.
    "- The instance_timestamp attribute shows different timestamps for each created instance.
    "- The static attribute instance_constr_call_count increases with each instance. Note that running
    "  the class with F9 in ADT also calls the instance and static constructors. Thus, the final
    "  instance_constr_call_count totals the number of DO loop passes plus 1, starting with 2 for inst1
    "  instead of 1.

    DATA itab_constr TYPE string_table.

    DO 5 TIMES.
      DATA(inst) = NEW zcl_demo_abap_objects_misc( |inst{ sy-index }| ).
      APPEND |-------------- Instance "{ inst->instance_name }" --------------| TO itab_constr.
      APPEND |instance_timestamp: { inst->instance_timestamp }| TO itab_constr.
      APPEND |static_timestamp: { inst->static_timestamp }| TO itab_constr.
      APPEND |instance_constr_call_count: { inst->instance_constr_call_count }| TO itab_constr.
      APPEND |stat_constr_call_count: { inst->stat_constr_call_count }| TO itab_constr.
      APPEND INITIAL LINE TO itab_constr.
    ENDDO.

    out->write( data = itab_constr name = `itab_constr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Excursion: Inline Declarations, Returning Parameters` ) ).
    "Note:
    "- Calling the method in the same class means specifying 'zcl_demo_abap=>' is optional here.
    "- There is no proper implementation in the method implementations.
    "- There is not output for this section as it is meant to visualize on syntax options.

    "Standalone method call
    "Specifying target data objects for all output parameters
    "Inline declarations are handy because you can create an
    "appropriately typed data object in place. No need to
    "create an extra variable, check on the type etc.
    zcl_demo_abap_objects_misc=>meth1(
      EXPORTING
        i_str = `ABAP`
      IMPORTING
        e_dec = DATA(a)
        e_tab = DATA(b)
      RECEIVING
        r_int = DATA(c)
    ).

    "Functional method call
    "The target data object of the returning parameter is specified on the left side of an assignment.
    "Note: In this case, you cannot specify inline declarations for the exporting parameters.
    DATA e TYPE decfloat34.
    DATA f TYPE string_table.
    DATA(g) = zcl_demo_abap_objects_misc=>meth1(
      EXPORTING
        i_str = `ABAP`
      IMPORTING
        "e_dec = DATA(h)
        "e_tab = DATA(i)
        e_dec = e
        e_tab = f
    ).

    "Benefits of returning parameters: They can, for example, be used in expressions
    "The following snippets show a selection (and ignore the available exporting
    "parameters).

    CASE zcl_demo_abap_objects_misc=>meth1( i_str = `ABAP` ).
      WHEN 0. ...
      WHEN 1. ...
      WHEN OTHERS. ...
    ENDCASE.

    IF zcl_demo_abap_objects_misc=>meth1( i_str = `ABAP` ) > 5.
      ...
    ELSE.
      ...
    ENDIF.

    "IF used with a predicative method call
    "The result of the relational expression is true if the result of the functional
    "method call is not initial and false if it is initial. The data type of the result
    "of the functional meth1od call, i. e. the return value of the called functional method,
    "is arbitrary. A check is made for the type-dependent initial value.
    IF zcl_demo_abap_objects_misc=>meth1( i_str = `ABAP` ).
      ...
    ELSE.
      ...
    ENDIF.

    DO zcl_demo_abap_objects_misc=>meth1( i_str = `ABAP` ) TIMES.
      ...
    ENDDO.

    "Method call result as actual parameter
    DATA(j) = zcl_demo_abap_objects_misc=>meth1( i_str = `ABAP` i_tab = zcl_demo_abap_objects_misc=>meth2( ) ).

    "Examples of returning parameters typed with a table type
    LOOP AT zcl_demo_abap_objects_misc=>meth2( ) INTO DATA(wa1).
      ...
    ENDLOOP.

    READ TABLE zcl_demo_abap_objects_misc=>meth2( ) INTO DATA(wa2) INDEX 1.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Self-Reference me` ) ).

    str = `AP`.
    DATA(text) = meth( ).
    out->write( data = text name = `text` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Method Chaining and Chained Attribute Access` ) ).

    DATA(txt1) = NEW zcl_demo_abap_objects_misc(
                         )->add_text( `Hallo`
                         )->add_space(
                         )->add_text( xco_cp=>sy->user( )->name
                         )->add_period(
                         )->add_space(
                         )->add_text( `This`
                         )->add_space(
                         )->add_text( `is`
                         )->add_space(
                         )->add_text( `an`
                         )->add_space(
                         )->add_text( `example`
                         )->add_space(
                         )->add_text( `of`
                         )->add_space(
                         )->add_text( `method`
                         )->add_space(
                         )->add_text( `chaining`
                         )->add_period(
                         )->return_text( ).

    out->write( data = txt1 name = `txt1` ).
    out->write( |\n| ).

    "The following example chained method call includes a chained attribute
    "access at the end so that the target variable contains the content of
    "the attribute.

    "Example result: Today is 2025-03-05. It's 14:30:38. Have a nice day.
    DATA(txt2) = NEW zcl_demo_abap_objects_misc(
                      )->add_text( `Today`
                      )->add_space(
                      )->add_text( `is`
                      )->add_space(
                      )->add_text( xco_cp=>sy->date( )->as( xco_cp_time=>format->iso_8601_extended )->value
                      )->add_period(
                      )->add_space(
                      )->add_text( `It's`
                      )->add_space(
                      )->add_text( xco_cp=>sy->time( xco_cp_time=>time_zone->user
                                    )->as( xco_cp_time=>format->iso_8601_extended
                                    )->value
                      )->add_period(
                      )->add_space(
                      )->add_text( `Have`
                      )->add_space(
                      )->add_text( `a`
                      )->add_space(
                      )->add_text( `nice`
                      )->add_space(
                      )->add_text( `day`
                      )->add_period(
                      )->text.

    out->write( data = txt2 name = `txt2` ).
    out->write( |\n| ).

    "----------------------------------------------------------------
    "-------- Method chaining with a standalone statement -----------
    "----------------------------------------------------------------

    "In the example, the final method call in the chain receives
    "the classrun instance available in the implementation of the
    "if_oo_adt_classrun~main method. The method implementation
    "includes the writing to the console.

    "Console output: Lorem ipsum dolor sit amet
    NEW zcl_demo_abap_objects_misc( )->add_text( `Lorem`
                        )->add_space(
                        )->add_text( `ipsum`
                        )->add_space(
                        )->add_text( `dolor`
                        )->add_space(
                        )->add_text( `sit`
                        )->add_space(
                        )->add_text( `amet`
                        )->display_text( out ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Demonstrating Upcasts and Downcasts Using the RTTS Inheritance Tree` ) ).

*Hierarchy tree of the classes:
*
*CL_ABAP_TYPEDESCR
*  |
*  |--CL_ABAP_DATADESCR
*  |   |
*  |   |--CL_ABAP_ELEMDESCR
*  |   |   |
*  |   |   |--CL_ABAP_ENUMDESCR
*  |   |
*  |   |--CL_ABAP_REFDESCR
*  |   |--CL_ABAP_COMPLEXDESCR
*  |       |
*  |       |--CL_ABAP_STRUCTDESCR
*  |       |--CL_ABAP_TABLEDESCR
*  |
*  |--CL_ABAP_OBJECTDESCR
*     |
*     |--CL_ABAP_CLASSDESCR
*     |--CL_ABAP_INTFDESCR

    "------------ Object reference variables ------------

    "Static and dynamic types
    "Defining an object reference variable with a static type
    DATA tdo TYPE REF TO cl_abap_typedescr.

    "Retrieving type information
    "The reference the reference variable points to is either cl_abap_elemdescr,
    "cl_abap_enumdescr, cl_abap_refdescr, cl_abap_structdescr, or cl_abap_tabledescr.
    "So, it points to one of the subclasses. The static type of tdo refers to
    "cl_abap_typedescr, however, the dynamic type is one of the subclasses mentioned.
    "in the case of the example, it is cl_abap_elemdescr. Check in the debugger.
    DATA some_string TYPE string.
    tdo = cl_abap_typedescr=>describe_by_data( some_string ).

    "Some more object reference variables
    DATA tdo_super TYPE REF TO cl_abap_typedescr.
    DATA tdo_elem TYPE REF TO cl_abap_elemdescr.
    DATA tdo_data TYPE REF TO cl_abap_datadescr.
    DATA tdo_gen_obj TYPE REF TO object.

    "------------ Upcasts ------------

    "Moving up the inheritance tree
    "Assignments:
    "- If the static type of target variable is less specific or the same, an assignment works.
    "- The target variable inherits the dynamic type of the source variable.

    "Static type of target variable is the same
    tdo_super = tdo.

    "Examples for static types of target variables that are less specific
    "Target variable has the generic type object
    tdo_gen_obj = tdo.

    "Target variable is less specific because the direct superclass of cl_abap_elemdescr
    "is cl_abap_datadescr
    "Note: In the following three assignments, the target variable remains initial
    "since the source variables do not (yet) point to any object.
    tdo_data = tdo_elem.

    "Target variable is less specific because the direct superclass of cl_abap_datadescr
    "is cl_abap_typedescr
    tdo_super = tdo_data.

    "Target variable is less specific because the class cl_abap_typedescr is higher up in
    "the inheritance tree than cl_abap_elemdescr
    tdo_super = tdo_elem.

    "The casting happens implicitly. You can also excplicitly cast and use
    "casting operators, but it is usually not required.
    tdo_super = CAST #( tdo ).
    tdo_super ?= tdo.

    "In combination with inline declarations, the CAST operator can be used to provide a
    "reference variable with a more general type.
    DATA(tdo_inl_cast) = CAST cl_abap_typedescr( tdo_elem ).

    CLEAR: tdo_super, tdo_elem, tdo_data, tdo_gen_obj.

    "------------ Downcasts ------------

    "Moving down the inheritance tree
    "Assignments:
    "- If the static type of the target variable is more specific than the static type
    "  of the source variable, performing a check whether it is less specific or the same
    "  as the dynamic type of the source variable is required at runtime before the assignment
    "- The target variable inherits the dynamic type of the source variable, however, the target
    "  variable can accept fewer dynamic types than the source variable
    "- Downcasts are always performed explicitly using casting operators

    "Static type of the target is more specific
    "object -> cl_abap_typedescr
    tdo_super = CAST #( tdo_gen_obj ).
    "cl_abap_typedescr -> cl_abap_datadescr
    "Note: Here, the dynamic type of the source variable is cl_abap_elemdescr.
    tdo_data = CAST #( tdo ).
    "cl_abap_datadescr -> cl_abap_elemdescr
    tdo_elem = CAST #( tdo_data ).
    "cl_abap_typedescr -> cl_abap_elemdescr
    tdo_elem = CAST #( tdo_super ).

    "------------ Error prevention in downcasts ------------

    "In the examples above, the assignments work. The following code snippets
    "deal with examples in which a downcast is not possible. An exception is
    "raised.
    DATA str_table TYPE string_table.
    DATA tdo_table TYPE REF TO cl_abap_tabledescr.

    "With the following method call, tdo points to an object with
    "reference to cl_abap_tabledescr.
    tdo = cl_abap_typedescr=>describe_by_data( str_table ).

    "Therefore, the following downcast works.
    tdo_table = CAST #( tdo ).

    "You could also achieve the same in one statement and with inline
    "declaration.
    DATA(tdo_table_2) = CAST cl_abap_tabledescr( cl_abap_typedescr=>describe_by_data( str_table ) ).

    "Example for an impossible downcast
    "The generic object reference variable points to cl_abap_elemdescr after the following
    "assignment.
    tdo_gen_obj = cl_abap_typedescr=>describe_by_data( some_string ).

    "Without catching the exception, the runtime error MOVE_CAST_ERROR
    "occurs. There is no syntax error at compile time. The static type of
    "tdo_gen_obj is more generic than the static type of the target variable.
    "The error occurs when trying to downcast, and the dynamic type is used.
    TRY.
        tdo_table = CAST #( tdo_gen_obj ).
      CATCH cx_sy_move_cast_error.
    ENDTRY.
    "Note: tdo_table sill points to the reference as assigned above after trying
    "to downcast in the TRY control structure.

    "Using CASE TYPE OF and IS INSTANCE OF statements, you can check if downcasts
    "are possible.
    "Note: In case of ...
    "- non-initial object reference variables, the dynamic type is checked.
    "- initial object reference variables, the static type is checked.

    "------------ IS INSTANCE OF ------------
    DATA some_tdo TYPE REF TO cl_abap_typedescr.
    some_tdo = cl_abap_typedescr=>describe_by_data( str_table ).

    IF some_tdo IS INSTANCE OF cl_abap_elemdescr.
      DATA(tdo_a) = CAST cl_abap_elemdescr( some_tdo ).
    ELSE.
      "This branch is executed. The downcast is not possible.
      ...
    ENDIF.

    IF some_tdo IS INSTANCE OF cl_abap_elemdescr.
      DATA(tdo_b) = CAST cl_abap_elemdescr( some_tdo ).
    ELSEIF some_tdo IS INSTANCE OF cl_abap_refdescr.
      DATA(tdo_c) = CAST cl_abap_refdescr( some_tdo ).
    ELSEIF some_tdo IS INSTANCE OF cl_abap_structdescr.
      DATA(tdo_d) = CAST cl_abap_structdescr( some_tdo ).
    ELSEIF some_tdo IS INSTANCE OF cl_abap_tabledescr.
      "In this example, this branch is executed. With the check,
      "you can make sure that the downcast is indeed possible.
      DATA(tdo_e) = CAST cl_abap_tabledescr( some_tdo ).
    ELSE.
      ...
    ENDIF.

    DATA initial_tdo TYPE REF TO cl_abap_typedescr.

    IF initial_tdo IS INSTANCE OF cl_abap_elemdescr.
      DATA(tdo_f) = CAST cl_abap_elemdescr( some_tdo ).
    ELSEIF initial_tdo IS INSTANCE OF cl_abap_refdescr.
      DATA(tdo_g) = CAST cl_abap_refdescr( some_tdo ).
    ELSEIF initial_tdo IS INSTANCE OF cl_abap_structdescr.
      DATA(tdo_h) = CAST cl_abap_structdescr( some_tdo ).
    ELSEIF initial_tdo IS INSTANCE OF cl_abap_tabledescr.
      DATA(tdo_i) = CAST cl_abap_tabledescr( some_tdo ).
    ELSE.
      "In this example, this branch is executed. The static
      "type of the initial object reference variable is used,
      "which is cl_abap_typedescr here.
      ...
    ENDIF.

    "------------ CASE TYPE OF ------------
    "The examples are desinged similarly to the IS INSTANCE OF examples.

    DATA(dref) = REF #( str_table ).
    some_tdo = cl_abap_typedescr=>describe_by_data( dref ).

    CASE TYPE OF some_tdo.
      WHEN TYPE cl_abap_elemdescr.
        DATA(tdo_j) = CAST cl_abap_elemdescr( some_tdo ).
      WHEN TYPE cl_abap_refdescr.
        "In this example, this branch is executed. With the check,
        "you can make sure that the downcast is indeed possible.
        DATA(tdo_k) = CAST cl_abap_refdescr( some_tdo ).
      WHEN TYPE cl_abap_structdescr.
        DATA(tdo_l) = CAST cl_abap_structdescr( some_tdo ).
      WHEN TYPE cl_abap_tabledescr.
        DATA(tdo_m) = CAST cl_abap_tabledescr( some_tdo ).
      WHEN OTHERS.
        ...
    ENDCASE.

    "Example with initial object reference variable
    CASE TYPE OF initial_tdo.
      WHEN TYPE cl_abap_elemdescr.
        DATA(tdo_n) = CAST cl_abap_elemdescr( some_tdo ).
      WHEN TYPE cl_abap_refdescr.
        DATA(tdo_o) = CAST cl_abap_refdescr( some_tdo ).
      WHEN TYPE cl_abap_structdescr.
        DATA(tdo_p) = CAST cl_abap_structdescr( some_tdo ).
      WHEN TYPE cl_abap_tabledescr.
        DATA(tdo_q) = CAST cl_abap_tabledescr( some_tdo ).
      WHEN OTHERS.
        "In this example, this branch is executed. The static
        "type of the initial object reference variable is used,
        "which is cl_abap_typedescr here.
        ...
    ENDCASE.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Interface Implementation` ) ).

    "Note:
    "- The example demonstrates that the interface methods declared with DEFAULT
    "  IGNORE and DEFAULT FAIL are not required to be implemented. In this example
    "  class, the methods are not implemented. In the zcl_demo_abap_objects class,
    "  which also includes the interface, they are implemented (but do not contain
    "  code)
    "- So, if implementations are desired, you can manually add the implementations (if
    "  not automatically added using the ADT quickfix) for these methods.
    "- The following code demonstrates calls to implemented interface methods. The
    "  example also demonstrates the calling of the non-implemented methods, which
    "  can indeed be specified. Since there is no implementation in the example class,
    "  errors occur.

    "Examples using an object reference variable
    DATA(oref) = NEW zcl_demo_abap_objects_misc( ).

    oref->add( num1 = 1 num2 = 2 ).
    DATA(res1) = oref->res.

    out->write( data = res1 name = `res1` ).
    out->write( |\n| ).

    oref->subtr( num1 = 1 num2 = 2 ).
    DATA(res2) = oref->zdemo_abap_objects_interface~subtr_result.

    out->write( data = res2 name = `res2` ).
    out->write( |\n| ).

    "Referring to a type declared in the interface
    DATA char_a TYPE zdemo_abap_objects_interface~c3.
    DATA char_b TYPE zdemo_abap_objects_interface=>c3.

    "Calling non-implemented methods
    DATA(int_ig_a) = oref->zdemo_abap_objects_interface~meth_ignore( ).
    ASSERT int_ig_a = 0.

    TRY.
        DATA(int_fl_a) = oref->zdemo_abap_objects_interface~meth_fail( ).
      CATCH cx_sy_dyn_call_illegal_method INTO DATA(error).
        DATA(error_text) = error->get_text( ).
        out->write( data = error_text name = `error_text` ).
        out->write( |\n| ).
    ENDTRY.

    "Similar examples using an interface reference variable
    DATA iref TYPE REF TO zdemo_abap_objects_interface.
    iref = NEW zcl_demo_abap_objects_misc( ).

    iref->addition( num1 = 3 num2 = 5 ).
    DATA(res3) = iref->add_result.

    out->write( data = res3 name = `res3` ).
    out->write( |\n| ).

    iref->subtraction( num1 = 3 num2 = 5 ).
    DATA(res4) = iref->subtr_result.

    out->write( data = res4 name = `res4` ).
    out->write( |\n| ).

    "Referring to a type declared in the interface
    DATA char_c TYPE iref->c3.

    "Calling non-implemented methods
    DATA(int_ig_b) = iref->meth_ignore( ).
    ASSERT int_ig_b = 0.

    TRY.
        DATA(int_fl_b) = iref->meth_fail( ).
      CATCH cx_sy_dyn_call_illegal_method INTO error.
        error_text = error->get_text( ).
        out->write( data = error_text name = `error_text` ).
        out->write( |\n| ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Friendship between Global and Local Classes` ) ).

    "Notes:
    "- Global class: When running the class, a method of the local class that is declared in the private
    "  section there is called. As a result of this method call, a string is assigned to an attribute
    "  that is also declared in the private section of the local class. This attribute is accessed by
    "  the global class, and finally displayed in the ADT console
    "- CCDEF include (Class-relevant Local Types tab in ADT): The LOCAL FRIENDS addition makes the local
    "  class a friend of the global class. The private components of the global class can then be accessed
    "  by the local class.
    "- CCIMP include (Local Types tab in ADT): The FRIENDS addition makes the global class a friend of the
    "  local class. The private components of the local class can then be accessed by the global class.
    "  A type declared in the private section of the global class is used to type an attribute.
    "  The method, which is also declared in the private section, includes a method call in the implementation.
    "  It is a method declared in the private section of the global class.

    local_class=>say_hello( ).
    DATA(hello) = local_class=>hello.

    out->write( data = hello name = `hello` ).

  ENDMETHOD.

  METHOD formal_params_compl_types.
    ... "No implementation
  ENDMETHOD.

  METHOD formal_params_generic_types.
    ... "No implementation
  ENDMETHOD.

  METHOD meth_opt_1.
    IF num IS SUPPLIED.
      str = |The parameter is supplied. Value: "{ num }".|.
    ELSE.
      str = |The parameter is not supplied. Initial value: "{ num }".|.
    ENDIF.
  ENDMETHOD.

  METHOD meth_opt_2.
    str = COND #( WHEN num IS SUPPLIED THEN |The parameter is supplied. Value: "{ num }".|
                     ELSE |The parameter is not supplied. Default value: "{ num }".|  ).
  ENDMETHOD.

  METHOD meth_opt_3.
    str = |num1: "{ num1 }" / |.

    str &&= |{ COND #( WHEN num2 IS SUPPLIED THEN |num2 (is supplied): "{ num2 }"|
                       ELSE |num2 (is not supplied; initial value): "{ num2 }"| ) } / |.

    str &&= |{ COND #( WHEN num3 IS SUPPLIED THEN |num3 (is supplied): "{ num3 }"|
                       ELSE |num3 (is not supplied; default value): "{ num3 }"| ) } |.
  ENDMETHOD.

  METHOD meth_pref.
    DATA(addition) = num1 + num2 + num3.
    text = |IS SUPPLIED: num1 "{ COND #( WHEN num1 IS SUPPLIED THEN 'X' ELSE '' ) }", | &&
           |num2 "{ COND #( WHEN num2 IS SUPPLIED THEN 'X' ELSE '' ) }", | &&
           |num3 "{ COND #( WHEN num3 IS SUPPLIED THEN 'X' ELSE '' ) }" / | &&
           |Addition result "{ addition }"|.
  ENDMETHOD.

  METHOD class_constructor.
    static_timestamp = utclong_current( ).
    stat_constr_call_count += 1.
  ENDMETHOD.

  METHOD constructor.
    instance_timestamp = utclong_current( ).
    instance_constr_call_count += 1.

    IF text IS SUPPLIED AND text IS NOT INITIAL.
      instance_name = text.
    ENDIF.
  ENDMETHOD.

  METHOD meth1.
    ... "No implementation
  ENDMETHOD.

  METHOD meth2.
    ... "No implementation
  ENDMETHOD.

  METHOD meth.
    "Declaring a local data object having the same
    "name as a data object declared in a visibility section
    DATA str TYPE string VALUE `AB`.

    "Addressing locally declared data object
    DATA(local_string) = str.

    "Addressing data object declared in private visibility section
    DATA(other_string) = me->str.

    text = local_string && other_string.
  ENDMETHOD.

  METHOD add_period.
    text &&= `.`.
    ref = me.
  ENDMETHOD.

  METHOD add_space.
    text &&= ` `.
    ref = me.
  ENDMETHOD.

  METHOD add_text.
    text &&= str.
    ref = me.
  ENDMETHOD.

  METHOD display_text.
    cl_run_ref->write( text ).
  ENDMETHOD.

  METHOD return_text.
    str = me->text.
  ENDMETHOD.

  METHOD add.
    res = num1 + num2.
  ENDMETHOD.

  METHOD subtr.
    zdemo_abap_objects_interface~subtr_result = num1 - num2.
  ENDMETHOD.

  METHOD zdemo_abap_objects_interface~double.
    ... "Not implemented and used in this example class.
  ENDMETHOD.

  METHOD zdemo_abap_objects_interface~halve.
    ... "Not implemented and used in this example class.
  ENDMETHOD.

  METHOD get_hello.
    hello = `Hello`.
  ENDMETHOD.

ENDCLASS.   """,
    r"""CLASS local_class DEFINITION DEFERRED.
CLASS zcl_demo_abap_objects_misc DEFINITION LOCAL FRIENDS local_class.""",
    r"""CLASS local_class DEFINITION FRIENDS zcl_demo_abap_objects_misc.

  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA hello TYPE zcl_demo_abap_objects_misc=>str4friend.
    CLASS-METHODS say_hello.

ENDCLASS.

CLASS local_class IMPLEMENTATION.
  METHOD say_hello.
    hello = |{ zcl_demo_abap_objects_misc=>get_hello( ) } { sy-uname }.|.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_1 DEFINITION
  PUBLIC
  CREATE PUBLIC .

  PUBLIC SECTION.
    "Classrun interface
    INTERFACES if_oo_adt_classrun.

    "Instance/static constructor declarations
    METHODS constructor.
    CLASS-METHODS class_constructor.

    "Instance method declarations
    METHODS meth_public_1.
    "Final method
    METHODS meth_public_1_final FINAL.

    "Components used for logging information about method calls
    TYPES: BEGIN OF s_log,
             method            TYPE string,
             implemented_where TYPE string,
             called_from       TYPE syrepid,
             is_inherited      TYPE abap_boolean,
             is_redefined      TYPE abap_boolean,
             is_final          TYPE abap_boolean,
             visibility        TYPE abap_visibility,
             is_static_method  TYPE abap_boolean,
             called_at         TYPE utclong,
           END OF s_log,
           t_log TYPE TABLE OF s_log WITH EMPTY KEY.

    CLASS-DATA log_tab TYPE t_log.
    CLASS-METHODS get_method_info RETURNING VALUE(info) TYPE s_log.

  PROTECTED SECTION.
    METHODS meth_protected_1.

  PRIVATE SECTION.
    METHODS meth_private_1.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_1 IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: ABAP Object Orientation - Inheritance\n\n| ).

    "----- First level in the inheritance hierarchy ----
    "Creating an instance of the class
    DATA(oref_super) = NEW zcl_demo_abap_oo_inheritance_1( ).

    "Calling methods of the class
    oref_super->meth_public_1( ).
    oref_super->meth_public_1_final( ).
    oref_super->meth_protected_1( ).
    oref_super->meth_private_1( ).

    "----- Second level in the inheritance hierarchy ----
    "The instance creation and method calling is delegated to
    "a static method in the class
    zcl_demo_abap_oo_inheritance_2=>perform_meth_calls_2( ).
        zcl_demo_abap_oo_inheritance_4=>perform_meth_calls_4( ).

    "Writing the log table to the console
    out->write( data = log_tab name = `log_tab` ).

    "Excursion: Using RTTI to retrieve the name of the superclass
    "As this class starts an inheritance hierarchy, the superclass of this class
    "is the root class OBJECT.
    DATA(tdo_cl) = CAST cl_abap_classdescr( cl_abap_typedescr=>describe_by_name( 'ZCL_DEMO_ABAP_OO_INHERITANCE_1' ) ).
    DATA(superclass) = tdo_cl->get_super_class_type( )->get_relative_name( ).
    out->write( |\n\n| ).
    out->write( data = superclass name = `superclass` ).

  ENDMETHOD.

  METHOD class_constructor.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD constructor.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_private_1.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_1.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_1.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_1_final.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD get_method_info.

    "Getting callstack information
    DATA(call_stack_tab) = xco_cp=>current->call_stack->full( )->from->position( 2
                            )->to->position( 2 )->as_text( xco_cp_call_stack=>format->adt( )
                            )->get_lines( )->value.

    IF lines( call_stack_tab ) < 2.
      RETURN.
    ENDIF.

    LOOP AT call_stack_tab INTO DATA(wa) TO 2.
      DATA(tabix) = sy-tabix.
      SPLIT wa AT ` ` INTO TABLE DATA(entry).
      DELETE entry WHERE table_line IS INITIAL.

      DATA(class_name) = condense( val = entry[ 1 ] to = `` ).

      IF tabix = 1.
        info-implemented_where = class_name.

        DATA(meth_name) = condense( val = to_upper( entry[ 2 ] ) to = `` ).
        info-method = meth_name.

        IF class_name IS NOT INITIAL AND meth_name IS NOT INITIAL.
          DATA(tdo_cl) = CAST cl_abap_classdescr( cl_abap_typedescr=>describe_by_name( class_name ) ).
          DATA(methods_cl) = tdo_cl->methods.
          DATA(meth_info) = VALUE #( methods_cl[ name = meth_name ] OPTIONAL ).
          IF meth_info IS NOT INITIAL.
            info-is_inherited = meth_info-is_inherited.
            info-is_redefined = meth_info-is_redefined.
            info-is_final = meth_info-is_final.
            info-visibility = meth_info-visibility.
            info-is_static_method = meth_info-is_class.
          ENDIF.
        ENDIF.

      ELSE.
        info-called_from = class_name.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_2 DEFINITION
  INHERITING FROM zcl_demo_abap_oo_inheritance_1
  PUBLIC
  CREATE PROTECTED .

  PUBLIC SECTION.
    METHODS constructor.
    CLASS-METHODS class_constructor.

    METHODS meth_public_2.
    METHODS meth_public_2_final FINAL.

    CLASS-METHODS perform_meth_calls_2.
    METHODS meth_public_1 REDEFINITION.

  PROTECTED SECTION.
    METHODS meth_protected_2.
    METHODS meth_protected_1 REDEFINITION.
  PRIVATE SECTION.
ENDCLASS. """,
    r"""CLASS zcl_demo_abap_oo_inheritance_2 IMPLEMENTATION.
  METHOD class_constructor.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD constructor.
    super->constructor( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_2.
    "Method of this class
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_2_final.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_2.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_1.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_1.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD perform_meth_calls_2.
    DATA(oref_2) = NEW zcl_demo_abap_oo_inheritance_2( ).

    oref_2->meth_public_2( ).
    oref_2->meth_public_2_final( ).
    oref_2->meth_protected_2( ).
    oref_2->meth_protected_1( ).
    oref_2->meth_public_1( ).

  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_3 DEFINITION
  INHERITING FROM zcl_demo_abap_oo_inheritance_2
  PUBLIC
  ABSTRACT
  CREATE PUBLIC .

  PUBLIC SECTION.
    "Instance/static constructor declarations
    METHODS constructor.
    CLASS-METHODS class_constructor.

    "Instance method declarations
    METHODS meth_public_3.
    "Abstract method
    METHODS meth_public_3_abstract ABSTRACT.

    "Redefining methods from the class ...
    "... one level up in the inheritance hierarchy (i.e. the direct superclass)
    METHODS meth_public_2  REDEFINITION.
    "... two levels up in the inheritance hierarchy
    METHODS meth_public_1 REDEFINITION.

  PROTECTED SECTION.
    "Instance method declarations
    METHODS meth_protected_3.
    "Abstract method
    METHODS meth_protected_3_abstract ABSTRACT.

    "Redefining methods from the class ...
    "... one level up in the inheritance hierarchy (i.e. the direct superclass)
    METHODS meth_protected_2 REDEFINITION.
    "... two levels up in the inheritance hierarchy
    "Specifying the FINAL addition
    METHODS meth_protected_1 FINAL REDEFINITION.

  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_3 IMPLEMENTATION.

  METHOD class_constructor.
     INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD constructor.
    super->constructor( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_3.
    "Method of this class
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_3.
    "Method of this class
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_2.
    "Reimplementing a method from the class one level up in the inheritance hierarchy (direct superclass)
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_2.
    "Reimplementing a method from the class one level up in the inheritance hierarchy (direct superclass)
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_1.
    "Reimplementing a method from the class two levels up in the inheritance hierarchy
    "Note that the method is specified with FINAL REDEFINITION. So, a further redefinition in subclasses is not possible.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_1.
    "Reimplementing a method from the class two levels up in the inheritance hierarchy
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_4 DEFINITION
  INHERITING FROM zcl_demo_abap_oo_inheritance_3
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    "Instance/static constructor declarations
    METHODS constructor.
    CLASS-METHODS class_constructor.

    "Instance method declaration
    METHODS meth_public_4.
    "Static method declaration for display purposes
    CLASS-METHODS perform_meth_calls_4.

    "Redefining methods from the class ...
    "... one level up in the inheritance hierarchy (i.e. the direct superclass)
    METHODS meth_public_3 REDEFINITION.
    "Note: Redefining the abstract method here is mandatory.
    METHODS meth_public_3_abstract REDEFINITION.
    "... two levels up in the inheritance hierarchy
    METHODS meth_public_2 REDEFINITION.
    "... three levels up in the inheritance hierarchy
    METHODS meth_public_1 REDEFINITION.

  PROTECTED SECTION.

    "Instance method declaration
    METHODS meth_protected_4.

    "Redefining methods from the class ...
    "... one level up in the inheritance hierarchy (i.e. the direct superclass)
    METHODS meth_protected_3 REDEFINITION.
    "Note: Redefining the abstract method here is mandatory.
    METHODS meth_protected_3_abstract REDEFINITION.
    "... two levels up in the inheritance hierarchy
    METHODS meth_protected_2 REDEFINITION.
    "... three levels up in the inheritance hierarchy
    "The meth_protected_1 method is specified with FINAL REDEFINITION in the
    "direct superclass. Therefore, a further redefinition is not possible.
    "The following statement is not possible.
    "METHODS meth_protected_1 REDEFINITION.

  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_oo_inheritance_4 IMPLEMENTATION.

  METHOD class_constructor.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD constructor.
    super->constructor( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_4.
    "Method of this class
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_4.
    "Method of this class
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_3.
    "Reimplementing a method from the class one level up in the inheritance hierarchy (direct superclass)
    "Calling this instance method that is redefined in the abstract direct superclass (instances of abstract classes cannot be created)
    "by referring to the direct superclass using the syntax super->...
    super->meth_public_3( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_3.
    super->meth_protected_3( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_3_abstract.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_3_abstract.
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_2.
    super->meth_public_2( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_protected_2.
    super->meth_protected_2( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD meth_public_1.
    super->meth_public_1( ).
    INSERT VALUE #( called_at = utclong_current( ) ) INTO TABLE log_tab ASSIGNING FIELD-SYMBOL(<fs>).
    <fs> = CORRESPONDING #( BASE ( <fs> ) get_method_info( ) EXCEPT called_at ).
  ENDMETHOD.

  METHOD perform_meth_calls_4.
    DATA(oref_4) = NEW zcl_demo_abap_oo_inheritance_4( ).

    oref_4->meth_public_4( ).
    oref_4->meth_protected_4( ).
    oref_4->meth_public_3( ).
    oref_4->meth_public_3_abstract( ).
    oref_4->meth_protected_3( ).
    oref_4->meth_protected_3_abstract( ).
    oref_4->meth_public_2( ).
    oref_4->meth_protected_2( ).
    oref_4->meth_public_1( ).
    oref_4->meth_protected_1( ).
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_prog_flow_logic DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

  PROTECTED SECTION.
  PRIVATE SECTION.

    "Structured type for calculation example
    TYPES: BEGIN OF calc_results_struc,
             sy_tabix    LIKE sy-tabix,
             calculation TYPE string,
             res_if      TYPE string,
             res_case    TYPE string,
             res_cond    TYPE string,
             res_switch  TYPE string,
           END OF calc_results_struc.

    CLASS-METHODS:
      check_is_supplied IMPORTING num1       TYPE i DEFAULT 0
                                  num2       TYPE i DEFAULT 0
                        RETURNING VALUE(res) TYPE string_table,

      addition IMPORTING num1       TYPE i DEFAULT 0
                         num2       TYPE i DEFAULT 0
               RETURNING VALUE(res) TYPE i,

      calc IMPORTING num1       TYPE i DEFAULT 0
                     operator   TYPE c
                     num2       TYPE i DEFAULT 0
           RETURNING VALUE(res) TYPE calc_results_struc,

      validate_email IMPORTING email                 TYPE string
                     RETURNING VALUE(is_valid_email) TYPE abap_bool
                     RAISING   lcx_invalid_email,

      meth_with_return IMPORTING num        TYPE i
                       RETURNING VALUE(res) TYPE string,

      whats_my_user IMPORTING get_name    TYPE abap_bool
                    RETURNING VALUE(name) TYPE string
                    RAISING   lcx_static_exc_class,

      prep_calc_result CHANGING VALUE(res) TYPE string,

      power2_and_sqrt IMPORTING num           TYPE i
                      RETURNING VALUE(result) TYPE string
                      RAISING   cx_sy_arithmetic_overflow.

    CLASS-DATA: exception_text TYPE string,
                exception      TYPE REF TO cx_root.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_prog_flow_logic IMPLEMENTATION.


  METHOD addition.
    res = num1 + num2.
  ENDMETHOD.


  METHOD calc.

    DATA calc_if TYPE string.
    DATA calc_case TYPE string.
    DATA calc_cond TYPE string.
    DATA calc_switch TYPE string.

    "IF statements

    IF operator = `+`.
      calc_if = num1 + num2.
    ELSEIF operator = `-`.
      calc_if = num1 - num2.
    ELSEIF operator = `*`.
      calc_if = num1 * num2.
    ELSEIF operator = `/`.

      IF num2 = 0.
        calc_if = `Division by 0`.
      ELSE.
        calc_if = num1 / num2.
      ENDIF.
    ELSE.
      calc_if = |Check the operator { operator }.|.
    ENDIF.

    prep_calc_result( CHANGING res = calc_if ).

    "CASE

    CASE operator.
      WHEN '+'.
        calc_case = num1 + num2.
      WHEN '-'.
        calc_case = num1 - num2.
      WHEN '*'.
        calc_case = num1 * num2.
      WHEN '/'.

        CASE num2.
          WHEN 0.
            calc_case = `Division by 0`.
          WHEN OTHERS.
            calc_case = num1 / num2.
        ENDCASE.

      WHEN OTHERS.
        calc_case = |Check the operator { operator }.|.
    ENDCASE.

    prep_calc_result( CHANGING res = calc_case ).

    "COND

    calc_cond = COND #( WHEN operator = '+'
                  THEN num1 + num2
                  WHEN operator = '-'
                  THEN num1 - num2
                  WHEN operator = '*'
                  THEN num1 * num2
                  WHEN operator = '/' AND num2 = 0 THEN `Division by 0`
                  WHEN operator = '/' AND num2 <> 0 THEN num1 / num2
                  ELSE |Check the operator { operator }.|
     ).

    prep_calc_result( CHANGING res = calc_cond ).

    "SWITCH

    calc_switch = SWITCH #( operator
                  WHEN '+' THEN num1 + num2
                  WHEN '-' THEN num1 - num2
                  WHEN '*' THEN num1 * num2
                  WHEN '/' THEN SWITCH #( num2 WHEN 0 THEN `Division by 0` ELSE num1 / num2 )
                  ELSE |Check the operator { operator }.| ).

    prep_calc_result( CHANGING res = calc_switch ).

    res = VALUE #(  calculation = |{ num1 } { operator } { num2 }|
      res_if = calc_if
      res_case = calc_case
      res_cond = calc_cond
      res_switch = calc_switch
      ).

  ENDMETHOD.


  METHOD check_is_supplied.
    IF num1 IS SUPPLIED.
      APPEND `num1 is supplied` TO res.
    ELSE.
      APPEND `num1 is not supplied` TO res.
    ENDIF.

    IF num2 IS NOT SUPPLIED.
      APPEND `num2 is not supplied` TO res.
    ELSE.
      APPEND `num2 is supplied` TO res.
    ENDIF.
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Program Flow Logic\n\n| ).

**********************************************************************

    out->write( |1) Control Structure with IF\n| ).

    "Simple control structure realized by an IF ... ELSEIF ... ELSE ... ENDIF.
    "statement. Multiple statement blocks can be included, of which only 1 is
    "executed at most and depending on conditions.

    "Determining some operators for a calculation
    DATA(operators) = VALUE string_table( ( `+` ) ( `-` ) ( `?` ) ).

    "Getting a random operator from the table
    DATA(idx) = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( operators ) )->get_next( ).

    DATA(operator) = operators[ idx ].
    DATA(num1) = 5.
    DATA(num2) = 7.

    IF operator = `+`.
      out->write( |The result of { num1 } { operator } { num2 } is { num1 + num2 }. | ).
    ELSEIF operator = `-`.
      out->write( |The result of { num1 } { operator } { num2 } is { num1 - num2 }. | ).
    ELSE.
      out->write( |The operator { operator } is not possible.| ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) IF: Checking sy-subrc` ) ).

    "A prominent use case for IF statements: Checking sy-subrc.
    "In the case below, a FIND statement is used. If there is a finding,
    "sy-subrc has the value 0.

    DATA(to_be_found) = `AB`.
    DATA(string_to_search) = `ABAP is great!`.

    FIND to_be_found IN string_to_search.

    IF sy-subrc = 0.
      out->write( |'{ to_be_found }' was found in the string '{ string_to_search }'.| ).
    ELSE.
      out->write( |'{ to_be_found }' was not found in the string '{ string_to_search }'.| ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Excursion: COND Operator` ) ).

    "The conditional operator COND can also be used to implement branches in operand positions
    "that are based on logical expressions. Such conditional expressions have a result that
    "is dependent on the logical expressions.
    "The example provides an output based on the time stamp.

    DATA(syst_time) = cl_abap_context_info=>get_system_time( ).

    DATA(greetings) = COND #( WHEN syst_time BETWEEN '050001' AND '120000'
                              THEN |It's { syst_time TIME = ISO }. Good morning, { sy-uname }.|
                              WHEN syst_time BETWEEN '120001' AND '180000'
                              THEN |It's { syst_time TIME = ISO }. Good afternoon, { sy-uname }.|
                              WHEN syst_time BETWEEN '180001' AND '220000'
                              THEN |It's { syst_time TIME = ISO }. Good evening, { sy-uname }.|
                              ELSE |It's { syst_time TIME = ISO }. Good night, { sy-uname }.| ).

    out->write( data = greetings name = `greetings` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Expressions and Functions for Conditions` ) ).

    "Control structures are generally controlled by logical expressions that
    "define conditions for operands. The result of such an expression is either true or false.
    "The example demonstrates a selection of possible expressions and operands of such expressions
    "using a big IF statement. It includes multiple expressions combined by AND to demonstrate
    "different options. Here, it is just meant to cover many syntax options in one go
    "for demonstration purposes.

    "Data declarations to be used in the IF statement below
    DATA(num) = 2.                    "integer
    DATA(empty_string) = ``.          "empty string
    DATA(flag) = 'x'.
    DATA(dref) = NEW string( `ref` ). "data reference variable

    "Object reference variable
    DATA oref TYPE REF TO object.
    "Creating an object and assigning it to the reference variable
    oref = NEW zcl_demo_abap_prog_flow_logic( ).

    "Declaration of and assignment to a field symbol
    FIELD-SYMBOLS <fs> TYPE string.
    ASSIGN `hallo` TO <fs>.

    "Creating an internal table of type string inline
    DATA(str_table) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ).

    "Comparisons
    IF 2 = num    "equal, alternative EQ
    AND 1 <> num  "not equal, alternative NE
    AND 1 < num   "less than, alternative LT
    AND 3 > num   "greater than, alternative GT
    AND 2 >= num  "greater equal, alternative GE
    AND 2 <= num  "less equal, alternative LE

    "Checks whether the content of an operand operand is within a closed interval
    AND num BETWEEN 1 AND 3
    AND NOT num BETWEEN 5 AND 7   "NOT negates a logical expression
    AND ( num >= 1 AND num <= 3 ) "Equivalent to 'num BETWEEN 1 AND 3';
                                  "here, demonstrating the use of parentheses

    "CO, CN ,CA, NA, CS, NS, CP, NP  "Comparison operators for character-like data types;
                                     "see the cheat sheet on string processing

    "Predicate Expressions
    AND empty_string IS INITIAL  "Checks whether the operand operand is initial. The expression
                                 "is true, if the operand contains its type-dependent initial value
    AND num IS NOT INITIAL       "NOT negates

    AND dref IS BOUND  "Checks whether a data reference variable contains a valid reference and
                       "can be dereferenced;
                       "IS NOT BOUND is possible which is valid for the following examples, too
    AND oref IS BOUND  "Checks whether an object reference variable contains a valid reference

    "IS INSTANCE OF checks whether for a
    "a) non-initial object reference variable the dynamic type
    "b) for an initial object reference variable the static type
    "is more specific or equal to a comparison type.
    AND oref IS INSTANCE OF zcl_demo_abap_prog_flow_logic
    AND oref IS INSTANCE OF if_oo_adt_classrun

    AND <fs> IS ASSIGNED  "Checks whether a memory area is assigned to a field symbol

    "The predicate expression IS SUPPLIED is dealt with further down.

    "Predicate Functions
    AND contains( val = <fs> pcre = `\D` )  "Checks whether a certain value is contained;
                                            "the example uses the pcre parameter for regular expressions;
                                            "it checks whether there is any non-digit character contained
    AND matches( val = <fs> pcre = `ha.+` ) "Compares a search range of the argument for the val parameter
                                            "the example uses the pcre parameter for regular expressions;
                                            "it checks whether the value matches the pattern
                                            "'ha' and a sequence of any characters

    "Predicate functions for table-like arguments
    "Checks whether a line of an internal table specified in the table expression
    "exists and returns the corresponding truth value.
    AND line_exists( str_table[ 2 ] )

    "Predicative method call
    "The result of the relational expression is true if the result of the functional method call
    "is not initial and false if it is initial. The data type of the result of the functional method call,
    "i. e. the return value of the called function method, is arbitrary.
    "A check is made for the type-dependent initial value.
    AND check_is_supplied( )
    "It is basically the short form of such a predicate expression:
    AND check_is_supplied( ) IS NOT INITIAL

    "Boolean Functions
    "Determine the truth value of a logical expression specified as an argument;
    "the return value has a data type dependent on the function and expresses
    "the truth value of the logical expression with a value of this type.

    "Function boolc: Returns a single-character character string of the type string.
    "If the logical expression is true, X is returned. False: A blank is returned.
    "Not to be compared with the constants abap_true and abap_false in relational expressions,
    "since the latter converts from c to string and ignores any blanks. Note: If the logical
    "expression is false, the result of boolc does not meet the condition IS INITIAL, since
    "a blank and no empty string is returned. If this is desired, the function xsdbool
    "can be used instead of boolc.
    AND boolc( check_is_supplied( ) ) = abap_true

    "Result has the same ABAP type as abap_bool.
    AND xsdbool( check_is_supplied( ) ) = abap_true

    "Examples for possible operands

    "Data objects as shown in the examples above
    AND 2 = 2
    AND num = 2

    "Built-in functions
    AND to_upper( flag ) = 'X'
    AND NOT to_lower( flag ) = 'X'

    "Numeric functions
    AND ipow( base = num exp = 2 ) = 4

    "Functional methods
    "Method with exactly one return value
    AND addition( num1 = 1 num2 = 1 ) = 2

    "Calculation expressions
    AND 4 - 3 + 1 = num

    "String expressions
    AND `ha` && `llo` = <fs>

    "Constructor expression
    AND VALUE i( ) = 0
    AND VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ) = str_table

    "Table expression
    AND str_table[ 2 ] = `b`.
      out->write( `All of the logical expressions are true.` ).
    ELSE.
      out->write( `At least one of the logical expressions is false.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Predicate Expression with IS SUPPLIED` ) ).

    "The predicate expression IS SUPPLIED is available in method implementations
    "and checks whether a formal parameter of a procedure is filled or requested.
    "In this example, a method includes two importing parameters that are both
    "declared as non-mandatory. The method implementation includes a check with
    "IS SUPPLIED and stores the result. The result is returned and displayed.

    DATA(is_supplied) = check_is_supplied( num1 = 123 ).

    out->write( data = is_supplied name = `is_supplied` ).
    out->write( |\n| ).

    is_supplied = check_is_supplied( num2 = 456 ).

    out->write( data = is_supplied name = `is_supplied` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Control Structure with CASE` ) ).

    "CASE statements are used for case distinctions. If the content of an operand
    "specified after WHEN matches the content specified after CASE, the statement
    "block is executed. Constant values should be specified as operands.
    "The example is basically the same as above.

    "Determining some operators for a calculation
    operators = VALUE string_table( ( `+` ) ( `-` ) ( `#` ) ).

    "Getting a random operator from the table
    idx = cl_abap_random_int=>create(
      seed = cl_abap_random=>seed( ) min = 1
                                     max = lines( operators ) )->get_next( ).

    DATA(op) = operators[ idx ].
    DATA(n1) = 8.
    DATA(n2) = 3.

    "Simple calculation

    CASE op.
      WHEN '+'.
        out->write( |The result of { n1 } { op } { n2 } is { n1 + n2 }. | ).
      WHEN '-'.
        out->write( |The result of { n1 } { op } { n2 } is { n1 - n2 }. | ).
      WHEN OTHERS.
        out->write( |The operator { op } is not possible.| ).
    ENDCASE.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) CASE TYPE OF` ) ).

    "CASE TYPE OF: Checks the type of object reference variables

    "Creating an object reference variable and an object
    DATA oref_check TYPE REF TO object.
    oref_check = NEW zcl_demo_abap_prog_flow_logic( ).

    CASE TYPE OF oref_check.
      WHEN TYPE zcl_demo_abap_prog_flow_logic.
        out->write( `Type zcl_demo_abap_prog_flow_logic? True!` ).
      WHEN TYPE if_oo_adt_classrun.
        out->write( `Type if_oo_adt_classrun? True!` ).
      WHEN TYPE zcl_demo_abap_sql.
        out->write( `Type zcl_demo_abap_sql? True!` ).
      WHEN OTHERS.
        out->write( `Other type.` ).
    ENDCASE.

    out->write( |\n| ).

    "The same logic as above is realized in the following IF statements
    "using IS INSTANCE OF.
    "In the example, the type check for if_oo_adt_classrun 'comes first'.
    "This type is also true for the object reference variable. This class
    "implements the interface.
    IF oref_check IS INSTANCE OF if_oo_adt_classrun.
      out->write( `Type if_oo_adt_classrun? True!` ).
    ELSEIF oref_check IS INSTANCE OF zcl_demo_abap_prog_flow_logic.
      out->write( `Type zcl_demo_abap_prog_flow_logic? True!` ).
    ELSEIF oref_check IS INSTANCE OF zcl_demo_abap_sql.
      out->write( `Type zcl_demo_abap_sql? True!` ).
    ELSE.
      out->write( `Other type.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Excursion: SWITCH Operator` ) ).

    "The conditional operator SWITCH can also be used to make case
    "distinctions in operand positions. Such conditional expressions have
    "a result that is dependent on the logical expressions.
    "The example provides an output based on the date.

    DATA(syst_date) = cl_abap_context_info=>get_system_date( ).

    DATA(switch_res) = SWITCH #( syst_date+4(2)  "Extracting the month
                                  WHEN '01' THEN `January`
                                  WHEN '02' THEN `February`
                                  WHEN '03' THEN `March`
                                  WHEN '04' THEN `April`
                                  WHEN '05' THEN `May`
                                  WHEN '06' THEN `June`
                                  WHEN '07' THEN `July`
                                  WHEN '08' THEN `August`
                                  WHEN '09' THEN `September`
                                  WHEN '10' THEN `October`
                                  WHEN '11' THEN `November`
                                  WHEN '12' THEN `December`
                                  ELSE `Oops ...` ).

    out->write( data = switch_res name = `switch_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Loops (Iterations)` ) ).

    out->write( |9) Unconditional Loops with DO\n| ).

    "The example demonstrate the restriction of loop passes by specifying
    "a number (of maximum loop passes) and the TIMES addition in a DO loop.
    "The value of sy-index containing the number of loop passes is output, too.

    DATA do_counter TYPE i.
    DATA do_sy_index TYPE string.

    DO 10 TIMES.
      do_counter += 1.

      do_sy_index = do_sy_index && sy-index && ` `.
    ENDDO.

    out->write( data = do_counter name = `do_counter` ).
    out->write( |\n| ).
    out->write( data = do_sy_index name = `do_sy_index` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Terminating Loops Completely Using EXIT` ) ).

    "Using the EXIT statement, you can terminate a loop completely.
    "The program flow resumes after the closing statement of the loop.

    CLEAR: do_counter, do_sy_index.

    DO.
      do_counter += 1.

      do_sy_index = do_sy_index && sy-index && ` `.
      IF sy-index = 5.
        EXIT.
      ENDIF.
    ENDDO.

    out->write( data = do_counter name = `do_counter` ).
    out->write( |\n| ).
    out->write( data = do_sy_index name = `do_sy_index` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Terminating Loop Passes` ) ).

    "CONTINUE: The current loop pass is terminated immediately and the
    "          program flow is continued with the next loop pass.
    "CHECK: Conditional termination. If the specified logical expression
    "       is false, the current loop pass is terminated immediately and
    "       the program flow is continued with the next loop pass.

    CLEAR: do_counter, do_sy_index.

    DO.
      IF sy-index = 2. "skipped
        CONTINUE.
      ENDIF.

      CHECK sy-index <> 5. "skipped

      IF sy-index = 8. "terminates the loop completely
        EXIT.
      ENDIF.

      do_counter += 1.
      do_sy_index = do_sy_index && sy-index && ` `.
    ENDDO.

    out->write( data = do_counter name = `do_counter` ).
    out->write( |\n| ).
    out->write( data = do_sy_index name = `do_sy_index` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Excursion: Terminating Procedures Using RETURN` ) ).

    "RETURN statements immediately terminate the current processing block.
    "However, according to the guidelines, RETURN should only be used to exit
    "procedures like methods.
    "The method implementation includes a check if the passed number is positive.
    "If so, the square root is calculated. Otherwise, the method call is terminated.
    "That means, the returned value for the second method call is initial.

    DATA(return1) = meth_with_return( 81 ).

    out->write( data = return1 name = `return1` ).
    out->write( |\n| ).

    DATA(return2) = meth_with_return( -9 ).

    out->write( data = return2 name = `return2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Conditional Loops with WHILE` ) ).

    out->write( |13) WHILE Example 1\n| ).

    "The following example highlights the setting of sy-index within loop passes.
    "The value is added to an internal table. The loop iteration stops when
    "the internal table has 10 lines.

    DATA int_itab TYPE TABLE OF i.

    WHILE lines( int_itab ) < 10.
      int_itab = VALUE #( BASE int_itab ( sy-index ) ).
    ENDWHILE.

    out->write( data = int_itab name = `int_itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) WHILE Example 2` ) ).

    "In the following example, all occurrences of a certain substring
    "should be replaced by another string. Instead of, for example, using
    "a REPLACE ALL OCCURRENCES statement, a WHILE loop is used which
    "contains a FIND statement that stores offset and length of the found
    "substring. Then, a REPLACE statement is used and that only replaces
    "the substring according to the values. The condition for WHILE is
    "tailored in a way that the loop is terminated if there are no more
    "findings. The number of findings is also displayed - a number that
    "corresponds to the number of loop passes.

    DATA(while_string) = `##abap####abap#abap######abap###abapabap##abap`.
    DATA count_occ TYPE i.
    DATA count_occ_via_sy_index TYPE i.

    DATA(subrc) = 0. "separate dobj to store the sy-subrc value

    WHILE subrc = 0.
      FIND FIRST OCCURRENCE OF `abap` IN while_string
        MATCH LENGTH DATA(len)
        MATCH OFFSET DATA(off)
        MATCH COUNT DATA(cnt).
      "Note: cnt is always 1 since it is always the first occurrence.
      "      len is always 4 -> abap
      "      Only offset has different values

      "A separate data object subrc gets assigned the value of sy-subrc.
      "As long as there are findings in the string, the while loop continues.
      subrc = sy-subrc.

      IF subrc = 0.
        count_occ_via_sy_index = sy-index. "to hold the
        "To hold the total number of findings from left to right of the string
        count_occ = count_occ + cnt.
        REPLACE SECTION OFFSET off LENGTH len OF while_string WITH `ABAP`.
      ENDIF.
    ENDWHILE.

    out->write( data = count_occ_via_sy_index name = `count_occ_via_sy_index` ).
    out->write( |\n| ).
    out->write( data = count_occ name = `count_occ` ).
    out->write( |\n| ).
    out->write( data = while_string name = `while_string` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) WHILE Example 3` ) ).

    "The example demonstrates the 3 options for loop terminations
    "in the context of a WHILE ... ENDWHILE statement.

    DATA while_cnt TYPE i.
    DATA while_sy_index TYPE string.

    DATA(index) = 0.

    WHILE index <> 10.
      index = sy-index.

      IF sy-index = 2. "Skips loop pass
        CONTINUE.
      ENDIF.

      CHECK sy-index <> 5. "Skips loop pass

      IF sy-index = 8. "Terminates loop
        EXIT.
      ENDIF.

      while_cnt += 1.
      while_sy_index = while_sy_index && sy-index && ` `.
    ENDWHILE.

    out->write( data = while_cnt name = `while_cnt` ).
    out->write( |\n| ).
    out->write( data = while_sy_index name = `while_sy_index` ).


**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Loops across Tables` ) ).

    out->write( |16) Loop across Internal Table Using LOOP ... ENDLOOP\n\n| ).

    "LOOP ... ENDLOOP statements are meant for loops across internal tables.
    "For more examples, see the cheat sheet example on internal tables.
    "Note: In contrast to the loops above, the system field sy-index is not set.
    "Instead, the system field sy-tabix is set and which contains the table index
    "of the current table line in the loop pass.
    "The example demonstrates a loop across an internal table. It combines loops
    "and control structures mentioned before:
    "- An internal table includes two numbers and an operator based on which a
    "  a calculation is carried out.
    "- The calculation is done in a method. It is implemented in a way that
    "  IF and CASE statements as well as COND and SWITCH operators are used
    "  for the calculation.
    "- The calculation result is stored in an internal table which is output.
    "- All four results - which are all the same, of course, just demonstrating
    "  the variety of options to achieve the same regarding control structures -
    "  are available in the table. Plus, the value in sy-tabix is also added to
    "  the internal table representing the table index.

    TYPES: BEGIN OF calc_struc,
             num1     TYPE i,
             operator TYPE c LENGTH 1,
             num2     TYPE i,
           END OF calc_struc.

    DATA calc_itab TYPE TABLE OF calc_struc WITH EMPTY KEY.

    "Internal table containing numbers and operators on whose basis
    "calculations are to be carried out.
    calc_itab = VALUE #( ( num1 = 123 operator = '+' num2 = 456 )
                         ( num1 = -10 operator = '+' num2 = 9 )
                         ( num1 = 12 operator = '-' num2 = 89 )
                         ( num1 = -5 operator = '-' num2 = -12 )
                         ( num1 = 11 operator = '*' num2 = 10 )
                         ( num1 = -3 operator = '*' num2 = 3 )
                         ( num1 = 1 operator = '/' num2 = 5 )
                         ( num1 = -40 operator = '/' num2 = 2 )
                         ( num1 = 5 operator = '/' num2 = 0  )
                         ( num1 = 7 operator = '#' num2 = 4  ) ).

    DATA calc_results TYPE TABLE OF calc_results_struc WITH EMPTY KEY.

    LOOP AT calc_itab ASSIGNING FIELD-SYMBOL(<calc>).
      "Method call to calculate and return the result
      DATA(res) = calc( num1     = <calc>-num1
                        operator = <calc>-operator
                        num2     = <calc>-num2 ).

      "Adding the sy-tabix value to the table, too.
      res-sy_tabix = sy-tabix.
      APPEND res TO calc_results.
    ENDLOOP.

    out->write( data = calc_results name = `calc_results` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) SELECT Loop`  ) ).

    "SELECT ... ENDSELECT statements loop across the result set of a database access.
    "For more examples, see the cheat sheet example on ABAP SQL.
    "The example is meant to give an idea. The SELECT loop is purposely done across
    "an internal table which is also possible - just in the interest of not dealing
    "with a database table and not ensuring that a demo database table is filled.
    "As above, the example includes simple calculations.

    TYPES: BEGIN OF struc4loop,
             num         TYPE i,
             calc_result TYPE i,
           END OF struc4loop.

    TYPES ty_itab_select_loop TYPE TABLE OF struc4loop WITH EMPTY KEY.

    DATA(loop_pass) = 0.

    DATA(itab_select_loop) = VALUE ty_itab_select_loop( ( num = 1 )
                                                        ( num = 2 )
                                                        ( num = 3 )
                                                        ( num = 4 )
                                                        ( num = 5 )
                                                        ( num = 6 ) ).

    SELECT *
      FROM @itab_select_loop AS itab
      INTO @DATA(wa).

      IF sy-subrc = 0.
        "Loop pass stored and representing the table index value for the
        "ABAP SQL statement further down.
        loop_pass += 1.
        IF loop_pass <= 3.
          wa-calc_result = wa-num * 5.
        ELSEIF loop_pass = 6.
          "No calculation for this loop pass. Loop is terminated.
          EXIT.
        ELSE.
          wa-calc_result = wa-num * 100.
        ENDIF.
        "Inserting calculation result in table
        MODIFY itab_select_loop FROM wa INDEX loop_pass TRANSPORTING calc_result.
      ENDIF.
    ENDSELECT.

    out->write( data = itab_select_loop name = `itab_select_loop` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Exception Handling` ) ).

    out->write( |18) TRY Control Structures\n\n| ).

    "TRY control structures are meant for handling catchable exceptions locally
    "The example shows divisions. The predefined exception class cx_sy_zerodivide
    "as suitable exception class is used.
    "If the exception is not handled, the program is terminated and the runtime
    "error COMPUTE_INT_ZERODIVIDE occurs.
    "The third calculation is not carried out because the statement block is
    "left due to the previous erroneous 0 division.

    TRY.
        DATA(div1) = 4 / 2.
        out->write( data = div1 name = `div1` ).
        out->write( |\n| ).

        DATA(div2) = 4 / 0.
        out->write( data = div2 name = `div2` ).
        out->write( |\n| ).

        DATA(div3) = 9 / 3.
        out->write( data = div3 name = `div3` ).
        out->write( |\n| ).

      CATCH cx_sy_zerodivide.
        out->write( `0 division. The exception was caught.` ).
        out->write( |\n| ).
    ENDTRY.

    "The following example shows a catchable exception that is
    "raised if a line is not found when using table expressions.
    TRY.
        DATA(line) = str_table[ 12345 ].

        "The predefined exception class cx_sy_itab_line_not_found
        "as suitable exception class is used here.
        "If the exception is not handled, the program is terminated
        "and the runtime error ITAB_LINE_NOT_FOUND occurs.
      CATCH cx_sy_itab_line_not_found.
        out->write( `The line was not found. The exception was caught.` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) Multiple CATCH Blocks` ) ).

    "It is possible to specify multiple exception classes in a list and
    "multiple CATCH blocks.
    "Note: If there are multiple CATCH blocks for exceptions that are in an inheritance
    "relationship, you must pay attention that the more special exceptions are specified
    "before the more general ones.
    "The calculation example shows multiple CATCH blocks that themselves have more than
    "one exception class specified. Here, local exception classes are specified just for
    "demonstration purposes. They are not relevant in this TRY control structure.

    "Filling internal table of type i as basis for calculations
    int_itab = VALUE #( ( 5 ) ( 0 ) ( 987654321 ) ).

    LOOP AT int_itab ASSIGNING FIELD-SYMBOL(<fs_int>).
      TRY.
          out->write( |--- Calculations with { <fs_int> } ---| ).

          DATA(calc1) = CONV decfloat34( 1 / <fs_int> ).

          out->write( data = calc1 name = `calc1` ).
          out->write( |\n| ).

          DATA(calc2) = ipow( base = <fs_int> exp = 2 ).

          out->write( data = calc2 name = `calc2` ).
          out->write( |\n| ).
        CATCH cx_sy_arithmetic_overflow lcx_calc_error.
          out->write( `Arithmetic overflow. The exception was caught.` ).
        CATCH cx_sy_zerodivide lcx_some_error.
          out->write( `0 division. The exception was caught.` ).
      ENDTRY.
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) Using an Exception Class Higher Up in the Inheritance Tree` ) ).

    "In the following CATCH block, the predefined exception class cx_sy_arithmetic_error
    "is specified. Both cx_sy_zerodivide and cx_sy_arithmetic_overflow are derived from
    "cx_sy_arithmetic_error which is an exception class higher up in the inheritance
    "tree. Hence, cx_sy_arithmetic_error can be specified and handle both exceptions, too.
    "The following example is basically the same as above. However, only one exception
    "class is specified.

    LOOP AT int_itab ASSIGNING FIELD-SYMBOL(<fs_int_inh>).
      TRY.
          out->write( |--- Calculations with { <fs_int_inh> } ---| ).

          calc1 = 1 / <fs_int_inh>.

          out->write( data = calc1 name = `calc1` ).
          out->write( |\n| ).

          calc2 = ipow( base = <fs_int_inh> exp = 2 ).

          out->write( data = calc2 name = `calc2` ).
          out->write( |\n| ).
        CATCH cx_sy_arithmetic_error.
          out->write( `Arithmetic error. The exception was caught.` ).
      ENDTRY.
       out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) Storing a Reference to the Exception Object` ) ).

    "You can use the addition INTO plus an object reference variable to store
    "a reference to an exception object. It is, for example, relevant to
    "determine the exact exception.
    "The following example is the same as above using the more general exception
    "class cx_sy_arithmetic_error. You can carry out certain tasks, for
    "example, retrieving and displaying the exception text. To retrieve exception
    "texts, you can call, for example, the method get_text.

    LOOP AT int_itab ASSIGNING FIELD-SYMBOL(<fs_int_into>).

      TRY.
          out->write( |--- Calculations with { <fs_int_into> } ---| ).

          calc1 = 1 / <fs_int_into>.

          out->write( data = calc1 name = `calc1` ).
          out->write( |\n| ).

          calc2 = ipow( base = <fs_int_into> exp = 2 ).

          out->write( data = calc2 name = `calc2` ).
          out->write( |\n| ).
        CATCH cx_sy_arithmetic_error INTO exception.
          "Note:
          "- The object reference variable is of type cx_root.
          "- You could also create the variable inline, e. g. ... INTO DATA(exc).

          "Retrieving and displaying exception text
          exception_text = exception->get_text( ).

          out->write( data = exception_text name = `exception_text` ).
      ENDTRY.
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Raising Exceptions Programmatically` ) ).

    "The following examples demonstrate the ABAP statement RAISE EXCEPTION
    "using the addition TYPE. Note there are more additions available that
    "are not dealt with here.

    "ABAP 'allows' zero division if the first operand is also 0 as shown
    "here.
    DATA(division) = 0 / 0.

    out->write( data = division name = `division` ).
    out->write( |\n| ).

    "In this example, the appropriate exception - the predefined exception
    "class cx_sy_zerodivide - is raised.
    TRY.
        division = 0 / 0.

        "raise predefined exception for 0 division
        RAISE EXCEPTION TYPE cx_sy_zerodivide.

      CATCH cx_sy_zerodivide INTO DATA(error_oref).
        exception_text = error_oref->get_text( ).
        out->write( data = exception_text name = `exception_text` ).
        out->write( |\n| ).
    ENDTRY.

    "The following example just demonstrates a locally defined
    "exception class that must be raised programmatically.
    "In ADT, see the definition of the class in the include, i. e.
    "the tab 'Class-relevant Local Types'.
    TRY.
        RAISE EXCEPTION TYPE lcx_some_error.
      CATCH lcx_some_error INTO exception.
        exception_text = exception->get_text( ).

        out->write( `Default exception text for a local exception class:` ).
        out->write( data = exception_text name = `exception_text` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Nested TRY Control Structure` ) ).

    TRY.
        TRY.
            RAISE EXCEPTION TYPE lcx_some_error.
          CATCH lcx_some_error INTO DATA(error_inner_catch).
            out->write( `Inner CATCH` ).
            RAISE EXCEPTION error_inner_catch.
        ENDTRY.
      CATCH lcx_some_error.
        out->write( `Outer CATCH` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) Raising an Exception in the Context of Conditional Expressions` ) ).

    "In this example, the optional addition THROW is used in a conditional
    "expression. A self-defined local exception class is used.

    DATA(number) = 3.

    TRY.
        DATA(cond_raise) = COND #( WHEN number = 1 THEN `one`
                                   WHEN number = 2 THEN `two`
                                   ELSE THROW lcx_some_error( ) ).

        out->write( data = cond_raise name = `cond_raise` ).
      CATCH lcx_some_error INTO exception.
        exception_text = exception->get_text( ).
        out->write( data = exception_text name = `exception_text` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) RAISING Parameter in Method Delcarations` ) ).

    "In the following example, a string table is looped across. The table
    "includes valid and invalid email addresses. The validity is checked
    "in a method. In the method, a local exception class is raised if the
    "email address is invalid.

    str_table = VALUE string_table( ( `john.doe@email.com` )         "valid
                                    ( `john.doe@#email.com` )        "invalid
                                    ( `jane.doe@email.com` )         "valid
                                    ( `jane#doe@email.com` )         "invalid
                                    ( `max.mustermann@email12.com` ) "valid
                                    ( `max.mustermann@email12.c#m` ) "invalid
                                    ( `some_name@email.com` )        "valid
                                    ( `some_name@email.c` )          "invalid
                                  ).

    TYPES: BEGIN OF struc_email_check,
             email            TYPE string,
             is_email_valid   TYPE abap_bool,
             exception_raised TYPE abap_bool,
           END OF  struc_email_check.

    DATA itab_email_check TYPE TABLE OF struc_email_check WITH EMPTY KEY.

    LOOP AT str_table ASSIGNING FIELD-SYMBOL(<email>).
      TRY.
          DATA(email_valid) = validate_email( email = <email> ).
          DATA(exc_raised) = abap_false.
        CATCH lcx_invalid_email.
          email_valid = abap_false.
          exc_raised = abap_true.
      ENDTRY.

      APPEND VALUE #( email = <email>
                      is_email_valid = email_valid
                      exception_raised = exc_raised ) TO itab_email_check.
    ENDLOOP.

    out->write( data = itab_email_check name = `itab_email_check` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26) Exception Classes Derived from CX_STATIC_CHECK` ) ).

    "Exception Classes of type cx_static_check force users to handle exceptions.
    "Exceptions that are declared in the method signature make users aware of which
    "potential exception might occur. And the exceptions should be respected when using
    "such a method.
    "In this simplified example, a method has a self-defined local exception class
    "specified for the RAISING addition. If an actual parameter has a certain
    "value, the method raises an exception.
    "You can comment in the following line of code to see the enforcement.
    "A syntax warning is displayed since there is no proper exception handling.

    "DATA(my_user_a) = whats_my_user( get_name = abap_false ).

    "Method call with a proper exception handling
    TRY.
        DATA(my_user_b) = whats_my_user( get_name = abap_true ).

        out->write( data = my_user_b name = `my_user_b` ).
        out->write( |\n| ).

        DATA(my_user_c) = whats_my_user( get_name = abap_false ).

        out->write( data = my_user_c name = `my_user_c` ).
      CATCH lcx_static_exc_class INTO exception.
        exception_text = exception->get_text( ).
        out->write( data = exception_text name = `exception_texts` ).
    ENDTRY.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `27) Exception Classes Derived from CX_DYNAMIC_CHECK` ) ).

    "Exception Classes derived from cx_dynamic_check are for exceptions that
    "can be checked and avoided by preconditions.
    "The checking if a local handling or an explicit declaration in procedure
    "interfaces is available is carried out at runtime only ("dynamic check")
    "and only in case the exception is indeed raised.
    "The following example includes two TRY control structures in which a
    "method is called that carries out calculations. In this case, the
    "method uses the imported value and carries out two calculations (the
    "value powered by 2 and the square root).
    "The method signature purposely only includes the exception class
    "cx_sy_arithmetic_overflow, i. e. calculation errors regarding the
    "square root calculation are 'ignored' here.
    "The two exception classes cx_sy_arithmetic_overflow and cx_sy_arg_out_of_domain
    "are both derived from cx_dynamic_check.

    "This TRY control structure only catches exception for
    "cx_sy_arithmetic_overflow. The example does purposely not
    "include an error for the square root calculation. If you
    "implemented the code outside of the TRY control structure,
    "there would not be a syntax warning. Actually, you could
    "prevent a calculation failure by setting appropriate values.
    TRY.
        DATA(res1) = power2_and_sqrt( num = 4 ).

        out->write( data = res1 name = `res1` ).
        out->write( |\n| ).

        DATA(res2) = power2_and_sqrt( num = 123456789 ).

        out->write( data = res2 name = `res2` ).
        out->write( |\n| ).

      CATCH cx_sy_arithmetic_overflow INTO exception.
        exception_text = exception->get_text( ).
        out->write( data = exception_text name = `exception_text` ).
        out->write( |\n| ).
    ENDTRY.

    "This TRY control structure demonstrates the following:
    "If it is determined at runtime that an exception derived from cx_dynamic_check
    "is neither locally handled nor an interface is declared appropriately - and the
    "exception is raised - a new exception of type cx_sy_no_handler is raised. In this
    "case, the attribute 'previous' contains a reference to the original exception.
    TRY.
        DATA(res3) = power2_and_sqrt( num = 16 ).

        out->write( data = res3 name = `res3` ).
        out->write( |\n| ).

        DATA(res4) = power2_and_sqrt( num = -1 ).

        out->write( data = res4 name = `res4` ).
        out->write( |\n| ).

        "The specification of the suitable exception class does not help here.
        "The error is raised while processing the method.
      CATCH cx_sy_arg_out_of_domain INTO exception.
        exception_text = exception->get_text( ).

        out->write( data = exception_text name = `exception_text` ).
        out->write( |\n| ).
      CATCH cx_sy_no_handler INTO exception.
        exception_text = exception->get_text( ).

        out->write( data = exception_text name = `exception_text` ).
        out->write( |\n| ).

        "Attribute 'previous'
        "In this case, the information of the actual runtime error is provided:
        "Here, it is COMPUTE_SQRT_DOMAIN.
        out->write( data = exception->previous name = `exception->previous` ).
        out->write( |\n| ).

        "For demo purposes, RTTI is used here to retrieve the relative name of the type,
        "i. e. the exception class that was raised.
        DATA(relative_name) = cl_abap_typedescr=>describe_by_object_ref( exception->previous )->get_relative_name( ).

        out->write( data = relative_name name = `relative_name` ).
    ENDTRY.

**********************************************************************

    "Excursion: Runtime Errors and Terminating Programs

    out->write( zcl_demo_abap_aux=>heading( `28) Excursion: Runtime Errors and Terminating Programs` ) ).

    "ASSERT statements are followed by a logical expression. If the expression is false,
    "the program is terminated and an uncatchable exception is raised resulting in the
    "runtime error ASSERTION_FAILED.
    "You can comment in the code that is commented out below to check out the effect.
    "In ADT, you will see a message popping up and informing you about the runtime error.
    "You can check the details by choosing the "Show" button in the pop-up. Furthermore,
    "you can check the content of the "Feed Reader" tab in ADT. There, just expand your
    "project and find the runtime errors caused by you.

    "Terminating a program using ASSERT
    ASSERT 1 = 1.

    "ASSERT 1 + 2 = 5 - 3.

    DATA(some_flag) = abap_false.

    "ASSERT some_flag = abap_true.

    "Not handling predefined exception classes
    "Caused runtime errors COMPUTE_INT_ZERODIVIDE and ITAB_LINE_NOT_FOUND

    "DATA(zero_division) = 1 / 0.
    "DATA(nope) = str_table[ 12345 ].

    "Not handling self-defined exception classes
    "Causes runtime error UNCAUGHT_EXCEPTION

    "DATA(is_email_valid) = validate_email( email = `john.doe@email.c##` ).

    out->write( `This text is displayed if you left all statements causing a runtime error commented out :)` ).
  ENDMETHOD.

  METHOD meth_with_return.
    IF num >= 0.
      DATA(sqr_res) = sqrt( num ).
    ELSE.
      RETURN.
    ENDIF.

    res = `The method call was not terminated. The square root of ` && num && ` is ` && sqr_res.
  ENDMETHOD.

  METHOD power2_and_sqrt.
    result = |{ num } powered by 2 = { ipow( base = num exp = 2 ) } / Square root of { num } = { sqrt( num ) }|.
  ENDMETHOD.


  METHOD prep_calc_result.
    FIND PCRE `-$` IN res.  "trailing minus

    IF sy-subrc = 0.
      SHIFT res BY 1 PLACES RIGHT CIRCULAR.
    ENDIF.

    "trailing .0
    IF res CP `*.0*`.
      SHIFT res RIGHT DELETING TRAILING ` `.
      SHIFT res LEFT  DELETING LEADING ` `.
      FIND PCRE `\.0$` IN res.

      IF sy-subrc = 0.
        REPLACE `.0` IN res WITH ``.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD validate_email.
    IF matches( val   = email
                pcre = `\w+(\.\w+)*@(\w+\.)+(\w{2,4})` ).
      is_valid_email = abap_true.
    ELSE.
      RAISE EXCEPTION TYPE lcx_invalid_email.
    ENDIF.
  ENDMETHOD.

  METHOD whats_my_user.
    IF get_name = abap_true.
      name = sy-uname.
    ELSE.
      RAISE EXCEPTION TYPE lcx_static_exc_class.
    ENDIF.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS lcx_calc_error DEFINITION INHERITING FROM cx_no_check.
ENDCLASS.

CLASS lcx_some_error DEFINITION INHERITING FROM cx_no_check.
ENDCLASS.

CLASS lcx_invalid_email DEFINITION INHERITING FROM cx_no_check.
ENDCLASS.

CLASS lcx_static_exc_class DEFINITION INHERITING FROM cx_static_check.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_draft_ln_m DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS:
      class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA:
      activate_tab  TYPE TABLE FOR ACTION IMPORT
                      zdemo_abap_rap_draft_m~activate,
      activate_tab2 TYPE TABLE FOR ACTION IMPORT
                      zdemo_abap_rap_draft_m~activate,
      activate_tab3 TYPE TABLE FOR ACTION IMPORT
                      zdemo_abap_rap_draft_m~activate,
      edit_tab      TYPE TABLE FOR ACTION IMPORT
                      zdemo_abap_rap_draft_m~edit,
      read_tab      TYPE TABLE FOR READ IMPORT zdemo_abap_rap_draft_m,
      f             TYPE RESPONSE FOR FAILED zdemo_abap_rap_draft_m,
      r             TYPE RESPONSE FOR REPORTED zdemo_abap_rap_draft_m,
      m             TYPE RESPONSE FOR MAPPED zdemo_abap_rap_draft_m.

    CLASS-METHODS:
      initialize_dbtabs.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_draft_ln_m IMPLEMENTATION.


  METHOD class_constructor.
    initialize_dbtabs( ).
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( `ABAP Cheat Sheet Example: RAP Calculator Using Managed, ` &&
                      |Draft-Enabled RAP BO (Late Numbering)\n\n| ).
    out->write( |1) Creating Instances and Saving to the database\n| ).

    "Creating instances; draft indicator %is_draft is enabled
    MODIFY ENTITY zdemo_abap_rap_draft_m
     CREATE AUTO FILL CID
     FIELDS ( num1 arithm_op num2 )
     WITH VALUE #(
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 1 arithm_op = '+' num2 = 2 )
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 2 arithm_op = '*' num2 = 4 )
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 3 arithm_op = '-' num2 = 5 )
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 1 arithm_op = '/' num2 = 4 )
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 2 arithm_op = 'P' num2 = 5 ) )
        FAILED f
        REPORTED r
        MAPPED m.

    "Displaying responses only if FAILED and REPORTED
    "response parameters are not initial
    IF f IS NOT INITIAL OR r IS NOT INITIAL.
      out->write( `Responses after MODIFY operation` ).
      out->write( |\n| ).

      IF m IS NOT INITIAL.
        out->write( data = m name = `m` ).
        out->write( |\n| ).
      ENDIF.

      IF f IS NOT INITIAL.
        out->write( data = f name = `f` ).
        out->write( |\n| ).
      ENDIF.

      IF r IS NOT INITIAL.
        out->write( data = r name = `r` ).
        out->write( |\n| ).
      ENDIF.
    ENDIF.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving draft table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time, draftentitycreationdatetime,
           draftentitylastchangedatetime
     FROM zdemo_abap_draft
     ORDER BY id
     INTO TABLE @DATA(draft_parent_before_act).

    "Retrieving database table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time
     FROM zdemo_abap_tabca
     ORDER BY id
     INTO TABLE @DATA(db_tab_root_before_act).

    "Filling the derived type for the ACTIVATE method by
    "getting %pid values
    LOOP AT m-calc
      ASSIGNING FIELD-SYMBOL(<fs>).
      APPEND VALUE #( %pid = <fs>-%pid )
                             TO activate_tab.
    ENDLOOP.

    MODIFY ENTITY zdemo_abap_rap_draft_m
      EXECUTE activate AUTO FILL CID WITH activate_tab
      MAPPED m
      FAILED f
      REPORTED r.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving draft table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time, draftentitycreationdatetime,
           draftentitylastchangedatetime
     FROM zdemo_abap_draft
     ORDER BY id
     INTO TABLE @DATA(draft_parent_afer_act).

    "Retrieving database table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time
     FROM zdemo_abap_tabca
     ORDER BY id
     INTO TABLE @DATA(db_tab_root_after_act).

    "Displaying entries
    out->write( |1a) Draft and database tables before ACTIVATE action\n| ).
    out->write( `Draft table before activation` ).
    out->write( |\n| ).
    out->write( data = draft_parent_before_act name = `draft_parent_before_act` ).
    out->write( |\n| ).
    out->write( `Database table before activation` ).
    out->write( |\n| ).
    out->write( data = db_tab_root_before_act name = `db_tab_root_before_act` ).

    out->write( zcl_demo_abap_aux=>heading( `1b) Draft and database tables after ` &&
                   `ACTIVATE action` ) ).
    out->write( `Draft table after activation` ).
    out->write( |\n| ).
    out->write( data = draft_parent_afer_act name = `draft_parent_afer_act` ).
    out->write( |\n| ).
    out->write( `Database table after activation` ).
    out->write( |\n| ).
    out->write( data = db_tab_root_after_act name = `db_tab_root_after_act` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Creating Invalid Instances` ) ).

    "Purposely creating invalid instances;
    "draft indicator %is_draft is enabled
    MODIFY ENTITY zdemo_abap_rap_draft_m
     CREATE AUTO FILL CID
     FIELDS ( num1 arithm_op num2 )
     WITH VALUE #(
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 1 arithm_op = 'a' num2 = 1 )  "wrong operator
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 1 arithm_op = '/' num2 = 0 ) "0 division
        ( %is_draft = if_abap_behv=>mk-on
          num1 = 2 arithm_op = 'P' num2 = 12345 ) ) "arithmetic overflow
        FAILED f
        REPORTED r
        MAPPED m.

    "Displaying responses only if FAILED and REPORTED
    "response parameters are not initial.
    IF f IS NOT INITIAL OR r IS NOT INITIAL.
      out->write( data = `Responses after MODIFY operation` ).
      out->write( |\n| ).

      IF m IS NOT INITIAL.
        out->write( data = m name = `m` ).
        out->write( |\n| ).
      ENDIF.

      IF f IS NOT INITIAL.
        out->write( data = f name = `f` ).
        out->write( |\n| ).
      ENDIF.

      IF r IS NOT INITIAL.
        out->write( data = r name = `r` ).
        out->write( |\n| ).
      ENDIF.

    ENDIF.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving draft table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time, draftentitycreationdatetime,
           draftentitylastchangedatetime
     FROM zdemo_abap_draft
     ORDER BY id
     INTO TABLE @draft_parent_before_act.

    "Retrieving database table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time
     FROM zdemo_abap_tabca
     ORDER BY id
     INTO TABLE @db_tab_root_before_act.

    "Filling the derived type for the ACTIVATE method by
    "getting %pid values; here, another table is filled for later use
    LOOP AT m-calc
      ASSIGNING FIELD-SYMBOL(<fs2>).

      APPEND VALUE #( %pid = <fs2>-%pid )
                             TO activate_tab2.

      APPEND VALUE #( %pid = <fs2>-%pid )
                             TO activate_tab3.
    ENDLOOP.

    MODIFY ENTITY zdemo_abap_rap_draft_m
      EXECUTE activate AUTO FILL CID WITH activate_tab2
      MAPPED m
      FAILED f
      REPORTED r.

    "Displaying responses only if FAILED and REPORTED
    "response parameters are not initial.
    IF f IS NOT INITIAL OR r IS NOT INITIAL.
      out->write( data = `Responses after MODIFY operation` ).
      out->write( |\n| ).

      IF m IS NOT INITIAL.
        out->write( data = m name = `m` ).
        out->write( |\n| ).
      ENDIF.

      IF f IS NOT INITIAL.
        out->write( data = f name = `f` ).
        out->write( |\n| ).
      ENDIF.

      IF r IS NOT INITIAL.
        out->write( data = r name = `r` ).
        out->write( |\n| ).
      ENDIF.

    ENDIF.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving draft table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time, draftentitycreationdatetime,
           draftentitylastchangedatetime
     FROM zdemo_abap_draft
     ORDER BY id
     INTO TABLE @draft_parent_afer_act.

    "Retrieving database table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time
     FROM zdemo_abap_tabca
     ORDER BY id
     INTO TABLE @db_tab_root_after_act.

    "Displaying entries
    out->write( zcl_demo_abap_aux=>heading( `2a) Draft and database tables before ` &&
                   `ACTIVATE action` ) ).
    out->write( `Draft table before activation` ).
    out->write( |\n| ).
    out->write( data = draft_parent_before_act name = `draft_parent_before_act` ).
    out->write( |\n| ).
    out->write( `Database table before activation` ).
    out->write( |\n| ).
    out->write( data = db_tab_root_before_act name = `db_tab_root_before_act` ).

    out->write( zcl_demo_abap_aux=>heading( `2b) Draft and database tables after ` &&
                   `ACTIVATE action` ) ).
    out->write( `Draft table after activation` ).
    out->write( |\n| ).
    out->write( data = draft_parent_afer_act name = `draft_parent_afer_act` ).
    out->write( |\n| ).
    out->write( `Database table after activation` ).
    out->write( |\n| ).
    out->write( data = db_tab_root_after_act name = `db_tab_root_after_act` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Correcting and Updating Invalid Instances` ) ).

    "Preparing the derived type for the read operation to
    "retrieve the field values; the draft indicator is enabled
    LOOP AT activate_tab3 ASSIGNING FIELD-SYMBOL(<fs3>).

      APPEND VALUE #( %pky = <fs3>-%pky
                      %is_draft = if_abap_behv=>mk-on
                      %control-id = if_abap_behv=>mk-on
                      %control-num1 = if_abap_behv=>mk-on
                      %control-arithm_op = if_abap_behv=>mk-on
                      %control-num2 = if_abap_behv=>mk-on
                      %control-calc_result = if_abap_behv=>mk-on
                      %control-crea_date_time = if_abap_behv=>mk-on
                      %control-lchg_date_time = if_abap_behv=>mk-on
                    ) TO read_tab.
    ENDLOOP.

    "Retrieving the entries of the invalid instances
    READ ENTITY zdemo_abap_rap_draft_m
      ALL FIELDS WITH read_tab
      RESULT DATA(result).

    "Correcting and updating the invalid instances
    MODIFY ENTITY zdemo_abap_rap_draft_m
      UPDATE FROM VALUE #(
        FOR wa IN result (
            %pid = wa-%pid
            %is_draft = if_abap_behv=>mk-on
            num2 = SWITCH #( wa-calc_result
              WHEN `Division by 0` THEN 2
              WHEN `Overflow error` THEN 3 )
            arithm_op = SWITCH #( wa-calc_result
              WHEN `Wrong operator` THEN '+' )
            %control-num2 = SWITCH #( wa-calc_result
              WHEN `Division by 0` THEN if_abap_behv=>mk-on
              WHEN `Overflow error` THEN if_abap_behv=>mk-on
              ELSE if_abap_behv=>mk-off )
            %control-arithm_op = SWITCH #( wa-calc_result
              WHEN `Wrong operator` THEN if_abap_behv=>mk-on
              ELSE if_abap_behv=>mk-off ) ) )
        FAILED f
        REPORTED r
        MAPPED m.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    MODIFY ENTITY zdemo_abap_rap_draft_m
      EXECUTE activate AUTO FILL CID WITH activate_tab3
      MAPPED m
      FAILED f
      REPORTED r.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving draft table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time, draftentitycreationdatetime,
           draftentitylastchangedatetime
     FROM zdemo_abap_draft
     ORDER BY id
     INTO TABLE @draft_parent_afer_act.

    "Retrieving database table entries
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time,
           lchg_date_time
     FROM zdemo_abap_tabca
     ORDER BY id
     INTO TABLE @db_tab_root_after_act.

    "Displaying entries
    out->write( data = `Draft and database tables after ` &&
                   `ACTIVATE action` ).
    out->write( |\n| ).
    out->write( `Draft table after activation` ).
    out->write( |\n| ).
    out->write( data = draft_parent_afer_act name = `draft_parent_afer_act` ).
    out->write( |\n| ).
    out->write( `Database table after activation` ).
    out->write( |\n| ).
    out->write( data = db_tab_root_after_act name = `db_tab_root_after_act` ).
  ENDMETHOD.

  METHOD initialize_dbtabs.
    DELETE FROM zdemo_abap_tabca.
    DELETE FROM zdemo_abap_draft.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_evt_handler DEFINITION
  PUBLIC ABSTRACT FINAL
  FOR EVENTS OF zdemo_abap_rap_ro_m_as.

  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap_rap_evt_handler IMPLEMENTATION.
ENDCLASS.""",
    r"""CLASS lhe_event DEFINITION INHERITING FROM cl_abap_behavior_event_handler.

  PRIVATE SECTION.

    METHODS on_updated FOR ENTITY EVENT
       updated FOR root~updated.

    METHODS on_deleted FOR ENTITY EVENT
       deleted FOR root~deleted.

    METHODS on_created FOR ENTITY EVENT
       created FOR root~created.

    DATA evt_log TYPE TABLE OF zdemo_abap_draft WITH EMPTY KEY.
ENDCLASS.""",
    r"""CLASS lhe_event IMPLEMENTATION.

  "Note:
  "- For this example, database table entries are created for the individual
  "  RAP BO instances that are imported into the event handler methods.
  "- The transactional phases are implicitly set when RAP business events are
  "  consumed locally. This means that RAP event handler methods are started in
  "  the modify phase when called. If database modifications are to be implemented
  "  in RAP event handler methods, you must explicitly activate the save phase to
  "  avoid causing errors detected by the controlled SAP LUW.

  METHOD on_created.
    cl_abap_tx=>save( ).
    LOOP AT created ASSIGNING FIELD-SYMBOL(<created>).
      TRY.
          APPEND VALUE #( id         = cl_system_uuid=>create_uuid_x16_static( )
                          draftuuid  = cl_system_uuid=>create_uuid_x16_static( )
                          calc_result    = |Instance key: "{ <created>-id }" / Event CREATED raised|
                          crea_date_time = cl_abap_tstmp=>utclong2tstmp( utclong_current( ) )
                        ) TO evt_log.
        CATCH cx_uuid_error INTO DATA(err).
          ASSERT err IS INITIAL.
      ENDTRY.
      MODIFY zdemo_abap_draft FROM TABLE @evt_log.
    ENDLOOP.
  ENDMETHOD.

  METHOD on_updated.
    cl_abap_tx=>save( ).
    LOOP AT updated  ASSIGNING FIELD-SYMBOL(<updated>).
      TRY.
          APPEND VALUE #( id         = cl_system_uuid=>create_uuid_x16_static( )
                          draftuuid  = cl_system_uuid=>create_uuid_x16_static( )
                          calc_result    = |Instance key: "{ <updated>-id }" / %param: col1: "{ <updated>-%param-col1 }" col2: "{ <updated>-%param-col2 }"|
                          crea_date_time = cl_abap_tstmp=>utclong2tstmp( utclong_current( ) )
                        ) TO evt_log.
        CATCH cx_uuid_error INTO DATA(err).
          ASSERT err IS INITIAL.
      ENDTRY.
      MODIFY zdemo_abap_draft FROM TABLE @evt_log.
    ENDLOOP.
  ENDMETHOD.

  METHOD on_deleted.
    cl_abap_tx=>save( ).
    LOOP AT deleted ASSIGNING FIELD-SYMBOL(<deleted>).
      TRY.
          APPEND VALUE #( id         = cl_system_uuid=>create_uuid_x16_static( )
                          draftuuid  = cl_system_uuid=>create_uuid_x16_static( )
                          calc_result    = |Instance key: "{ <deleted>-id }" / %param: col1: "{ <deleted>-%param-col1 }" col2: "{ <deleted>-%param-col2 }"|
                          crea_date_time = cl_abap_tstmp=>utclong2tstmp( utclong_current( ) )
                        ) TO evt_log.
        CATCH cx_uuid_error INTO DATA(err).
          ASSERT err IS INITIAL.
      ENDTRY.
      MODIFY zdemo_abap_draft FROM TABLE @evt_log.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_ext_num_m DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS:
      class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA:
      failed   TYPE RESPONSE FOR FAILED zdemo_abap_rap_ro_m,
      reported TYPE RESPONSE FOR REPORTED zdemo_abap_rap_ro_m,
      mapped   TYPE RESPONSE FOR MAPPED zdemo_abap_rap_ro_m,
      op       TYPE string.
    CLASS-METHODS:
      initialize_dbtabs,
      "If there are entries in the response parameters following EML
      "requests, they should be processed for displaying purposes.
      extract_from_reported RETURNING VALUE(messages) TYPE string_table,
      extract_from_failed RETURNING VALUE(errors) TYPE string_table,
      fill_db_tab.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_ext_num_m IMPLEMENTATION.


  METHOD class_constructor.
    initialize_dbtabs( ).
  ENDMETHOD.


  METHOD extract_from_failed.
    CLEAR errors.

    LOOP AT failed-root ASSIGNING FIELD-SYMBOL(<err>).
      CASE if_abap_behv=>mk-on.
        WHEN <err>-%op-%create.
          op = `create operation`.
        WHEN <err>-%op-%update.
          op = `update operation`.
        WHEN <err>-%op-%delete.
          op = `delete operation`.
        WHEN <err>-%op-%assoc-_child.
          op = `operation involving the child entity`.
        WHEN <err>-%op-%action-multiply_by_2.
          op = `executing action multiply_by_2`.
        WHEN OTHERS. op = `operation`.
      ENDCASE.

      APPEND `Error for instance with ` &&
           COND #( WHEN <err>-%cid IS NOT INITIAL THEN `%cid = `
                   && <err>-%cid
                   ELSE `key = ` && <err>-key_field ) &&
           `: Fail cause ` &&  <err>-%fail-cause && ` for ` &&  op
            && `.` TO errors.
    ENDLOOP.

    IF failed-child IS NOT INITIAL.
      LOOP AT failed-child ASSIGNING FIELD-SYMBOL(<err_ch>).
        APPEND `Error for child instance with key_field = ` &&
        <err_ch>-key_field && ` and key_ch = ` &&
        <err_ch>-key_ch && `: Fail cause `
        && <err_ch>-%fail-cause && `.` TO errors.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.


  METHOD extract_from_reported.
    CLEAR messages.

    LOOP AT reported-root ASSIGNING FIELD-SYMBOL(<rep>).
      IF <rep>-%global = if_abap_behv=>mk-on.
        APPEND <rep>-%msg->m_severity &&
                <rep>-%msg->if_t100_dyn_msg~msgv1 TO messages.
      ELSE.
        APPEND `Message for instance with ` &&
               COND #( WHEN <rep>-%cid IS NOT INITIAL
                       THEN `%cid = ` && <rep>-%cid
                       ELSE `key = ` && <rep>-key_field ) &&
               `: ` &&  <rep>-%msg->m_severity && ` ` &&
               <rep>-%msg->if_t100_dyn_msg~msgv1 TO messages.

      ENDIF.
    ENDLOOP.

    IF reported-child IS NOT INITIAL.
      LOOP AT reported-child ASSIGNING FIELD-SYMBOL(<rep_ch>).
        APPEND `Message for child instance with key_field = ` &&
        <rep_ch>-key_field && ` and key_ch = `
        && <rep_ch>-key_ch && `: ` && <rep_ch>-%msg->m_severity &&
        ` ` && <rep_ch>-%msg->if_t100_dyn_msg~msgv1 TO messages.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.


  METHOD fill_db_tab.
    MODIFY zdemo_abap_rapt1 FROM TABLE @( VALUE #(
          ( key_field = 4
             field1   = 'ggg'
             field2   = 'hhh'
             field3   = 40
             field4   = 41 ) ) ).
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: RAP BO Operations Using a Managed RAP BO\n\n| ).

**********************************************************************
*
* Create operation
*
**********************************************************************

    out->write( |1) Create operation\n\n| ).

    "Adding an entry to the database table to provoke an error for the
    "EML create request.
    fill_db_tab( ).

**********************************************************************
* Notes:
* - field4 is purposely not included in the FIELDS list
* - Effect:
*   - %control value for field4 is set to if_abap_behv=>mk-off
*   - Although the derived type (created inline here) includes a
*     value assignment for field4 in an instance, the field value is
*     not saved. The initial value is used.
* - The instance with key_field = 4 will not be saved since an entry
*   already exists in the database table with the same key.
* - Response parameters are specified to receive information.
* - A COMMIT ENTITIES statement triggers the saving of the instances.
* - The example BDEF includes the definition of a determination on
*   save for create operations. In this case, the determination
*   adds some text to the value in field2.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
      ENTITY root
      CREATE FIELDS ( key_field field1 field2 field3 )
        WITH VALUE #( ( %cid = 'cid1'
                        key_field = 1
                        field1    = 'aaa'
                        field2    = 'bbb'
                        field3    = 10
                        field4    = 11 ) "Value not considered
                      ( %cid      = 'cid2'
                        key_field = 2
                        field1    = 'ccc'
                        field2    = 'ddd'
                        field3    = 20 )
                      ( %cid      = 'cid3'
                        key_field = 3
                        field1    = 'eee'
                        field2    = 'fff'
                        field3    = 30 )
                      ( %cid      = 'cid4' "Instance to fail
                        key_field = 4
                        field1    = 'error'
                        field2    = 'error'
                        field3    = 99 ) )
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @DATA(tab_root).

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
      out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Update operations
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Update operation` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create and an update request. The
*   create request is included to have a %cid to refer to for demo
*   purposes. This instance has not yet been persisted.
* - The EML statement for the create operation includes the ABAP
*   FROM ... (instead of FIELDS ( ... ) WITH ...) for demo purposes.
*   Here, the %control values must be set explicitly.
* - The update request purposely excludes field2 so as not to update
*   the value of this particular field.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
        ENTITY root
        CREATE FROM VALUE #(
            %control-key_field = if_abap_behv=>mk-on
            %control-field1 = if_abap_behv=>mk-on
            %control-field2 = if_abap_behv=>mk-on
            %control-field3 = if_abap_behv=>mk-on
            %control-field4 = if_abap_behv=>mk-on
          ( %cid = 'cid5'
            key_field = 5
            field1    = 'iii'
            field2    = 'jjj'
            field3    = 50
            field4    = 51 ) )
        UPDATE FIELDS ( field1 field3 field4 )
          WITH VALUE #(
          "Update via cid_ref
          ( %cid_ref = 'cid5'
            field1   = 'up_kkk'
            field2   = 'up_lll' "Value not considered
            field3   = 500
            field4   = 501 )
          "Updates via key
          ( key_field = 1
            field1    = 'up_mmm'
            field3    = 100
            field4    = 101 )
          ( key_field = 2
            field1    = 'up_ooo'
            field3    = 200
            field4    = 201 )
          ( key_field = 99   "Instance to fail
            field1    = 'error'
            field3    = 99
            field4    = 99 ) )
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
      out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Delete operation
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Delete operation` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create and an delete request. The
*   create request is included to have a %cid to refer to for demo
*   purposes. This instance has not yet been persisted.
* - EML statements for delete operations can only be used with the
*   ABAP word FROM ....
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid      = 'cid_del'
            key_field = 6
            field1    = 'mmm'
            field2    = 'nnn'
            field3    = 60
            field4    = 61 ) )
        DELETE FROM VALUE #(
          "Deletion via %cid_ref
          ( %cid_ref = 'cid_del' )
          "Deletions via key
          ( key_field = 4 )
          ( key_field = 5 )
          "Instance to fail
          ( key_field = 100 ) )  "Key not available
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
      out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Action multiply_by_2
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Action execution: mutliply_by_2` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create request and a request to execute
*   an action. The create request is included to have a %cid to refer
*   to for demo purposes. This instance has not yet been persisted.
* - EML statements for executing actions can only be used with the
*   ABAP word FROM ....
* - As the name implies, the action multiplies field
*   values (field3 and field4) by 2 for requested instances.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid = 'cid_x2'
            key_field = 7
            field1    = 'ooo'
            field2    = 'ppp'
            field3    = 70
            field4    = 71 ) )
        EXECUTE multiply_by_2 FROM VALUE #(
          "Executing action via %cid_ref
          ( %cid_ref = 'cid_x2' )
          "Executing action via key
          ( key_field  =  1  )
          ( key_field  =  2  )
          ( key_field  =  1234 ) ) "Instance to fail
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
      out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Create-by-association operation (from root to child entity)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Create-by-association operation (from parent to child)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create and create-by-association
*   request, i. e. a "deep create". An instance is created for the
*   parent entity and, in the same request and based on this
*   instance, instances are created for the child entity, too.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
              WITH VALUE #(
              ( %cid      = 'cid_cba'
                key_field = 9
                field1    = 'qqq'
                field2    = 'rrr'
                field3    = 90
                field4    = 91 ) )
        CREATE BY \_child
        FIELDS ( key_ch field_ch1 field_ch2 ) WITH VALUE #(
          "CBA operation via %cid_ref
          ( %cid_ref = 'cid_cba'
            %target = VALUE #( ( %cid      = 'cid_ch1'
                                 key_ch    = 9
                                 field_ch1 = 'aaa_ch'
                                 field_ch2 = 99 )
                               ( %cid      = 'cid_ch2'
                                 key_ch    = 10
                                 field_ch1 = 'bbb_ch'
                                 field_ch2 =  100 ) ) )
          "CBA operation via root key
          ( key_field = 1
            %target = VALUE #( ( %cid      = 'cid_ch3'
                                 key_ch    = 1
                                 field_ch1 = 'ccc_ch'
                                 field_ch2 = 11 )
                               ( %cid      = 'cid_ch4'
                                 key_ch    = 2
                                 field_ch1 = 'ddd_ch'
                                 field_ch2 = 22 ) ) )
          ( key_field = 2
            %target = VALUE #( ( %cid      = 'cid_ch5'
                                 key_ch    = 3
                                 field_ch1 = 'ccc_ch'
                                 field_ch2 = 33 )
                               ( %cid      = 'cid_ch6'
                                 key_ch    = 4
                                 field_ch1 = 'ddd_ch'
                                 field_ch2 = 44 ) ) )
          "Instance to fail
          ( key_field = 123
            %target = VALUE #( ( %cid      = 'cid_ch7'
                                 key_ch    = 1
                                 field_ch1 = 'error'
                                 field_ch2 = 2 )
                               ( %cid      = 'cid_ch8'
                                 key_ch    = 2
                                 field_ch1 = 'error'
                                 field_ch2 = 3 ) ) )
                                 )
          MAPPED mapped
          FAILED failed
          REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    SELECT FROM zdemo_abap_rapt2
      FIELDS key_field, key_ch, field_ch1, field_ch2
      ORDER BY key_field, key_ch
      INTO TABLE @DATA(tab_child).

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).
    out->write( data = tab_child name = `tab_child` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root and child entity)` ).
      out->write( |\n| ).
      out->write( data = mapped name = `mapped` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Validation val
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Validation val` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create request. The validation's
*   handler method is implementation in a way that the saving of
*   instances is disabled if a field value is not allowed. In this
*   example, the value of the integer in field3 shall not exceed 1000.
*   Here, the third instance will fail for the validation.
*   Consequently, all instances of this request are not saved to the
*   database. Either all is ok and will be saved or nothing.
* - Note that the response information for the validation is only
*   available in the response parameters of the COMMIT ENTITIES
*   statement. Here, the BDEF derived type is
*   ... TYPE RESPONSE FOR ... LATE ....
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid = 'cid_val1'
            key_field = 123
            field1    = 'sss'
            field2    = 'ttt'
            field3    = 1
            field4    = 2 )
          ( %cid = 'cid_val2'
            key_field = 456
            field1    = 'uuu'
            field2    = 'vvv'
            field3    = 3
            field4    = 4 )
          ( %cid = 'cid_val3'
            key_field = 789
            field1    = 'www'
            field2    = 'xxx'
            field3    = 1001
            field4    = 5 ) )
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES RESPONSES
      FAILED DATA(failed_late)
      REPORTED DATA(reported_late).

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root and child entity)` ).
      out->write( |\n| ).
      out->write( data = mapped name = `mapped` ).
      out->write( |\n| ).
    ENDIF.

    IF failed_late IS NOT INITIAL.
      out->write( `Entries in FAILED LATE response parameter` ).
      out->write( |\n| ).
      out->write( data = failed_late name = `failed_late` ).
      out->write( |\n| ).
    ENDIF.

    IF reported_late IS NOT INITIAL.
      out->write( `Entries in REPORTED LATE response parameter` ).
      out->write( |\n| ).
      out->write( data = reported_late name = `reported_late` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Read operation (root entity)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Read operation (root entity)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read request. The EML statement uses
*   the ABAP words ALL FIELDS WITH. In this case, as the name implies,
*   all field values are retrieved. The %control values for all fields
*   are set to if_abap_behv=>mk-on.
* - When using the ABAP words FIELDS ( ... ) WITH and specifying the
*   concrete fields to be read, only for those fields %control is
*   set accordingly.
* - Filling the parameter for RESULT is mandatory.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_m
        ENTITY root
        ALL FIELDS WITH VALUE #(
          ( key_field = 1 )
          ( key_field = 2 )
          ( key_field = 7 )
          ( key_field = 5 ) ) "Instance to fail
        RESULT DATA(result)
        FAILED failed
        REPORTED reported.

    "Displaying the read result
    out->write( data = result name = `result` ).
    out->write( |\n| ).

    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.
    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

*********************************************************************
*
* Read operation (child entity)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Read operation (child entity)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read request. The read operation is
*   executed on the child entity directly by specifying the alias, as
*   it is defined in the BDEF, following the ABAP word ENTITY.
* - All field values are read using the addition ALL FIELDS WITH.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_m
          ENTITY child
          ALL FIELDS WITH VALUE #(
            ( key_field = 1 key_ch = 1 )
            ( key_field = 2 key_ch = 4 )
            "Instances to fail
            ( key_field = 9 )
            ( key_field = 9 key_ch = 11 ) )
          RESULT DATA(read_ch)
          FAILED failed
          REPORTED reported.

    "Displaying read result
    out->write( data = read_ch name = `read_ch` ).
    out->write( |\n| ).


    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.
    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Read-by-association operation (from parent to child)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Read-by-association operation (from parent to child)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read-by-association request from the
*   parent to the child.
* - All field values are read using the addition ALL FIELDS WITH.
* - Specifying the parameter for RESULT is mandatory.
* - Additionally, the optional association links are retrieved.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_m
          ENTITY root
          BY \_child
          ALL FIELDS WITH VALUE #(
            ( key_field = 2 )
            ( key_field = 9 )
            ( key_field = 999 ) ) "Instance to fail
          RESULT DATA(rba_result)
          LINK DATA(association_links)
          FAILED failed
          REPORTED reported.

    "Displaying read result and association links
    out->write( data = rba_result name = `rba_result` ).
    out->write( |\n| ).
    out->write( data = association_links name = `association_links` ).
    out->write( |\n| ).

    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.
    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Read-by-association operation (from child to parent)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Read-by-association operation (from child to parent)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read-by-association request from the
*   child to the parent.
* - All field values are read using the addition ALL FIELDS WITH.
* - Specifying the parameter for RESULT is mandatory.
* - Additionally, the optional association links are retrieved.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_m
      ENTITY child
      BY \_parent ALL FIELDS WITH VALUE #(
         ( key_field = 1 key_ch = 1 )
         ( key_field = 2 key_ch = 4 )
         "Instances to fail
         ( key_field = 1 key_ch = 3 )
         ( key_field = 543 key_ch = 1 ) )
       RESULT DATA(rba_parent)
       LINK DATA(association_links_parent)
       FAILED failed
       REPORTED reported.

    "Displaying read result and association links
    out->write( data = rba_parent name = `rba_parent` ).
    out->write( |\n| ).
    out->write( data = association_links_parent name = `association_links_parent` ).
    out->write( |\n| ).

    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.
    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Excursion: Read and read-by-association operation using a dynamic
* EML statement
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Excursion: Read and read-by-association ` &&
                     `operations using dynamic EML` ) ).
    DATA:
      op_tab          TYPE abp_behv_retrievals_tab,
      read_dyn        TYPE TABLE FOR READ IMPORT zdemo_abap_rap_ro_m,
      read_dyn_result TYPE TABLE FOR READ RESULT zdemo_abap_rap_ro_m,
      rba_dyn         TYPE TABLE FOR READ IMPORT
                        zdemo_abap_rap_ro_m\_child,
      rba_dyn_result  TYPE TABLE FOR READ RESULT
                        zdemo_abap_rap_ro_m\_child,
      rba_dyn_link    TYPE TABLE FOR READ LINK zdemo_abap_rap_ro_m\_child.

    read_dyn = VALUE #(
      ( %key-key_field = 1
        %control = VALUE #(
          field1 = if_abap_behv=>mk-on
          field2 = if_abap_behv=>mk-on
          field3 = if_abap_behv=>mk-on
          field4 = if_abap_behv=>mk-on ) )
      ( %key-key_field = 2
        %control = VALUE #(
          field1 = if_abap_behv=>mk-on
          field2 = if_abap_behv=>mk-on
          field3 = if_abap_behv=>mk-on
          field4 = if_abap_behv=>mk-on ) ) ).

    rba_dyn = VALUE #(
     ( %key-key_field = 1
       %control = VALUE #(
          key_ch    = if_abap_behv=>mk-on
          field_ch1 = if_abap_behv=>mk-on
          field_ch2 = if_abap_behv=>mk-on ) )
      ( %key-key_field = 2
        %control = VALUE #(
          key_ch    = if_abap_behv=>mk-on
          field_ch1 = if_abap_behv=>mk-on
          field_ch2 = if_abap_behv=>mk-on ) ) ).

    op_tab = VALUE #(
       ( op = if_abap_behv=>op-r-read
         entity_name = 'ZDEMO_ABAP_RAP_RO_M'
         instances   = REF #( read_dyn )
         results     = REF #( read_dyn_result ) )
       ( op = if_abap_behv=>op-r-read_ba
         entity_name = 'ZDEMO_ABAP_RAP_RO_M'
         sub_name    = '_CHILD'
         full        = abap_true
         instances   = REF #( rba_dyn )
         results     = REF #( rba_dyn_result )
         links       = REF #( rba_dyn_link ) ) ).

    READ ENTITIES OPERATIONS op_tab.

    out->write( `Read result (root)` ).
    out->write( |\n| ).
    out->write( data = read_dyn_result name = `read_dyn_result` ).
    out->write( |\n| ).
    out->write( `Read result (read-by-association)` ).
    out->write( |\n| ).
    out->write( data = rba_dyn_result name = `rba_dyn_result` ).
    out->write( |\n| ).
    out->write( `Links` ).
    out->write( |\n| ).
    out->write( data = rba_dyn_link name = `rba_dyn_link` ).
  ENDMETHOD.

  METHOD initialize_dbtabs.
    DELETE FROM zdemo_abap_rapt1.
    DELETE FROM zdemo_abap_rapt2.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_ext_num_u DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS:
      class_constructor.

protected section.
  PRIVATE SECTION.
    CLASS-DATA:
      failed   TYPE RESPONSE FOR FAILED zdemo_abap_rap_ro_u,
      reported TYPE RESPONSE FOR REPORTED zdemo_abap_rap_ro_u,
      mapped   TYPE RESPONSE FOR MAPPED zdemo_abap_rap_ro_u,
      op       TYPE string.
    CLASS-METHODS:
      initialize_dbtabs,
      "If there are entries in the response parameters following EML
      "requests, they should be processed for displaying purposes.
      extract_from_reported RETURNING VALUE(messages) TYPE string_table,
      extract_from_failed RETURNING VALUE(errors) TYPE string_table,
      fill_db_tab.

ENDCLASS.""",
    r"""CLASS ZCL_DEMO_ABAP_RAP_EXT_NUM_U IMPLEMENTATION.


  METHOD class_constructor.
    initialize_dbtabs( ).
  ENDMETHOD.


  METHOD extract_from_failed.
    CLEAR errors.

    LOOP AT failed-root ASSIGNING FIELD-SYMBOL(<err>).
      CASE if_abap_behv=>mk-on.
        WHEN <err>-%op-%create.
          op = `create operation`.
        WHEN <err>-%op-%update.
          op = `update operation`.
        WHEN <err>-%op-%delete.
          op = `delete operation`.
        WHEN <err>-%op-%assoc-_child.
          op = `operation involving the child entity`.
        WHEN <err>-%op-%action-multiply_by_2.
          op = `executing action multiply_by_2`.
        WHEN <err>-%op-%action-multiply_by_3.
          op = `executing action multiply_by_3`.
        WHEN <err>-%op-%action-set_z.
          op = `executing action set_z`.
        WHEN OTHERS. op = `operation`.
      ENDCASE.

      APPEND `Error for instance with ` &&
           COND #( WHEN <err>-%cid IS NOT INITIAL THEN `%cid = `
                   && <err>-%cid
                   ELSE `key = ` && <err>-key_field ) &&
           `: Fail cause ` &&  <err>-%fail-cause && ` for ` &&  op
           && `.` TO errors.
    ENDLOOP.

    IF failed-child IS NOT INITIAL.
      LOOP AT failed-child ASSIGNING FIELD-SYMBOL(<err_ch>).

        APPEND `Error for child instance with ` &&
             COND #( WHEN <err_ch>-%cid IS NOT INITIAL THEN `%cid = `
                     && <err_ch>-%cid
                     ELSE `key_field = ` && <err_ch>-key_field &&
                      ` and key_ch = ` && <err_ch>-key_ch ) &&
             `: Fail cause ` &&  <err_ch>-%fail-cause && ` for operation.`
             TO errors.

      ENDLOOP.
    ENDIF.
  ENDMETHOD.


  METHOD extract_from_reported.
    CLEAR messages.

    LOOP AT reported-root ASSIGNING FIELD-SYMBOL(<rep>).
      IF <rep>-%global = if_abap_behv=>mk-on.
        APPEND <rep>-%msg->m_severity && ` ` &&
                <rep>-%msg->if_t100_dyn_msg~msgv1 TO messages.
      ELSE.
        APPEND `Message for instance with ` &&
               COND #( WHEN <rep>-%cid IS NOT INITIAL
                       THEN `%cid = ` && <rep>-%cid
                       ELSE `key = ` && <rep>-key_field ) &&
               `: ` &&  <rep>-%msg->m_severity && ` ` &&
               <rep>-%msg->if_t100_dyn_msg~msgv1 TO messages.

      ENDIF.
    ENDLOOP.

    IF reported-child IS NOT INITIAL.
      LOOP AT reported-child ASSIGNING FIELD-SYMBOL(<rep_ch>).
        APPEND `Message for child instance with key_field = ` &&
        <rep_ch>-key_field && ` and key_ch = `
        && <rep_ch>-key_ch && `: ` && <rep_ch>-%msg->m_severity &&
        ` ` && <rep_ch>-%msg->if_t100_dyn_msg~msgv1 TO messages.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.


  METHOD fill_db_tab.

    MODIFY zdemo_abap_rapt1 FROM TABLE @( VALUE #(
          ( key_field = 4
            field1    = 'fff'
            field2    = 'ggg'
            field3    = 40
            field4    = 41 ) ) ).

  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: RAP BO Operations Using an Unmanaged RAP BO (External Numbering)\n\n| ).

**********************************************************************
*
* Create operation
*
**********************************************************************

    out->write( |1) Create Operation\n\n| ).

    "Adding an entry to the database table to provoke an error for the
    "EML create request.
    fill_db_tab( ).

**********************************************************************
* Notes:
* - field4 is purposely not included in the FIELDS list
* - Effect:
*   - %control value for field4 is set to if_abap_behv=>mk-off
*   - Although the derived type (created inline here) includes a
*     value assignment for field4 in an instance, the field value is
*     not saved. The initial value is used.
* - The instance with key_field = 4 will not be saved since an entry
*   already exists in the database table with the same key.
* - Response parameters are specified to receive information.
* - A COMMIT ENTITIES statement triggers the saving of the instances.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
      ENTITY root
      CREATE FIELDS ( key_field field1 field2 field3 )
        WITH VALUE #( ( %cid = 'cid1'
                        key_field = 1
                        field1    = 'aaa'
                        field2    = 'bbb'
                        field3    = 10
                        field4    = 11 ) "Value not respected
                      ( %cid      = 'cid2'
                        key_field = 2
                        field1    = 'ccc'
                        field2    = 'ddd'
                        field3    = 20 )
                      ( %cid      = 'cid3'
                        key_field = 3
                        field1    = 'X'
                        field2    = 'eee'
                        field3    = 30 )
                      ( %cid      = 'cid4' "Instance to fail
                        key_field = 4
                        field1    = 'error'
                        field2    = 'error'
                        field3    = 99 ) )
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @DATA(tab_root).

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
                         out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Update operations
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Update Operation` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create and an update request. The
*   create request is included to have a %cid to refer to for demo
*   purposes. This instance has not yet been persisted.
* - The EML statement for the create operation includes the ABAP
*   FROM ... (instead of FIELDS ( ... ) WITH ...) for demo purposes.
*   Here, the %control values must be set explicitly.
* - The update request purposely excludes field2 so as not to update
*   the value of this particular field.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        CREATE FROM VALUE #(
            %control-key_field = if_abap_behv=>mk-on
            %control-field1 = if_abap_behv=>mk-on
            %control-field2 = if_abap_behv=>mk-on
            %control-field3 = if_abap_behv=>mk-on
            %control-field4 = if_abap_behv=>mk-on
          ( %cid = 'cid5'
            key_field = 5
            field1    = 'hhh'
            field2    = 'iii'
            field3    = 50
            field4    = 51 ) )
        UPDATE FIELDS ( field1 field3 field4 )
          WITH VALUE #(
          "Update via cid_ref
          ( %cid_ref = 'cid5'
            field1   = 'up_jjj'
            field2   = 'up_kkk' "Value not respected
            field3   = 500
            field4   = 501 )
          "Updates via key
          ( key_field = 1
            field1    = 'up_lll'
            field3    = 100
            field4    = 101 )
          ( key_field = 2
            field1    = 'up_mmm'
            field3    = 200
            field4    = 201 )
          ( key_field = 99       "Instance to fail
            field1    = 'error'
            field3    = 99
            field4    = 99 ) )
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
                         out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Delete operation
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Delete Operation` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create and an delete request. The
*   create request is included to have a %cid to refer to for demo
*   purposes. This instance has not yet been persisted.
* - EML statements for delete operations can only be used with the
*   ABAP word FROM ....
* - Note: Instance authorization is defined in the BDEF. In this
*   example, the corresponding handler method is implemented in a way
*   that disables the deletion of instances if a field has a certain
*   value. If field1 has the value 'X', a deletion is disabled.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid      = 'cid_del'
            key_field = 6
            field1    = 'a'
            field2    = 'b'
            field3    = 60
            field4    = 61 ) )
        DELETE FROM VALUE #(
          "Deletion via %cid_ref
          ( %cid_ref = 'cid_del' )
          "Deletions via key
          ( key_field = 4 )
          ( key_field = 5 )
          "Instances to fail
          ( key_field = 3 )      "Deletion disabled
          ( key_field = 100 ) )  "Key not available
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
                         out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Action multiply_by_2
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Executing Action mutliply_by_2` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create request and a request to execute
*   an action. The create request is included to have a %cid to refer
*   to for demo purposes. This instance has not yet been persisted.
* - EML statements for executing actions can only be used with the
*   ABAP word FROM ....
* - As the name implies, the action multiplies field
*   values (field3 and field4) by 2 for requested instances.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid = 'cid_x2'
            key_field = 7
            field1    = 'nnn'
            field2    = 'ooo'
            field3    = 70
            field4    = 71 ) )
        EXECUTE multiply_by_2 FROM VALUE #(
          "Executing action via %cid_ref
          ( %cid_ref = 'cid_x2' )
          "Executing action via key
          ( key_field  =  1  )
          ( key_field  =  2  )
          ( key_field  =  1234 ) ) "Instance to fail
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
                         out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Action multiply_by_3
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Executing Action mutliply_by_3` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create request and a request to execute
*   an action. The create request is included to have a %cid to refer
*   to for demo purposes. This instance has not yet been persisted.
* - As the name implies, the action multiplies field
*   values (field3 and field4) by 3 for requested instances.
* - Note: In the BDEF of this example, this action is defined with
*   instance feature control. Here, the action execution is disabled
*   if both integer values are 0.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid = 'cid_x3'
            key_field = 8
            field1    = 'ppp'
            field2    = 'qqq'
            field3    = 80
            field4    = 81 ) )
        EXECUTE multiply_by_3 FROM VALUE #(
          "Executing action via %cid_ref
          ( %cid_ref = 'cid_x3' )
          "Executing action via key
          ( key_field =  1  )
          ( key_field =  2  )
          "Instances to fail
          ( key_field =  3 )      "Action execution disabled
          ( key_field =  1234 ) ) "Key not available
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
                         out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Action set_z
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Executing ACTION set_z` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create request and a request to execute
*   an action. The create request is included to have a %cid to refer
*   to for demo purposes. This instance has not yet been persisted.
* - As the name implies, the action sets the value 'Z' for a
*   particular field (field2) for requested instances.
* - Note: In the BDEF of this example, this action is defined with
*   global feature control. Here, the action execution is disabled
*   based on a certain time frame in which you run this example. You
*   might want to change the time frame values in the ABP to check the
*   effect.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
          WITH VALUE #(
          ( %cid      = 'cid_setz'
            key_field = 9
            field1    = 'rrr'
            field2    = 'sss'
            field3    = 90
            field4    = 91 ) )
        EXECUTE set_z FROM VALUE #(
          "Executing action via %cid_ref
          ( %cid_ref = 'cid_setz' )
          "Executing action via key
          ( key_field =  2 ) )
        MAPPED mapped
        FAILED failed
        REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped-root IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root entity)` ).
                         out->write( |\n| ).
      out->write( data = mapped-root name = `mapped-root` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Create-by-Association Operation (from Root to Child Entity)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Create-by-Association Operation (from Root to Child Entity)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a create and create-by-association
*   request, i. e. a "deep create". An instance is created for the
*   root entity and, in the same request and based on this root
*   instance, instances are created for the child entity, too.
**********************************************************************

    MODIFY ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        CREATE FIELDS ( key_field field1 field2 field3 field4 )
              WITH VALUE #(
              ( %cid      = 'cid_cba'
                key_field = 10
                field1    = 'ttt'
                field2    = 'uuu'
                field3    = 100
                field4    = 101 ) )
        CREATE BY \_child
        FIELDS ( key_ch field_ch1 field_ch2 ) WITH VALUE #(
          "CBA operation via %cid_ref
          ( %cid_ref = 'cid_cba'
            %target = VALUE #( ( %cid      = 'cid_ch1'
                                 key_ch    = 11
                                 field_ch1 = 'aaa_ch'
                                 field_ch2 = 110 )
                               ( %cid      = 'cid_ch2'
                                 key_ch    = 12
                                 field_ch1 = 'bbb_ch'
                                 field_ch2 =  120 ) ) )
          "CBA operation via root key
          ( key_field = 1
            %target = VALUE #( ( %cid      = 'cid_ch3'
                                 key_ch    = 1
                                 field_ch1 = 'ccc_ch'
                                 field_ch2 = 11 )
                               ( %cid      = 'cid_ch4'
                                 key_ch    = 2
                                 field_ch1 = 'ddd_ch'
                                 field_ch2 = 22 ) ) )
          ( key_field = 2
            %target = VALUE #( ( %cid      = 'cid_ch5'
                                 key_ch    = 3
                                 field_ch1 = 'ccc_ch'
                                 field_ch2 = 33 )
                               ( %cid      = 'cid_ch6'
                                 key_ch    = 4
                                 field_ch1 = 'ddd_ch'
                                 field_ch2 = 44 ) ) )
          "Instance to fail
          ( key_field = 123
            %target = VALUE #( ( %cid      = 'cid_ch7'
                                 key_ch    = 1
                                 field_ch1 = 'error'
                                 field_ch2 = 2 )
                               ( %cid      = 'cid_ch8'
                                 key_ch    = 2
                                 field_ch1 = 'error'
                                 field_ch2 = 3 ) ) ) )
          MAPPED mapped
          FAILED failed
          REPORTED reported.

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Retrieving and displaying database content
    SELECT FROM zdemo_abap_rapt1
      FIELDS key_field, field1, field2, field3, field4
      ORDER BY key_field
      INTO TABLE @tab_root.

    SELECT FROM zdemo_abap_rapt2
      FIELDS key_field, key_ch, field_ch1, field_ch2
      ORDER BY key_field, key_ch
      INTO TABLE @DATA(tab_child).

    out->write( data = tab_root name = `tab_root` ).
    out->write( |\n| ).
    out->write( data = tab_child name = `tab_child` ).
    out->write( |\n| ).

    "Displaying response information
    IF mapped IS NOT INITIAL.
      out->write( `Entries in MAPPED response parameter ` &&
                         `(root and child entity)` ).
out->write( |\n| ).
      out->write( data = mapped name = `mapped` ).
      out->write( |\n| ).
    ENDIF.

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Read operation
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Read Operation (Root Entity)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read request. The EML statement uses
*   the ABAP words ALL FIELDS WITH. In this case, as the name implies,
*   all field values are retrieved. The %control values for all fields
*   are set to if_abap_behv=>mk-on.
* - When using the ABAP words FIELDS ( ... ) WITH and specifying the
*   concrete fields to be read, only for those fields %control is
*   set accordingly.
* - Filling the parameter for RESULT is mandatory.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_u
        ENTITY root
        ALL FIELDS WITH VALUE #(
          ( key_field = 1 )
          ( key_field = 2 )
          ( key_field = 5 ) ) "Instance to fail
        RESULT DATA(result)
        FAILED failed
        REPORTED reported.

    "Displaying the read result and response information
    out->write( data = result name = `result` ).
    out->write( |\n| ).

    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
      out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

*********************************************************************
*
* Read operation (child entity)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Read Operation (Child Entity)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read request. The read operation is
*   executed on the child entity directly by specifying the alias, as
*   it is defined in the BDEF, following the ABAP word ENTITY.
* - All field values are read using the addition ALL FIELDS WITH.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_u
          ENTITY child
          ALL FIELDS WITH VALUE #(
            ( key_field = 1 key_ch = 1 )
            ( key_field = 2 key_ch = 4 )
            "Instances to fail
            ( key_field = 9 )
            ( key_field = 9 key_ch = 11 ) )
          RESULT DATA(read_ch)
          FAILED failed
          REPORTED reported.

    "Displaying read result
    out->write( data = read_ch name = `read_ch` ).

    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Read-by-association operation (from parent to child)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Read-by-Association Operation (from Parent to Child)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read-by-association request from the
*   parent to the child entity.
* - All field values are read using the addition ALL FIELDS WITH.
* - Specifying the parameter for RESULT is mandatory.
* - Additionally, the optional association links are retrieved.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_u
          ENTITY root
          BY \_child
          ALL FIELDS WITH VALUE #(
            ( key_field = 2 )
            ( key_field = 10 )
            ( key_field = 111 ) ) "Instance to fail
          RESULT DATA(rba_result)
          LINK DATA(association_links)
          FAILED failed
          REPORTED reported.

    "Displaying read result and association links
    out->write( data = rba_result name = `rba_result` ).
    out->write( |\n| ).
    out->write( data = association_links name = `association_links` ).
    out->write( |\n| ).

    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Read-by-association operation (from child to parent)
*
**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Read-by-Association Operation (from Child to Parent)` ) ).

**********************************************************************
* Notes:
* - The EML request includes a read-by-association request from the
*   child to the parent.
* - All field values are read using the addition ALL FIELDS WITH.
* - Specifying the parameter for RESULT is mandatory.
* - Additionally, the optional association links are retrieved.
**********************************************************************

    READ ENTITIES OF zdemo_abap_rap_ro_u
      ENTITY child
      BY \_parent ALL FIELDS WITH VALUE #(
         ( key_field = 1 key_ch = 1 )
         ( key_field = 2 key_ch = 4 )
         "Instances to fail
         ( key_field = 1 key_ch = 3 )
         ( key_field = 543 key_ch = 1 ) )
       RESULT DATA(rba_parent)
       LINK DATA(association_links_parent)
       FAILED failed
       REPORTED reported.

    "Displaying read result and association links
    out->write( data = rba_parent name = `rba_parent` ).
    out->write( |\n| ).
    out->write( data = association_links_parent name = `association_links_parent` ).
    out->write( |\n| ).

    "Displaying response information
    IF failed IS NOT INITIAL.
      out->write( `Entries in FAILED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_failed( ) name = `extract_from_failed( )` ).
      out->write( |\n| ).
    ENDIF.

    IF reported IS NOT INITIAL.
      out->write( `Entries in REPORTED response parameter` ).
out->write( |\n| ).
      out->write( data = extract_from_reported( ) name = `extract_from_reported( )` ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************
*
* Excursion: Read and read-by-association operation using dynamic
* EML statements
*
* Note:
* If the parameter for FULL is not flagged, only the association
* links are returned. The parameter for RESULT will be empty.
**********************************************************************

out->write( zcl_demo_abap_aux=>heading( `12) Excursion: Read and read-by-association ` &&
                     `operations using dynamic EML`  ) ).
    DATA:
      op_tab          TYPE abp_behv_retrievals_tab,
      read_dyn        TYPE TABLE FOR READ IMPORT zdemo_abap_rap_ro_u,
      read_dyn_result TYPE TABLE FOR READ RESULT zdemo_abap_rap_ro_u,
      rba_dyn         TYPE TABLE FOR READ IMPORT
                        zdemo_abap_rap_ro_u\_child,
      rba_dyn_result  TYPE TABLE FOR READ RESULT
                        zdemo_abap_rap_ro_u\_child,
      rba_dyn_link    TYPE TABLE FOR READ LINK zdemo_abap_rap_ro_u\_child.

    read_dyn = VALUE #(
      ( %key-key_field = 1
        %control = VALUE #(
          field1 = if_abap_behv=>mk-on
          field2 = if_abap_behv=>mk-on
          field3 = if_abap_behv=>mk-on
          field4 = if_abap_behv=>mk-on ) )
      ( %key-key_field = 2
        %control = VALUE #(
          field1 = if_abap_behv=>mk-on
          field2 = if_abap_behv=>mk-on
          field3 = if_abap_behv=>mk-on
          field4 = if_abap_behv=>mk-on ) ) ).

    rba_dyn = VALUE #(
     ( %key-key_field = 1
       %control = VALUE #(
          key_ch    = if_abap_behv=>mk-on
          field_ch1 = if_abap_behv=>mk-on
          field_ch2 = if_abap_behv=>mk-on ) )
      ( %key-key_field = 2
        %control = VALUE #(
          key_ch    = if_abap_behv=>mk-on
          field_ch1 = if_abap_behv=>mk-on
          field_ch2 = if_abap_behv=>mk-on ) ) ).

    out->write( `Result if FULL parameter is ` &&
                  `not flagged for RBA` ).
out->write( |\n| ).

    op_tab = VALUE #(
       ( op = if_abap_behv=>op-r-read
         entity_name = 'ZDEMO_ABAP_RAP_RO_U'
         instances   = REF #( read_dyn )
         results     = REF #( read_dyn_result ) )
       ( op = if_abap_behv=>op-r-read_ba
         entity_name = 'ZDEMO_ABAP_RAP_RO_U'
         sub_name    = '_CHILD'
         full        = abap_false
         instances   = REF #( rba_dyn )
         results     = REF #( rba_dyn_result )
         links       = REF #( rba_dyn_link ) ) ).

    READ ENTITIES OPERATIONS op_tab.

    out->write( data = read_dyn_result name = `read_dyn_result` ).
    out->write( |\n| ).
    out->write( data = rba_dyn_result name = `rba_dyn_result` ).
    out->write( |\n| ).
    out->write( data = rba_dyn_link name = `rba_dyn_link` ).
    out->write( |\n| ).
    out->write( `Result if FULL parameter is ` &&
                  `flagged for RBA` ).
out->write( |\n| ).

    op_tab = VALUE #(
           ( op = if_abap_behv=>op-r-read
             entity_name = 'ZDEMO_ABAP_RAP_RO_U'
             instances   = REF #( read_dyn )
             results     = REF #( read_dyn_result ) )
           ( op = if_abap_behv=>op-r-read_ba
             entity_name = 'ZDEMO_ABAP_RAP_RO_U'
             sub_name    = '_CHILD'
             full        = abap_true
             instances   = REF #( rba_dyn )
             results     = REF #( rba_dyn_result )
             links       = REF #( rba_dyn_link ) ) ).

    READ ENTITIES OPERATIONS op_tab.

    out->write( data = read_dyn_result name = `read_dyn_result` ).
    out->write( |\n| ).
    out->write( data = rba_dyn_result name = `rba_dyn_result` ).
    out->write( |\n| ).
    out->write( data = rba_dyn_link name = `rba_dyn_link` ).
    out->write( |\n| ).
  ENDMETHOD.


  METHOD initialize_dbtabs.
    DELETE FROM zdemo_abap_rapt1.
    DELETE FROM zdemo_abap_rapt2.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_m_as DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS:
      class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_rap_m_as IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.
    out->write( |ABAP Cheat Sheet Example: Local Consumption of RAP Business Events\n\n| ).
    "RAP create operation that creates multiple calculations
    "Note the AUTO FILL CID addition with which the required %cid values
    "for RAP BO instances are created automatically. Since the scenario is
    "managed internal numbering, the 'id' field is assigned an appropriate value
    "automatically by the RAP framework.
    MODIFY ENTITY zdemo_abap_rap_ro_m_as
      CREATE AUTO FILL CID
      FIELDS ( num1 arithm_op num2 )
      WITH VALUE #( ( num1 = 1
                      arithm_op = '+'
                      num2    = 2 )
                    ( num1 = 5
                      arithm_op = '-'
                      num2    = 30 )
                    ( num1 = 3
                      arithm_op = '*'
                      num2    = 3 )
                    ( num1 = 7
                      arithm_op = '/'
                      num2    = 5 )
                    ( num1 = 2
                      arithm_op = 'P'
                      num2    = 4 )
                    ( num1 = 10
                      arithm_op = 'P'
                      num2    = 1000000000 )
                    ( num1 = 2
                      arithm_op = '/'
                      num2    = 0 ) )
      MAPPED DATA(m_cr)
      FAILED DATA(f_cr)
      REPORTED DATA(r_cr).

    COMMIT ENTITIES.

    IF sy-subrc <> 0.
      out->write( `An issue occurred in the RAP save sequence.` ).
    ENDIF.

    "Getting and displaying persisted instances to show the effect of the
    "EML MODIFY statement
    SELECT id, num1, arithm_op, num2, calc_result, crea_date_time, lchg_date_time
     FROM zdemo_abap_tabca
     ORDER BY lchg_date_time
     INTO TABLE @DATA(dbtab_entries).

    out->write( `Database table entries after the create operation`
      )->write( dbtab_entries
      )->write( |\n| ).

**********************************************************************

    "RAP update operation
    "In the example, all RAP BO instances that were created above are
    "updated. Here, the second number is updated with a random
    "integer (from the value range 1 - 10). For this purpose, the
    "cl_abap_random_int class is used.
    "The reference to existing instances is made using entries in the
    "mapped reponse table from above (it contains all keys of the created
    "RAP BO instances).
    IF m_cr-root IS NOT INITIAL.
      MODIFY ENTITY zdemo_abap_rap_ro_m_as
        UPDATE FIELDS ( num2 )
        WITH VALUE #( FOR wa IN m_cr-root ( id   = wa-id
                                            num2 = cl_abap_random_int=>create(
                                                    seed = cl_abap_random=>seed( )
                                                    min  = 1
                                                    max  = 10 )->get_next( ) ) )
      FAILED DATA(f_upd)
      REPORTED DATA(r_upd).

      COMMIT ENTITIES.

      IF sy-subrc <> 0.
        out->write( `An issue occurred in the RAP save sequence.` ).
      ENDIF.

      "Getting and displaying persisted instances to show the effect of the
      "EML MODIFY statement
      SELECT id, num1, arithm_op, num2, calc_result, crea_date_time, lchg_date_time
       FROM zdemo_abap_tabca
       ORDER BY lchg_date_time
       INTO TABLE @dbtab_entries.

      out->write( `Database table entries after the update operation`
        )->write( dbtab_entries
        )->write( |\n| ).
    ENDIF.

**********************************************************************

    "RAP delete operation
    "As above, the reference to existing RAP BO instances is made
    "using entries in the mapped response table. In the example,
    "the first three instances created are deleted.
    IF lines( m_cr-root ) > 3.
      MODIFY ENTITY zdemo_abap_rap_ro_m_as
       DELETE FROM VALUE #( ( id = m_cr-root[ 1 ]-id )
                            ( id = m_cr-root[ 2 ]-id )
                            ( id = m_cr-root[ 3 ]-id ) )
       FAILED DATA(f_del)
       REPORTED DATA(r_del).

      COMMIT ENTITIES.

      IF sy-subrc <> 0.
        out->write( `An issue occurred in the RAP save sequence.` ).
      ENDIF.

      "Getting and displaying persisted instances to show the effect of the
      "EML MODIFY statement
      SELECT id, num1, arithm_op, num2, calc_result, crea_date_time, lchg_date_time
       FROM zdemo_abap_tabca
       ORDER BY lchg_date_time
       INTO TABLE @dbtab_entries.

      out->write( `Database table entries after the delete operation`
        )->write( dbtab_entries
        )->write( |\n| ).
    ENDIF.

**********************************************************************

    "Note:
    "- Due to the asynchronous call of the events, a WAIT statement
    "  is included to give the events some time in this self-contained example,
    "  i.e. so that all the database table entries that are created in the
    "  RAP event handler method can be retrieved and displayed.
    "- In the RAP event handler method implementation, note the cl_abap_tx=>save( ).
    "  method call. This explicit activation of the 'save' transactional phase
    "  is required because, when called, the methods are started in the
    "  'modify' transactional phase. In the modify phase, database modification
    "  statements are not allowed. If the save phase is not activated,
    "  a following database modification statement results in an error.

    "To explore the asynchronity of the event raising, you can comment out the
    "following WAIT statement.
    WAIT UP TO 2 SECONDS.
    DATA(tmstmp_after_wait) = cl_abap_tstmp=>utclong2tstmp( utclong_current( ) ).
    out->write( |Timestamp (e.g. for comparing with the timestamps of the events raised): { tmstmp_after_wait }| ).
    out->write( |\n| ).

    "The global class of the behavior pool contains a static attribute of type i.
    "The example is implemented as follows: When events are raised in the save_modified
    "method, this number is increased by 1 per event raised. The number represents
    "the expected events to be raised. It is used in the following example implementation.
    "As mentioned above, you can comment out the WAIT statement to potentially see
    "a different number here compared to the number of entries in the log table.
    out->write( |Number of expected events raised: { zbp_demo_abap_rap_ro_m_as=>num_raised_events }| ).
    out->write( |\n| ).

    "Getting and displaying database table entries that were inserted
    "in the event handler method implementations to demonstrate that
    "events have been triggered.
    SELECT calc_result, crea_date_time
     FROM zdemo_abap_draft
     ORDER BY crea_date_time
     INTO TABLE @DATA(evt_log_entries).

    out->write( |Entries in log table at this stage (after SELECT from database table): { lines( evt_log_entries ) }| ).
    out->write( |\n| ).

    DATA(flag) = abap_false.
    IF evt_log_entries IS INITIAL.
      out->write( `There are no entries in the log table.` &&
        ` Try and run the example again.` ).
      flag = abap_true.
    ELSEIF lines( evt_log_entries ) BETWEEN 1 AND zbp_demo_abap_rap_ro_m_as=>num_raised_events - 1.
      out->write( `Log database table entries created by the ` &&
          `raised events` )->write( `Note that not all expected log database table entries have been created yet by the ` &&
          `raised events`
          )->write( evt_log_entries ).
      flag = abap_true.
    ELSE.
      out->write( `Log database table entries created by the ` &&
        `raised events`
        )->write( evt_log_entries ).
    ENDIF.

    "The following implementation is included for exploring the asynchronity in the self-contained example, if you
    "have commented out the WAIT statement above, or if not all expected entries are available in the database table
    "yet. This is just to give it some more time and select from the database table again.
    IF flag = abap_true.
      out->write( |\n| ).
      out->write( |******************************************************| ).
      out->write( |\n| ).
      out->write( |Out of { zbp_demo_abap_rap_ro_m_as=>num_raised_events } events that are expected to be raised in the example implementation, | &&
                  |only { lines( evt_log_entries ) } events are available in the database table at this stage. So, waiting a bit more ...| ).
      out->write( |\n| ).

      WAIT UP TO 1 SECONDS.

      SELECT calc_result, crea_date_time
       FROM zdemo_abap_draft
       ORDER BY crea_date_time
       INTO TABLE @evt_log_entries.

      IF lines( evt_log_entries ) = zbp_demo_abap_rap_ro_m_as=>num_raised_events.
        out->write( `Log database table entries created by the ` &&
      `raised events after waiting some more time`
      )->write( evt_log_entries ).
      ELSE.
        out->write( |Hmm... still not all events are available in the database table.| ).
        out->write( evt_log_entries ).
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD class_constructor.
    DELETE FROM zdemo_abap_tabca.
    DELETE FROM zdemo_abap_draft.
    CLEAR zbp_demo_abap_rap_ro_m_as=>num_raised_events.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_regex DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    INTERFACES if_abap_matcher_callout.
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA callout TYPE i.
    CLASS-DATA callout_tab TYPE string_table.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_regex IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: Regular Expressions in ABAP\n\n| ).
    out->write( `1) Characters and Character Types` ).

    DATA string_chars_types TYPE string.

    "Specific character
    string_chars_types = replace( val = `abcdef` pcre = `a` with = `#` occ = 0 ).

    out->write( string_chars_types ).

    "Any character except a line break
    string_chars_types = replace( val = |ab 1#?C\n D23| pcre = `.` with = `_` occ = 0 ).
    out->write( string_chars_types ).

    "Any digit
    string_chars_types = replace( val = `a1-b2 3-4c9` pcre = `\d` with = `#` occ = 0 ).
    out->write( string_chars_types ).

    "Any non-digit
    string_chars_types = replace( val = `a1-b2 3-4c9` pcre = `\D` with = `#` occ = 0 ).
    out->write( string_chars_types ).

    "Any whitespace character such as a blank, tab and new line
    string_chars_types = replace( val = |ab cd\tef\ngh| pcre = `\s` with = `#` occ = 0 ).
    out->write( string_chars_types ).

    "Any character that is not a
    string_chars_types = replace( val = |ab cd\tef\ngh| pcre = `\S` with = `#` occ = 0 ).
    out->write( string_chars_types ).

    "Any word character (letter, digit or the underscore)
    string_chars_types = replace( val = `(ab 12_c)` pcre = `\w` with = `#` occ = 0 ).
    out->write( string_chars_types ).

    "Any character that is not a word character
    string_chars_types = replace( val = `(ab 12_c)` pcre = `\W` with = `#` occ = 0 ).
    out->write( string_chars_types ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Escaped Characters and Special Variants` ) ).

    DATA string_esc_chars TYPE string.

    "Special characters
    string_esc_chars = replace( val = `a[b]c\d/e^f.g` pcre = `\[|\]|\\|\/|\^|\.` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    "Line feeds
    string_esc_chars = replace( val = |a\nb\nc| pcre = `\n` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    "Line feed negation
    string_esc_chars = replace( val = |a\nb\nc| pcre = `\N` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    "Tabs
    string_esc_chars = replace( val = |a\tb\tc| pcre = `\t` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    "Carriage return
    string_esc_chars = replace( val = |d\re\rf| pcre = `\r` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    "Characters with hex code
    "The example string includes a non-breaking space.
    string_esc_chars = replace(
      val = |#{ cl_abap_conv_codepage=>create_in( codepage = `UTF-16BE` )->convert( source = CONV xstring( `00A0` ) ) }#|
      pcre = `\x{00A0}` with = `x` occ = 0 ).
    out->write( string_esc_chars ).

    "Characters with Unicode code point
    "As above, the example string includes a non-breaking space.
    "The PCRE syntax uses the control verb (*UTF) to enable UTF mode.
    string_esc_chars = replace(
      val = |#{ cl_abap_conv_codepage=>create_in( codepage = `UTF-16BE` )->convert( source = CONV xstring( `00A0` ) ) }#|
      pcre = `(*UTF)\N{U+00A0}` with = `y` occ = 0 ).
    out->write( string_esc_chars ).

    "Characters with a specified Unicode character property
    string_esc_chars = replace( val = `Hello ABAP` pcre = `\p{Ll}+` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    string_esc_chars = replace( val = `Hello ABAP` pcre = `\p{Lu}+` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    string_esc_chars = replace( val = `Hello ABAP` pcre = `\P{Ll}+` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

    string_esc_chars = replace( val = `Hello ABAP` pcre = `\P{Lu}+` with = `#` occ = 0 ).
    out->write( string_esc_chars ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Quantifiers, Repetitions and Alternatives` ) ).

    DATA string_quan_rep_alt TYPE string.

    "Zero or more repetitions
    string_quan_rep_alt = replace( val = `abc abbc abbbc a ac` pcre = `ab*` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "One or more repetitions
    string_quan_rep_alt = replace( val = `abc abbc abbbc a ac` pcre = `ab+` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Between x and y repetitions
    string_quan_rep_alt = replace( val = `abc abbc abbbc a ac` pcre = `ab{2,3}` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Exactly n repetitions
    string_quan_rep_alt = replace( val = `abc abbc abbbc a ac` pcre = `ab{3}` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Exactly n or more repetitions
    string_quan_rep_alt = replace( val = `abc abbc abbbc a ac` pcre = `ab{2,}` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Optional matches
    string_quan_rep_alt = replace( val = `abc abbc abbbc a ac` pcre = `ab?` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Alternative matches
    string_quan_rep_alt = replace( val = `azbycxdwevfu` pcre = `a|b|c` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Capturing non-greedily (zero or more repetitions)
    string_quan_rep_alt = replace( val = `abcd abccccd ab` pcre = `bc*?` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    string_quan_rep_alt = replace( val = `abcxdefghxi` pcre = `\A.*?x` with = `_` ).
    out->write( string_quan_rep_alt ).

    "Example to compare with greedy capturing
    string_quan_rep_alt = replace( val = `abcxdefghxi` pcre = `\A.*x` with = `_` ).
    out->write( string_quan_rep_alt ).

    "Capturing non-greedily (one or more repetitions)
    string_quan_rep_alt = replace( val = `abcd abccccd ab` pcre = `bc+?` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    "Example to compare with greedy capturing
    string_quan_rep_alt = replace( val = `abcd abccccd ab` pcre = `bc+` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

    string_quan_rep_alt = replace( val = `<span>Hallo</span>` pcre = `<.+?>` with = `#` occ = 0 ).
    out->write( string_quan_rep_alt ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Character Sets and Ranges` ) ).

    DATA string_char_sets_ranges TYPE string.

    "Defining a character set
    string_char_sets_ranges = replace( val = `bit bat but bet` pcre = `b[iu]` with = `#` occ = 0 ).
    out->write( string_char_sets_ranges ).

    "Defining a character range
    string_char_sets_ranges = replace( val = `aa1 ab2 ba3 cac4 da56 a7` pcre = `a[a-c0-5]` with = `#` occ = 0 ).
    out->write( string_char_sets_ranges ).

    "Matching any single character not present in the list
    string_char_sets_ranges = replace( val = `ABap` pcre = `[^Ap]` with = `#` occ = 0 ).
    out->write( string_char_sets_ranges ).

    "Matching any single character not within the range
    string_char_sets_ranges = replace( val = `ABCDabcd123456` pcre = `[^A-Ca-c1-4]` with = `#` occ = 0 ).
    out->write( string_char_sets_ranges ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Anchors and Positions` ) ).

    DATA string_anchors_pos TYPE string.

    "Start of subject, syntax \A
    string_anchors_pos = replace( val = `abc def` pcre = `\A` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "Start of subject, syntax ^; find more information below regarding multi-line mode
    string_anchors_pos = replace( val = |abc\ndef\nghi| pcre = `(?m)^` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "The following examples uses ^ without enabling the multi-line mode
    string_anchors_pos = replace( val = |abc\ndef\nghi| pcre = `^` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "End of subject, syntax \Z
    string_anchors_pos = replace( val = `abc def` pcre = `\Z` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "End of subject, syntax $
    "The example uses multi-line mode
    string_anchors_pos = replace( val = |abc\ndef\nghi| pcre = `(?m)$` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "Start or end of word
    string_anchors_pos = replace( val = `abcd a12d ed` pcre = `\ba.` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    string_anchors_pos = replace( val = `abcd a12d ed` pcre = `\Dd\b` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    string_anchors_pos = replace( val = `abcd a12d ed` pcre = `\b.d\b` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "Not at the start or end of words
    string_anchors_pos = replace( val = `see an elefant` pcre = `\Be\B` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

    "Resetting the starting point of a match
    string_anchors_pos = replace( val = `abcd` pcre = `a.\Kc` with = `#` occ = 0 ).
    out->write( string_anchors_pos ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Capturing Groups, Replacements and Backreferences` ) ).

    DATA string_capt_group TYPE string.

    string_capt_group = replace( val = `bit bat but bet` pcre = `b(a|u)t` with = `#` occ = 0 ).
    out->write( string_capt_group ).

    "------- Replacements with capturing groups -------

    string_capt_group = replace( val = `APAB` pcre = `(..)(..)` with = `$2$1` ).
    out->write( string_capt_group ).

    "$0 representing the content of the whole match
    string_capt_group = replace( val = `abcd` pcre = `(..)(..)` with = `#$0#` ).
    out->write( string_capt_group ).

    "Alternative replacement syntax with the curly brackets
    string_capt_group = replace( val = `APAB` pcre = `(..)(..)` with = `${2}${1}` ).
    out->write( string_capt_group ).

    "------- Named capturing groups -------

    "PCRE syntax (?<name>...), replacement syntax $name
    string_capt_group = replace( val = xco_cp=>sy->date( )->as( xco_cp_time=>format->abap )->value
                                  pcre = `(?<yr>\d{4})(?<mo>\d{2})(?<d>\d{2})`
                                  with = `Day: $d, month: $mo, year: $yr` ).

    out->write( string_capt_group ).

    "Alternative PCRE syntax (?'name'...), replacement syntax ${name}
    string_capt_group = replace( val = xco_cp=>sy->date( )->as( xco_cp_time=>format->abap )->value
                                  pcre = `(?'yr'\d{4})(?'mo'\d{2})(?'d'\d{2})`
                                  with = `${d}.${mo}.${yr}` ).
    out->write( string_capt_group ).

    "Creating a group but not capturing it
    string_capt_group = replace( val = `abcd` pcre = `(?:..)(..)` with = `#$1#` ).
    out->write( string_capt_group ).

    "The following example raises an exception. $2 cannot be referred to.
    TRY.
        string_capt_group = replace( val = `abcd` pcre = `(?:..)(..)` with = `#$1#$2#` ).
      CATCH cx_sy_invalid_regex_format INTO DATA(error).
        out->write( error->get_text( ) ).
    ENDTRY.

    string_capt_group = replace( val = `abcd` pcre = `(?:..)(..)` with = `#$0#` ).
    out->write( string_capt_group ).

    "------- Back reference -------

    "In the example, the capturing group 1 holds `ab`. The second capturing group captures
    "all word characters until `ab` is found, including `ab`. The reference to the first
    "capturing group is made using \1.
    string_capt_group = replace( val = `abcdefabghij` pcre = `(a.)(\w*)\1` with = `#` ).
    out->write( string_capt_group ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Lookarounds` ) ).

    DATA string_look_arounds TYPE string.

    "Positive lookahead
    string_look_arounds = replace( val = `abc ade` pcre = `a(?=b)` with = `#` occ = 0 ).
    out->write( string_look_arounds ).

    "Negative lookahead
    string_look_arounds = replace( val = `abc ade` pcre = `a(?!b)` with = `#` occ = 0 ).
    out->write( string_look_arounds ).

    "Positive lookbehind
    string_look_arounds = replace( val = `ab c abcd` pcre = `(?<=\s)c` with = `#` occ = 0 ).
    out->write( string_look_arounds ).

    "Negative lookbehind
    string_look_arounds = replace( val = `ab c abcd` pcre = `(?<!\s)c` with = `#` occ = 0 ).
    out->write( string_look_arounds ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Case Conversions in Replacement Patterns` ) ).

    DATA string_case_conv TYPE string.

    "\u syntax
    string_case_conv = replace( val = `abcdefg` pcre = `c(.*)` with = `c\u$1` ).
    out->write( string_case_conv ).

    "\U syntax
    string_case_conv = replace( val = `abcdefg` pcre = `c(.*)` with = `c\U$1` ).
    out->write( string_case_conv ).

    "\l syntax
    string_case_conv = replace( val = `HIJKLMNO` pcre = `K(.*)` with = `K\l$1` ).
    out->write( string_case_conv ).

    "\L syntax
    string_case_conv = replace( val = `HIJKLMNO` pcre = `K(.*)` with = `K\L$1` ).
    out->write( string_case_conv ).

    "\E syntax
    string_case_conv = replace( val = `abcdefg` pcre = `c(..)(..)` with = `c\U$1\E$2` ).
    out->write( string_case_conv ).

    "The following example is a comparison to similar syntax without specifying \E
    string_case_conv = replace( val = `abcdefg` pcre = `c(..)(..)` with = `c\U$1$2` ).
    out->write( string_case_conv ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Setting Options and Control Verbs` ) ).

    DATA string_opt_set TYPE string.

    "----------- Examples with `.` and single line mode -----------

    "`.` matches new lines feeds when the single line option is set
    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `.` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    "Result (11 replacements including the new line feeds):
    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `(?s).` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    string_opt_set = replace( val = |\n\n| pcre = `(?s).` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    "----------- Examples for the start of subjects -----------

    "Multi-line mode not enabled
    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `^.` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    "Multi-line mode enabled
    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `(?m)^.` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    "\A for comparison
    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `(?m)\A.` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    "----------- Examples for the end of subjects -----------

    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `.$` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `(?m).$` with = `#` occ = 0 ).
    out->write( string_opt_set ).

    "\Z syntax (the result is the same as with `.$`)
    string_opt_set = replace( val = |abc\ndef\nghi| pcre = `(?m).\Z` with = `#` occ = 0 ).
    out->write( string_opt_set ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Extended Mode` ) ).

    DATA some_string TYPE string.

    "Extended mode is enabled by default
    "No replacement in the example.
    some_string = replace( val = `abc def` pcre = `abc def` with = `#` ).
    out->write( some_string ).

    "The following example works because there is no whitespace in the source string.
    "The whitespace in the regular expression is ignored.
    some_string = replace( val = `abcdef` pcre = `abc def` with = `#` ).
    out->write( some_string ).

    "To match whitespace characters, you can use the pattern \s
    some_string = replace( val = `abc def` pcre = `abc\sdef` with = `#` ).
    out->write( some_string ).

    "Escaping a whitespace using \
    some_string = replace( val = `abc def` pcre = `abc\ def` with = `#` ).
    out->write( some_string ).

    "The following example also performs the replacement as the unescaped whitespaces
    "are ignored.
    some_string = replace( val = `abc def` pcre = `abc\         def` with = `#` ).
    out->write( some_string ).

    "Disabling the extended mode so that whitespaces are not ignored
    some_string = replace( val = `abc def` pcre = `(?-x)abc def` with = `#` ).
    out->write( some_string ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Control verbs` ) ).

    DATA ctrl_verb_string TYPE string.

    "Using (*UTF); the source string contains a non-breakable space that is to be replaced
    ctrl_verb_string = replace(
      val = |#{ cl_abap_conv_codepage=>create_in( codepage = `UTF-16BE` )->convert( source = CONV xstring( `00A0` ) ) }#|
      pcre = `(*UTF)\N{U+00A0}` with = `x` occ = 0 ).
    out->write( ctrl_verb_string ).

    "Line breaks
    "The results are demonstrated using string templates.
    "In the examples, the multi-line mode is enabled in addition.

    ctrl_verb_string = replace( val = |abc\ndef\rghi\r\njkl|
                                pcre = `(*CR)(?m)^` with = `_` occ = 0 ).
    out->write( ctrl_verb_string ).

    ctrl_verb_string = replace( val = |abc\ndef\rghi\r\njkl|
                                pcre = `(*LF)(?m)^` with = `_` occ = 0 ).
    out->write( ctrl_verb_string ).

    ctrl_verb_string = replace( val = |abc\ndef\rghi\r\njkl|
                                pcre = `(*CRLF)(?m)^` with = `_` occ = 0 ).
    out->write( ctrl_verb_string ).

    ctrl_verb_string = replace( val = |abc\ndef\rghi\r\njkl|
                                pcre = `(*ANYCRLF)(?m)^` with = `_` occ = 0 ).
    out->write( ctrl_verb_string ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Callouts` ) ).

    "The following example shows how to use callouts to call an ABAP method from a PCRE
    "regular expression. It creates an object-oriented representation of a PCRE regex using
    "the CL_ABAP_REGEX class, applying different PCRE syntaxes for callout specifications.
    "The class implements the IF_ABAP_MATCHER_CALLOUT interface, and the callout method uses
    "a demo class instance as the callout handler. If the regex matches, the method is called
    "for each callout position. The callout method populates a string table with accessible
    "details. This demonstrates that regex processing can be influenced, and in the example,
    "processing stops when a condition is met. As a result, found is false because the regex
    "is not fully processed. For more details, refer to the class documentation.

    DATA(text_to_search) = `abcdefghijklmnopq`.
    DATA(regex) = cl_abap_regex=>create_pcre( pattern = `(...)(?C1)(..)(?C2)(....)(?C3)(.)(?C"D")(....)(?C"E")(...)(?C"F")` ).
    DATA(matcher) = regex->create_matcher( text = text_to_search ).
    DATA(handler) = NEW zcl_demo_abap_regex( ).
    matcher->set_callout( handler ).
    DATA(found) = matcher->match( ).

    IF found = abap_false.
      out->write( |Pattern not found.\n\n| ).
    ENDIF.

    out->write( callout_tab ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Conditional Patterns` ) ).

    DATA string_cond_pattern TYPE string.

    "------- Conditions in the search pattern -------

    "Example pattern:
    "- The first capturing group matches a digit.
    "- The '?' character specifies that the capturing group participates
    "  in the match optionally.
    "- A condition is specified, introduced by '(?...' and referring to
    "  the first capturing group (the digit) indicated by 1.
    "- If the condition is met, i.e. a digit is found, then the yes pattern
    "  is applied ('.pdf'), which participates in the match.
    "- If the condition is not met, i.e. a digit is not found, then the no
    "  pattern is applied ('.md'), which participates in the match.
    "- As a result, '2.pdf' and the two '.md' occurrences (also the one
    "  without the digit) are replaced.

    string_cond_pattern = replace( val = `1.txt,a.txt,2.pdf,b.pdf,3.gif,c.gif,4.md,d.md,5.jpg,e.jpg`
                                    pcre = `(\d)?(?(1)\.pdf|\.md)` with = `#` occ = 0 ).
    out->write( string_cond_pattern ).

    "------- Conditions in the replacement pattern -------

    "Search pattern:
    "- The '?' character specifies that the capturing group participates in the match optionally.
    "Replacements pattern:
    "- '$' followed by the specification of the capturing group that is referred to in curly brackets
    "- The capturing group number is followed by a ':' and '+...' that denotes the value if true,
    "  the value following the other colon denotes the value if false

    string_cond_pattern = replace( val = `correct`   pcre = `(in)?correct` with = `This is ${1:+not:very} good.` ).
    out->write( string_cond_pattern ).

    string_cond_pattern = replace( val = `incorrect` pcre = `(in)?correct` with = `This is ${1:+not:very} good.` ).
    out->write( string_cond_pattern ).

    "Syntax {n:-default}
    "Shortcut for the PCRE replacement pattern by specifying
    "a default if the capture group does not participate in the match

    "'ab' participates in the match, so the default replacement pattern is not
    "applied
    string_cond_pattern = replace( val = `abcd` pcre = `(ab)?cd` with = `${1:-yz}cd` ).
    out->write( string_cond_pattern ).

    "'ab' does not participate in the match, so the default replacement pattern is
    "applied
    string_cond_pattern = replace( val = `cd` pcre = `(ab)?cd` with = `${1:-yz}cd` ).
    out->write( string_cond_pattern ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) ABAP Statements Using Regular Expressions` ) ).

    "-----------------------------------------------------------------------------
    "------------------------------- FIND ----------------------------------------
    "-----------------------------------------------------------------------------

    DATA(str) = `Cathy's black cat on the mat played with Matt.`.

    "----- ALL OCCURRENCES addition: Finding all occurrences -----
    "The MATCH COUNT addition stores the number of occurrences in a data object.

    "Determining the number of letters in a string
    FIND ALL OCCURRENCES OF PCRE `[A-Za-z]` IN str MATCH COUNT DATA(a).
    out->write( a ).

    "----- RESULTS addition: Finding all occurrences -----
    "The example also uses the ALL OCCURRENCES addition. The findings are
    "stored in a table of type match_result_tab.
    FIND ALL OCCURRENCES OF PCRE `\s` IN str RESULTS DATA(b).
    out->write( b ).

    "----- SUBMATCHES addition: Storing capturing group content in variables -----
    "Pattern: anything before and after ' on '
    FIND PCRE `(.*)\son\s(.*)` IN str IGNORING CASE SUBMATCHES DATA(c) DATA(d).
    out->write( c ).
    out->write( d ).

    "Using the RESULTS addition to get offset and length information of
    "all capturing groups, among others
    FIND PCRE `(.*)\son\s(.*)` IN str IGNORING CASE RESULTS DATA(e).
    out->write( e ).

    "----- MATCH OFFSET/LENGTH additions -----
    "The following examples find the last occurrence of a comma and the following content.
    "\K denotes that the comma is excluded from the result. Using the offset and length
    "values, the part of the string is extracted. The examples underscore that you can
    "achieve the same thing differently with different PCRE syntax patterns (which also
    "applies to ABAP demonstrated with the use of the substring function and specifying
    "the syntax string+off(len) to extract the substring).

    str = `abc,def,ghi,jkl,mno,pqr,stu,vwx,yz`.

    "Negative lookahead
    FIND PCRE `,(?!.*,)\K.*` IN str MATCH OFFSET DATA(off_a) MATCH LENGTH DATA(len_a).
    DATA(content_a) = substring( val = str off = off_a len = len_a ).
    out->write( off_a ).
    out->write( len_a ).
    out->write( content_a ).

    "Positive lookahead
    FIND PCRE `,(?=[^,]*$)\K.*` IN str MATCH OFFSET DATA(off_b) MATCH LENGTH DATA(len_b).
    DATA(content_b) = str+off_b(len_b).
    out->write( off_b ).
    out->write( len_b ).
    out->write( content_b ).

    ASSERT content_a = `yz`.
    ASSERT content_b = content_a.

    "----- IN TABLE addition: Searching in internal tables  -----
    "The internal table must have a character-like line type.

    "Searching in an internal table and retrieving line, offset, length information
    "The example only searches for the first occurrence. See another example below
    "that uses the ALL OCCURRENCES and RESULTS additions.
    DATA(itab) = VALUE string_table( ( `Cathy's black cat on the mat played with the friend of Matt.` ) ).

    "Pattern: 't' at the beginning of a word followed by another character
    FIND FIRST OCCURRENCE OF PCRE `\bt.` IN TABLE itab
      IGNORING CASE MATCH LINE DATA(f) MATCH OFFSET DATA(g) MATCH LENGTH DATA(h).
    out->write( f ).
    out->write( g ).
    out->write( h ).

    "----- Searching in internal tables  -----
    "The RESULTS addition stores findings in an internal table of type match_result_tab when
    "ALL OCCURRENCES is used.
    "Submatches (i.e. length and offset values of the submatches) are stored in internal
    "tables themselves. Therefore, the example uses nested loops and the substring function
    "to retrieve the strings.

    "The objective of the following example is to extract the content of the segments that
    "are positioned within /.../ in a URL. The segments are stored in an internal table.
    DATA(url) = `https://help.sap.com/docs/abap-cloud/abap-concepts/controlled-sap-luw/`.
    DATA url_parts TYPE string_table.

    FIND ALL OCCURRENCES OF PCRE `(?<=\/)([^\/]+)(?=\/)` IN url RESULTS DATA(res).
    out->write( res ).

    "Details on the regular expression:
    "- Positive lookbehind (?<=\/) that determines that the content is preceded by `/`
    "- Positive lookahead (?=\/) that determines that the content is followed by `/
    "- ([^\/]+) in between determines that any sequence of characters that are not `/` are matched
    "- The match is put in parentheses to store the submatch

    LOOP AT res INTO DATA(finding).
      LOOP AT finding-submatches INTO DATA(sub).
        DATA(url_part) = substring( val = url off = sub-offset len = sub-length ).
        APPEND url_part TO url_parts.
      ENDLOOP.
    ENDLOOP.

    out->write( url_parts ).


    "The following statement uses nested iteration expressions with FOR instead of nested
    "LOOP statements.
    DATA(url_parts_for_loop) = VALUE string_table( FOR wa1 IN res
                                                   FOR wa2 IN wa1-submatches
                                                   ( substring( val = url off = wa2-offset len = wa2-length ) ) ).

    ASSERT url_parts = url_parts_for_loop.

    "-----------------------------------------------------------------------------
    "------------------------------- REPLACE -------------------------------------
    "-----------------------------------------------------------------------------

    DATA(str_replace) = `ab apppc app`.
    DATA(str_replace_copy) = str_replace.

    "Changing the source field directly with a REPLACE statement; same as above
    REPLACE PCRE `(.*?)PP(.*)` IN str_replace WITH `$2#$1` IGNORING CASE.
    out->write( str_replace ).

    str_replace = str_replace_copy.

    "ALL OCCURRENCES addition
    REPLACE ALL OCCURRENCES OF PCRE `\s` IN str_replace WITH `#`.
    out->write( str_replace ).

    str_replace = str_replace_copy.

    REPLACE ALL OCCURRENCES OF PCRE `p.` IN str_replace WITH `#`
      REPLACEMENT COUNT DATA(repl_cnt) "3
      RESULTS DATA(repl_res).
    out->write( repl_cnt ).
    out->write( repl_res ).

    DATA(str_table_original) = VALUE string_table( ( `a1bc2` ) ( `d3ef` ) ( `4ghi` ) ( `jkl` ) ).
    DATA(str_table) = str_table_original.

    "Replacing all occurrences in a table
    "RESULTS addition: Storing information in an internal table of type repl_result_tab
    REPLACE ALL OCCURRENCES OF PCRE `\d`
      IN TABLE str_table
      WITH `#`
      RESULTS DATA(res_table).

    out->write( res_table ).

    str_table = str_table_original.

    "Replacing the first occurrence in a table
    "RESULTS addition: Storing information in a structure of type repl_result
    REPLACE FIRST OCCURRENCE OF PCRE `\d`
      IN TABLE str_table
      WITH `#`
      RESULTS DATA(res_structure).

    out->write( res_structure ).

    str_table = str_table_original.

    "Restricting the search range in an internal table
    REPLACE ALL OCCURRENCES OF PCRE `\d`
      IN TABLE str_table
      FROM 1 TO 2
      WITH `#`.

    out->write( str_table ).

    str_table = str_table_original.

    "Offsets can be optionally specified (also only the offset of start or end line possible)
    REPLACE ALL OCCURRENCES OF PCRE `\d`
      IN TABLE str_table
      FROM 1 OFFSET 3 TO 2 OFFSET 2
      WITH `#`.

    out->write( str_table ).


**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Built-In Functions in ABAP Using Regular Expressions` ) ).

    DATA(text) = `Pieces of cakes.`.

    "---------------- find ----------------
    "The find function searches for the subtexting specified and returns the offset

    DATA(find) = find( val = text pcre = `\.` ).
    out->write( find ).

    "---------------- find_end ----------------
    "find_end returns the sum of the offset of the occurrence plus the length of the match

    DATA(find_end) = find_end( val = text pcre = `\s` ).
    out->write( find_end ).

    "---------------- count ----------------

    DATA(count_a)  = count( val = text pcre = `\s` ).
    out->write( count_a ).

    DATA(count_b)  = count( val = text pcre = `.` ).
    out->write( count_b ).

    "---------------- match ----------------

    DATA(match_a) = match( val = `The email address is jon.doe@email.com.`
                            pcre = `\w+(\.\w+)*@(\w+\.)+(\w{2,4})` ).

    out->write( match_a ).

    "Find blank (without inlcuding it in the result indicated by \K) and
    "the following 2 characters, second occurrence
    DATA(match_b) = match( val = `The email address is jon.doe@email.com.`
                            pcre = `\s\K..`
                            occ = 2 ).

    out->write( match_b ).

    "---------------- replace ----------------

    DATA(replace_a) = replace( val = text pcre = `\s` with = `#` ).

    out->write( replace_a ).

    DATA(replace_b) = replace( val = text pcre = `\s` occ = 2 with = `#` ).

    out->write( replace_b ).

    "---------------- substring_* ----------------

    text = `Lorem ipsum dolor sit amet`.

    "Extracting a substring ...
    "... after a matching regular expression
    DATA(substring_after) = substring_after( val = text pcre = `\s` occ = 2 ).

    out->write( substring_after ).

    "... before a matching regular expression
    DATA(substring_before) = substring_before( val = text pcre = `\s` occ = 2 ).

    out->write( substring_before ).

    "... from a matching regular expression on including the match
    DATA(substring_from) = substring_from( val = text pcre = `\s` occ = 2  ).

    out->write( substring_from ).

    "... up to a matching regular expression including the match
    DATA(substring_to) = substring_to( val = text pcre = `\s` occ = 2 ).

    out->write( substring_to ).

    "---------------- Predicate functions: contains, matches ----------------
    "The built-in functions 'contains' returns a truth value. In the following
    "examples, the truth value is demonstrated using the xsdbool function.

    DATA(contains) = xsdbool( contains( val = `abc def` pcre = `\s`  ) ).
    out->write( contains ).

    "The built-in functions 'matches' compares a search range of the textual argument
    "with a regular expression.

    DATA(matches) = xsdbool( matches( val  = `jon.doe@email.com`
                                      pcre = `\w+(\.\w+)*@(\w+\.)+(\w{2,4})` ) ).

    out->write( matches ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Built-In Functions in ABAP SQL and CDS Using Regular Expressions` ) ).

    "Populating demo database tables
    zcl_demo_abap_aux=>fill_dbtabs( ).

    SELECT SINGLE
      carrid,    "LH
      carrname,  "Lufthansa
      url,       "http://www.lufthansa.com

      "Checks if expression contains a PCRE expression;
      "case-sensitive by default (case_sensitive parameter can be specified)
      "Notes on the 1 = found, 0 = not found
      "1
      like_regexpr( pcre  = '\..',         "Period that is followed by any character
                    value = url ) AS like_regex,

      "Searches a PCRE pattern, returns offset of match;
      "many optional parameters: occurrence, case_sensitive, start, group
      "21
      locate_regexpr( pcre = '\..',        "Period followed by any character
                      value = url,
                      occurrence = 2 )     "2nd occurrence in the string
                      AS locate_regexpr,

      "Searches a PCRE pattern, returns offset of match + 1;
      "many optional parameters: occurrence, case_sensitive, start, group
      "2
      locate_regexpr_after( pcre = '.',     "Any character
                            value = url,
                            occurrence = 1 ) AS locate_regexpr_after,

      "Counts all occurrences of found PCRE patterns
      "2
      occurrences_regexpr( pcre = '\..',    "Period that is followed by any character
                            value = url ) AS occ_regex,

      "Replaces a found PCRE expression;
      "more parameters possible: occurrence, case_sensitive, start
      "http://www#ufthansa#om
      replace_regexpr( pcre = '\..',        "Period that is followed by any character
                        value = url,
                        with = '#' ) AS replace_regex,

      "Searches for a PCRE expression and returns the matched substring
      "More parameters possible: occurrence, case_sensitive, start, group
      ".lu
      substring_regexpr( pcre = '\...', "Period that is followed by any two characters
                          value = url ) AS substring_regexpr

      FROM zdemo_abap_carr
      WHERE carrid = 'LH'
      INTO @DATA(builtin_func_regex).

    out->write( builtin_func_regex ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) System Classes for Regular Expressions: CL_ABAP_REGEX and CL_ABAP_MATCHER` ) ).
    "Note: The example results are not output except one.

    "Example test_stringing
    DATA(test_string) = `a1 # B2 ? cd . E3`.

    "----------- Creating an instance of a regular expression -----------

    "Creating an instance of a regular expression with PCRE syntax
    "using cl_abap_regex

    "Example pattern: Any-non digit followed by a digit
    DATA(regular_expr) = cl_abap_regex=>create_pcre( pattern = `\D\d`
                                              ignore_case = abap_true ).

    "----------- Creating matchers -----------

    "Two ways are possible (both ways return references of type
    "ref to cl_abap_matcher):
    "- create_matcher method of the cl_abap_regex class
    "- create_pcre method of the cl_abap_matcher class
    "Note that several importing parameters are available to enable
    "further settings of the regular expression, e.g. ignoring the
    "case, using the extended mode, etc. The examples pass a test_stringing
    "to the 'text' parameter. You can also specify internal tables
    "with the 'table' parameter and more.

    "Creating a matcher using the create_matcher method of the cl_abap_regex class
    DATA(matcher_1) = regular_expr->create_matcher( text = test_string ).
    "Creating a matcher in one go using method chaining
    DATA(matcher_2) = cl_abap_regex=>create_pcre( pattern = `\D\d`
                                                  ignore_case = abap_true
                                                )->create_matcher( text = test_string ).

    "Creating a matcher using the create_pcre method of the cl_abap_matcher class
    DATA(matcher_3) = cl_abap_matcher=>create_pcre( pattern = `\D\d`
                                                    text    = test_string
                                                    ignore_case = abap_true ).

    "----------- Exploring searching and replacing -----------

    "--- Finding all occurrences using the find_all method ---
    "In the example, result has the type match_result_tab containing the findings.
    DATA(result_fa1) = matcher_1->find_all( ).

    DATA(result_fa2) = matcher_2->find_all( ).
    ASSERT result_fa2 = result_fa1.

    "Getting the result in one go using method chaining with cl_abap_matcher
    DATA(result_fa3) = cl_abap_matcher=>create_pcre( pattern = `\D\d`
                                                    text    = test_string
                                                    ignore_case = abap_true
                                                  )->find_all( ).
    ASSERT result_fa3 = result_fa1.

    "--- Example with submatches ---

    test_string = `XabcdXXefgXXhXXijklmnXX`.

    DATA(result_fa4) = cl_abap_matcher=>create_pcre( pattern = `X(.*?)X`
                                                     text    = test_string
                                                     ignore_case = abap_true
                                                   )->find_all( ).

    "--- Replacing all occurrences using the 'replace_all' method ---

    DATA(matcher_repl_1) = cl_abap_regex=>create_pcre( pattern = `X(.*?)X`
                                                     )->create_matcher( text = test_string ).

    DATA(repl_count_1) = matcher_repl_1->replace_all( newtext = `#$1#` ).

    DATA(repl_result_1) = matcher_repl_1->text.

    "Using cl_abap_matcher
    DATA(matcher_repl_2) = cl_abap_matcher=>create_pcre( pattern = `X(.*?)X`
                                                         text    = test_string ).
    DATA(repl_count_2) = matcher_repl_2->replace_all( newtext = `#$1#` ).
    DATA(repl_result_2) = matcher_repl_2->text.

    "---- Sequential processing of the regular expression ---
    "---- using the find_next method ------------------------
    "The example explores various other methods, and writes
    "information to a test_stringing table.

    test_string = `a1bc2def3ghij45klm67opqr8stuvwx90yz`.

    DATA(matcher_fn) = cl_abap_matcher=>create_pcre( pattern = `\d(\D.)`
                                                     text    = test_string ).

    DATA test_stringtab TYPE string_table.
    WHILE matcher_fn->find_next( ) = abap_true.
      APPEND |---- Finding { sy-index } -----| TO test_stringtab.

      "Type match_result
      DATA(match_result) = matcher_fn->get_match( ).

      DATA(offset) = matcher_fn->get_offset( ).
      DATA(length) = matcher_fn->get_length( ).
      DATA(matched_content) = test_string+offset(length).

      APPEND |Match offset: { offset }| TO test_stringtab.
      APPEND |Match length: { length }| TO test_stringtab.
      APPEND |Match content: { matched_content }| TO test_stringtab.

      "Type match_result
      DATA(subgroup) = matcher_fn->get_match( )-submatches.

      LOOP AT subgroup INTO DATA(wa).
        DATA(sub_tabix) = sy-tabix.
        DATA(submatch_line) = wa.
        DATA(submatch_offset) = wa-offset.
        DATA(submatch_length) = wa-length.
        DATA(submatch) = matcher_fn->get_submatch( sub_tabix ).
        APPEND |Submatch { sub_tabix } offset: { submatch_offset }| TO test_stringtab.
        APPEND |Submatch { sub_tabix } length: { submatch_length }| TO test_stringtab.
        APPEND |Submatch { sub_tabix } content: { submatch }| TO test_stringtab.
      ENDLOOP.

    ENDWHILE.

    out->write( test_stringtab ).

    "---- Using an object of type cl_abap_regex in ABAP ---
    "---- statements with the REGEX addition --------------

    DATA(result_find_all_1) = cl_abap_matcher=>create_pcre( pattern = `\d(\D.)`
                                                            text = test_string
                                                          )->find_all( ).
    DATA(result_find_all_2) = cl_abap_regex=>create_pcre( pattern = `\d(\D.)`
                                               )->create_matcher( text = test_string
                                               )->find_all( ).

    DATA(reg_expr) = cl_abap_regex=>create_pcre( pattern = `\d(\D.)` ).

    FIND ALL OCCURRENCES OF REGEX reg_expr IN test_string RESULTS DATA(result_find_all_3).

    ASSERT result_find_all_3 = result_find_all_1.
    ASSERT result_find_all_3 = result_find_all_2.

    "Note that the REGEX addition is obsolete when using (POSIX) syntax patterns
    "A syntax warning is displayed for the following example.
    "FIND ALL OCCURRENCES OF REGEX `\d(\D.)` IN test_string RESULTS DATA(result_8).

    "The syntax warning can be suppressed using a pragma
    FIND ALL OCCURRENCES OF REGEX `\d(\D.)` IN test_string RESULTS DATA(result_find_all_4) ##REGEX_POSIX.

    "Using PCRE instead
    FIND ALL OCCURRENCES OF PCRE `\d(\D.)` IN test_string RESULTS DATA(result_find_all_5).
    ASSERT result_find_all_5 = result_find_all_3.

    "---------------- Exploring more parameters of the create_pcre method ----------------
    "See the class documentation for more parameters and information.

    "--- enable_multiline parameter ---

    test_string = |abc\ndef\nghi\njkl|.

    DATA(matcher_no_ml) = cl_abap_matcher=>create_pcre( pattern = `^`
                                                        text    = test_string ).

    DATA(repl_count_no_ml) = matcher_no_ml->replace_all( newtext = `#` ).

    DATA(repl_result_no_ml) = matcher_no_ml->text.

    DATA(matcher_w_ml) = cl_abap_matcher=>create_pcre( pattern = `^`
                                                       text    = test_string
                                                       enable_multiline = abap_true ).

    DATA(repl_count_w_ml) = matcher_w_ml->replace_all( newtext = `#` ).

    DATA(repl_result_w_ml) = matcher_w_ml->text.

    "--- table/ignore_case parameters ---

    DATA(test_string_table) = VALUE string_table( ( `abZdez` ) ( `zZfghZ` ) ( `ijkZZz` ) ( `zzzzZ` ) ).

    DATA(matcher_tab) = cl_abap_matcher=>create_pcre( pattern = `z+`
                                                      table   = test_string_table
                                                      ignore_case = abap_true ).

    DATA(repl_count_tab) = matcher_tab->replace_all( newtext = `#` ).

    DATA(repl_result_tab) = matcher_tab->table.

    "--- extended parameter ---

    test_string = `abc def`.

    DATA(matcher_w_extended) = cl_abap_matcher=>create_pcre( pattern = `abc def`
                                                             text    = test_string ).

    "No replacement in the following example as the extended mode is
    "enabled by default.

    DATA(repl_count_w_extended) = matcher_w_extended->replace_all( newtext = `#` ).

    DATA(repl_result_w_extended) = matcher_w_extended->text.

    "Disabling the extended mode so that whitespaces are not ignored
    DATA(matcher_not_extended) = cl_abap_matcher=>create_pcre( pattern = `abc def`
                                                               text    = test_string
                                                               extended = abap_false ).

    DATA(repl_count_not_extended) = matcher_not_extended->replace_all( newtext = `#` ).

    DATA(repl_result_not_extended) = matcher_not_extended->text.

  ENDMETHOD.

  METHOD if_abap_matcher_callout~callout.
    DATA(ts) = utclong_current( ).
    callout += 1.

    IF callout_string = `F`.
      callout_result = if_abap_matcher_callout=>c_callout_result-abort.
    ELSE.
      callout_result = if_abap_matcher_callout=>c_callout_result-pass.

      APPEND INITIAL LINE TO callout_tab.
      APPEND |----------------- Callout { callout } -----------------| TO callout_tab.
      APPEND INITIAL LINE TO callout_tab.
      APPEND |callout_num: { callout_num }| TO callout_tab.
      APPEND |callout_string: { callout_string }| TO callout_tab.
      APPEND |regex: { regex  }| TO callout_tab.
      APPEND |subject: { subject }| TO callout_tab.
      APPEND |current_subject_pos: { current_subject_pos }| TO callout_tab.
      APPEND |current_pattern_pos: { current_pattern_pos }| TO callout_tab.
      APPEND |capture_last: { capture_last }| TO callout_tab.
      APPEND |capture_last_len: { capture_last_len }| TO callout_tab.
      APPEND |capture_last_off: { capture_last_off }| TO callout_tab.
      APPEND |start_match_off: { start_match_off }| TO callout_tab.

      TRY.
          APPEND |Content of submatch: { subject+capture_last_off(capture_last_len) }| TO callout_tab.
        CATCH cx_sy_range_out_of_bounds.
      ENDTRY.
      APPEND |This callout was called at { ts }| TO callout_tab.
    ENDIF.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_sql DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.
    CLASS-METHODS:
      class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS: select_from_dbtab.

    CLASS-DATA:
      struct   TYPE zdemo_abap_flsch,
      itab     TYPE TABLE OF zdemo_abap_flsch,
      itab_res TYPE TABLE OF zdemo_abap_carr.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_sql IMPLEMENTATION.


  METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: ABAP SQL\n\n| ).
    out->write( |Using SELECT for multiple purposes\n| ).
    out->write( |1) Reading a single row from database table into a structure\n\n| ).

    "Note that, although it is optional, a WHERE clause should always be
    "specified for performance reasons and to restrict the read result.
    "In the following SELECT statements, a simple WHERE condition is
    "used to limit the number of found results.

    "Reading all fields

    "Reading into existing structure
    SELECT SINGLE FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'LH' AND connid = '400'
      INTO @struct.

    "Alternative syntax (no FIELDS), target variable declared inline
    SELECT SINGLE *
      FROM zdemo_abap_flsch
      WHERE carrid = 'AA' AND connid = '17'
      INTO @DATA(struct_1a).

    out->write( data = struct name = `struct` ).
    out->write( |\n| ).
    out->write( data = struct_1a name = `struct_1a` ).
    out->write( |\n| ).

    "Reading selected fields

    SELECT SINGLE carrid, connid, cityfrom, cityto
      FROM zdemo_abap_flsch
      WHERE carrid = 'AZ' AND connid = '555'
      INTO @DATA(struct_1b).

    "Alternative syntax (with FIELDS)
    SELECT SINGLE
      FROM zdemo_abap_flsch
      FIELDS carrid, connid, cityfrom, cityto
      WHERE carrid = 'DL' AND connid = '106'
      INTO @DATA(struct_1c).

    "When reading a selected set of fields into an existing target
    "variable, the CORRESPONDING FIELDS OF addition in the INTO clause
    "should be used. Other, not selected fields remain initial.
    DATA struct_1d LIKE struct.

    SELECT SINGLE carrid, connid, cityfrom, cityto
      FROM zdemo_abap_flsch
      WHERE carrid = 'DL' AND connid = '106'
      INTO CORRESPONDING FIELDS OF @struct_1d.

    out->write( data = struct_1b name = `struct_1b` ).
    out->write( |\n| ).
    out->write( data = struct_1c name = `struct_1c` ).
    out->write( |\n| ).
    out->write( data = struct_1d name = `struct_1d` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Reading mutliple rows into an internal table` ) ).

    "Reading all fields into an existing internal table
    SELECT FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'DL'
      INTO TABLE @itab.

    "Alternative syntax (no FIELDS), reading of a selected set of
    "fields, internal table is declared inline
    SELECT carrid, connid, cityfrom, cityto
      FROM zdemo_abap_flsch
      WHERE carrid = 'AZ'
      INTO TABLE @DATA(itab_2a).

    "When reading a selected set of fields into an existing target
    "variable, the CORRESPONDING FIELDS OF addition in the INTO clause
    "should be used. Other, not selected fields remain initial.
    DATA itab_2b LIKE itab.

    SELECT carrid, connid, cityfrom, cityto
      FROM zdemo_abap_flsch
      WHERE carrid = 'AZ'
      INTO CORRESPONDING FIELDS OF TABLE @itab_2b.

    out->write( data = itab name = `itab` ).
    out->write( |\n| ).
    out->write( data = itab_2a name = `itab_2a` ).
    out->write( |\n| ).
    out->write( data = itab_2b name = `itab_2b` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) SELECT loop: Sequentially reading multiple rows` ) ).

    "In the example below, the individual rows that are read are
    "modified before they are appended to an internal table.

    DATA itab3 LIKE itab.

    SELECT FROM zdemo_abap_flsch
     FIELDS *              "All fields
     WHERE carrid = 'DL'
     INTO @DATA(struct3).

      "Further processing of the structure if the reading is successful
      IF sy-subrc = 0.
        "Modification: Converting miles to kilometers
        IF struct3-distid = 'MI'.
          struct3-distance = struct3-distance * '1.609344'.
          struct3-distid = 'KM'.
        ENDIF.

        "Appending structure to an internal table
        APPEND struct3 TO itab3.
      ENDIF.
    ENDSELECT.

    out->write( data = itab3 name = `itab3` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) INTO CORRESPONDING FIELDS OF: Reading into existing` &&
    ` target variables that have a line type not matching the type of the data source` ) ).

    "Note: The addition CORRESPONDING FIELDS OF is needed when using
    "an existing variable to read data into, otherwise a type
    "compatibility issue might arise because the SELECT statement fills
    "the variable from left to right beginning with the first
    "component. In the example below, the identically named fields have
    "a matching type.

    "Creating structure type, structure and internal table.
    TYPES: BEGIN OF struc_type,
             carrid   TYPE zdemo_abap_flsch-carrid,
             connid   TYPE zdemo_abap_flsch-connid,
             cityfrom TYPE zdemo_abap_flsch-cityfrom,
             cityto   TYPE zdemo_abap_flsch-cityto,
           END OF struc_type.

    DATA struc4 TYPE struc_type.
    DATA itab4 TYPE TABLE OF struc_type.

    "Reading into a structure that has not a matching type
    SELECT SINGLE FROM zdemo_abap_flsch
      FIELDS carrid, connid, cityfrom, cityto
      WHERE carrid = 'AZ' AND connid = '555'
      INTO CORRESPONDING FIELDS OF @struc4.

    "Reading into an internal table that has not a matching type
    SELECT FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'AZ'
      INTO CORRESPONDING FIELDS OF TABLE @itab4.

    out->write( data = struc4 name = `struc4` ).
    out->write( |\n| ).
    out->write( data = itab4 name = `itab4` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Clause variations and additions in SELECT statements` ) ).

    "SELECT/FROM clause variants
    out->write( |SELECT/FROM clause variants\n| ).

    out->write( |5) Checking the existence of a row in a database table\n| ).

    "Instead of @abap_true, you could also use 'X' in the example below.

    SELECT SINGLE @abap_true
     FROM zdemo_abap_flsch
     WHERE carrid = 'AZ' AND connid = '555'
     INTO @DATA(exists).

    IF exists = abap_true.
      out->write( `A line was found.` ).
    ELSE.
      out->write( `Nothing found.` ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) DISTINCT addition: Removing duplicative rows from the result set` ) ).

    "The example shows the comparison of statements with and without
    "the use of DISTINCT. When used without DISTINCT, the result
    "shows multiple entries whereas the statement with DISTINCT
    "filters the duplicates out.

    "DISTINCT addition
    SELECT DISTINCT cityfrom
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH' AND
            cityto = 'NEW YORK'
      INTO TABLE @DATA(itab_6a).

    "Similar statement not using DISTINCT
    SELECT cityfrom
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH' AND
            cityto = 'NEW YORK'
      INTO TABLE @DATA(itab_6b).

    out->write( data = itab_6a name = `itab_6a` ).
    out->write( |\n| ).
    out->write( data = itab_6b name = `itab_6b` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) SELECT list variants` ) ).

    "Example 1: All fields
    SELECT * FROM zdemo_abap_flsch
      WHERE carrid = 'JL'
      INTO TABLE @DATA(itab_7a).

    "Example 2: Selected set of fields using a comma-separated list
    SELECT carrid, connid, cityfrom, cityto  FROM zdemo_abap_flsch
      WHERE carrid = 'JL'
      INTO TABLE @DATA(itab_7b).

    "Example 3: Data source is explicitly specified;
    "the last column in the select list is purposely specified without it; not mandatory in the case below
    SELECT zdemo_abap_flsch~carrid,
           zdemo_abap_flsch~connid,
           zdemo_abap_flsch~airpfrom,
           airpto
      FROM zdemo_abap_flsch
      WHERE carrid = 'JL'
      INTO TABLE @DATA(itab_7c).

    "Example 4: Data source is explicitly specified; all fields
    SELECT zdemo_abap_flsch~*
      FROM zdemo_abap_flsch
      WHERE carrid = 'JL'
      INTO TABLE @DATA(itab_7d).

    "Example 5: Alias names defined for fields
    "Data is read into a target variable declared inline
    SELECT FROM zdemo_abap_flsch
      FIELDS carrid AS carr,
             connid AS conn,
             cityfrom AS ctyfr,
             cityto
      WHERE carrid = 'JL'
      INTO TABLE @DATA(itab_7e).

    "Example 6: Data is read from a database table into an existing
    "table but the line type does not match. The fields also have
    "different names (but the same type). Due to the use of alias
    "names, the fields are read into the corresponding fields.
    TYPES: BEGIN OF struc_type_diff,
             carr_id   TYPE zdemo_abap_flsch-carrid,
             conn_id   TYPE zdemo_abap_flsch-connid,
             city_from TYPE zdemo_abap_flsch-cityfrom,
             city_to   TYPE zdemo_abap_flsch-cityto,
           END OF struc_type_diff.

    DATA itab_7f TYPE TABLE OF struc_type_diff.

    "In the simple case below, the addition CORRESPONDING FIELDS OF is not
    "even necessary.
    SELECT FROM zdemo_abap_flsch
      FIELDS carrid   AS carr_id,
             connid   AS conn_id,
             cityfrom AS city_from,
             cityto   AS city_to
      WHERE carrid = 'AZ'
      INTO CORRESPONDING FIELDS OF TABLE @itab_7f.

    "Example 7: Alias for the data source
    SELECT ds~carrid, ds~connid
      FROM zdemo_abap_flsch AS ds
      WHERE carrid = 'JL'
      INTO TABLE @DATA(itab_7g).

    out->write( data = itab_7a name = `itab_7a` ).
    out->write( |\n| ).
    out->write( data = itab_7b name = `itab_7b` ).
    out->write( |\n| ).
    out->write( data = itab_7c name = `itab_7c` ).
    out->write( |\n| ).
    out->write( data = itab_7d name = `itab_7d` ).
    out->write( |\n| ).
    out->write( data = itab_7e name = `itab_7e` ).
    out->write( |\n| ).
    out->write( data = itab_7f name = `itab_7f` ).
    out->write( |\n| ).
    out->write( data = itab_7g name = `itab_7g` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Reading from an internal table using SELECT` ) ).

    "Note: The internal table from which to be read must be specified
    "as host variable. The internal table should have an explicitly
    "defined primary key.

    DATA itab_read1 TYPE TABLE OF zdemo_abap_flsch
      WITH NON-UNIQUE KEY mandt carrid connid.

    "Reading from database table to fill an internal table.
    SELECT FROM zdemo_abap_flsch
      FIELDS mandt, carrid, connid, cityfrom, cityto
      WHERE carrid = 'AA'
      INTO TABLE @itab_read1.

    "Reading from internal table.
    SELECT FROM @itab_read1 AS itab
      FIELDS *
      WHERE carrid = 'AA'
      INTO TABLE @DATA(itab_read2).

    out->write( data = itab_read2 name = `itab_read2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( 'INTO clause variants' ) ).
    out->write( |9) UP TO: Limiting the number of returned table rows\n\n| ).

    "Restricting the absolute number of returned table rows
    "by specifying a number n in the addition UP TO n ROWS.
    "In this case, the addition ORDER BY is also specified (but need not be specified).
    "The rows of the hit list are sorted on the database server and only the number of
    "sorted rows specified for UP TO n ROWS are passed to the result set. If the addition
    "ORDER BY is not specified, n arbitrary rows that meet the WHERE condition are passed
    "to the result set. If the ORDER BY clause does not sort the result set uniquely,
    "it is not possible to define which rows are in the result set.
    "Other examples here do not use the ORDER BY clause.

    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH'
      ORDER BY carrid
      INTO TABLE @DATA(itab_up)
      UP TO 2 ROWS.

    out->write( data = itab_up name = `itab_up` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) OFFSET: Returning only the table rows after a row with a specified count from the result set` ) ).

    "In the example, data of all flights are retrieved, except for the 2 flights
    "with the shortest flight time.
    "To compare the result sets, there is one example with and one without the addition.

    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH'
      ORDER BY fltime ASCENDING
      INTO TABLE @DATA(itab_no_off).

    out->write( data = itab_no_off name = `itab_no_off` ).
    out->write( |\n| ).

    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH'
      ORDER BY fltime ASCENDING
      INTO TABLE @DATA(itab_w_off)
      OFFSET 2.

    out->write( data = itab_w_off name = `itab_w_off` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Reading into individual elementary data objects` ) ).

    "The field list and the INTO list must have the
    "same number of elements.
    "In the example, a structure and internal table are created
    "to process the individually read fields within a SELECT loop.

    "Structure and internal table to include the read result
    DATA struct_ind TYPE struc_type.

    DATA itab_ind TYPE TABLE OF struc_type.

    SELECT FROM zdemo_abap_flsch
      FIELDS carrid, connid, cityfrom, cityto
      WHERE carrid = 'JL'
      INTO (@DATA(carr_id),@DATA(conn_id),@DATA(city_from),
            @DATA(city_to)).

      IF sy-subrc = 0.
        "Filling structure components with the individual values
        struct_ind = VALUE #( carrid   = carr_id
                              connid   = conn_id
                              cityfrom = city_from
                              cityto   = city_to ).

        "Appending structure to internal table
        APPEND struct_ind TO itab_ind.
      ENDIF.
    ENDSELECT.

    out->write( data = itab_ind name = `itab_ind` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Appending the result set to an existing internal table` ) ).

    "APPEDNING TABLE

    "In the example, the existing internal table has the same line type
    "as the database table. The internal table from the previous
    "example is used to have a table with entries.

    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'JL'
      APPENDING TABLE @itab_up.

    out->write( data = itab_up name = `itab_up` ).
    out->write( |\n| ).

    "APPENDING CORRESPONDING FIELDS OF TABLE

    "In the example, the existing internal table has not a matching
    "line type as the database table. First, an internal table table
    "is filled using the INTO CORRESPONDING ... addition. Then, a
    "statement with an APPENDING CORRESPONDING ... addition ensures
    "that the existing content is kept and the target variable
    "receives the read data in the corresponding fields.

    DATA itab_corr TYPE TABLE OF struc_type.

    "INTO CORRESPONDING FIELDS OF: Filling internal table anew
    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH'
      INTO CORRESPONDING FIELDS OF TABLE @itab_corr
      UP TO 2 ROWS.

    "APPENDING CORRESPONDING FIELDS OF: Adding to existing table lines
    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'JL'
      APPENDING CORRESPONDING FIELDS OF TABLE @itab_corr.

    out->write( data = itab_corr name = `itab_corr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Reading into packages of a specified number of rows` ) ).

    "After PACKAGE SIZE, the number of rows is specified denoting the number
    "of rows to be inserted in the target object per iteration The internal
    "table that is displayed shows all entries, i.e. all packages. Furthermore,
    "a string table is filled and displayed to visualize the package size of each
    "internal table per iteration.

    DATA itab_pack TYPE TABLE OF zdemo_abap_flsch.

    DATA pack_table TYPE string_table.

    SELECT FROM zdemo_abap_flsch
      FIELDS carrid, connid, cityfrom, cityto
      WHERE carrid <> 'AZ' AND carrid <> 'DL'
      INTO TABLE @DATA(itab_package)
      PACKAGE SIZE 3.

      IF sy-subrc = 0.
        APPEND |Internal table lines processed: | &&
               |{ lines( itab_package ) }| TO pack_table.

        "Adding internal table content to another internal table
        itab_pack = CORRESPONDING #( BASE ( itab_pack )
                                     itab_package ).
      ENDIF.
    ENDSELECT.

    out->write( data = pack_table name = `pack_table` ).
    out->write( |\n| ).
    out->write( data = itab_pack name = `itab_pack` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) Specifying an anonymous data object as target object` ) ).

    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH'
      INTO TABLE NEW @DATA(dref)
      UP TO 2 ROWS.

    out->write( data = dref->* name = `dref->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Excursion: ABAP SQL - Operands and Expressions` ) ).
    out->write( |15) SQL operands\n\n| ).

    "SQL operands are elementary operands in an ABAP SQL statement.
    "Can be database table or view columns, a literal, host variables
    "(i. e. global or local data objects escaped using @) or host
    "expressions (@( ... )).
    "The literals can be typed (using the type name and content within
    "a pair of backquotes: char`abc`) with built-in ABAP Dictionary
    "types or untyped.
    "Regarding host expressions: Structures and internal tables are
    "possible as host expressions for statements modifying the content
    "of database tables as shown further down.
    "The example below demonstrates possible operands.

    DATA upto TYPE i VALUE 3.

    SELECT FROM zdemo_abap_flsch
    FIELDS
    "Specifies a column of a data source directly using its name
     cityfrom,

     "Column selector ~ can be used to prefix every specified column.
     "Here, it is optional. It is non-optional, e. g., if multiple data
     "sources in an ABAP SQL statement are edited and the column name
     "is not unique.
     zdemo_abap_flsch~cityto,

     'Lufthansa' AS name, "Untyped literal

     char`X` AS flag, "Typed literal

     @upto AS num, "Host variable

     @( cl_abap_context_info=>get_system_date( ) ) AS date "Host expression

    WHERE carrid = 'LH'        "Untyped literal
      AND countryfr = char`DE` "Typed literal

    "Data object created inline and escaped with @
    INTO TABLE @DATA(sql_operands)

    "The following shows all options having the same effect
    UP TO 3 ROWS.         "Untyped numeric literal
    "UP TO int4`3` ROWS.  "Typed numerice literal
    "UP TO @upto ROWS.    "Host variable
    "UP TO @( 10 - 7 ) ROWS. "Host expression

    out->write( data = sql_operands name = `sql_operands` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Numeric functions ` ) ).

    "You can use built-in functions in ABAP SQL.
    "Result: Value with the associated dictionary type.
    "Arguments of the functions: Cover one or more SQL expressions.

    SELECT SINGLE
       carrname,

       "Division, result rounded to an integer
       div( 4, 2 ) AS div,

       "Division, 3rd argument: result is rounded to the specified
       "number of decimals
       division( 1, 3, 2 ) AS division,

       "Result is rounded to first greater integer
       ceil( decfloat34`1.333` ) AS ceil,

       "Result is the remainder of division
       mod( 3, 2 ) AS mod,

       "Result: Largest integer value not greater than the specified
       "value
       floor( decfloat34`1.333` ) AS floor,

       "Returns the absolute number
       abs( int4`-2` ) AS abs,

       "Result is rounded to the specified position after the decimal
       "separator
       round( decfloat34`1.337`, 2 ) AS round
       FROM zdemo_abap_carr
       WHERE carrid = 'AA'
       INTO @DATA(numeric_functions).

    out->write( data = numeric_functions name = `numeric_functions` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) String functions` ) ).

    SELECT SINGLE
     carrid,  "LH
     carrname, "Lufthansa
     url, "http://www.lufthansa.com

     "Concatenates strings, ignores trailing blanks
     concat( carrid, carrname ) AS concat,

     "Concatenates strings, number denotes the blanks that are inserted
     concat_with_space( carrid, carrname, 1 ) AS concat_with_space,

     "First letter of a word -> upper case, all other letters ->
     "lower case; note that a space and other special characters means
     "a new word.
     initcap( url ) AS initcap,

     "Position of the first occurrence of the substring specified
     instr( carrname,'a' ) AS instr,

     "String of length n starting from the left of an expression;
     "trailing blanks are ignored
     left( carrname, 4 ) AS left,

     "Number of characters in an expression, trailing blanks are
     "ignored
     length( url ) AS length,

     "Checks if expression contains a PCRE expression;
     "case-sensitive by default (case_sensitive parameter can be
     "specified)
     "Notes on the result: 1 = found, 0 = not found
     "PCRE below: Searches a period that is followed by any character
     like_regexpr( pcre  = '\..',
                   value = url ) AS like_regex,

     "Returns position of a substring in an expression,
     "3rd parameter = specifies offset (optional)
     "4th parameter = determines the number of occurrences (optional)
     locate( carrname, 'a', 0, 2 ) AS locate,

     "Searches a PCRE pattern, returns offset of match;
     "many optional parameters: occurrence, case_sensitive, start,
     "group
     locate_regexpr( pcre = '\..', "Period followed by any character
                     value = url,
                     occurrence = 2 ) "2nd occurrence in the string
                     AS locate_regexpr,

     "Searches a PCRE pattern, returns offset of match + 1;
     "many optional parameters: occurrence, case_sensitive, start,
     "group
     locate_regexpr_after( pcre = '.',  "Any character
                           value = url,
                           occurrence = 1 ) AS locate_regexpr_after,

     "Removes leading characters as specified in the 2nd argument,
     "trailing blanks are removed
     ltrim( carrname, 'L' ) AS ltrim,

     "Counts all occurrences of found PCRE patterns
     occurrences_regexpr( pcre = '\..',
                          value = url ) AS occ_regex,

     "Replaces the 2nd argument with the 3rd in an expression
     replace( carrname,'a','#' ) AS replace,

     "Replaces a found PCRE expression;
     "more parameters possible: occurrence, case_sensitive, start
     replace_regexpr( pcre = '\..',
                      value = url,
                      with = '#' ) AS replace_regex,

     "Extracts a string with the length specified starting from the
     "right
     right( carrname, 5 ) AS right,

     "Expands string to length n (2nd argument); trailing blanks
     "produced are replaced by the characters from the (3rd) argument
     "Note that if n is less than the string, the expression is
     "truncated on the right.
     rpad( carrname, 12, '#' ) AS rpad,

     "All trailing characters that match the character of the 2nd
     "argument are removed; trailing blanks are removed, too
     rtrim( carrname, 'a' ) AS rtrim,

     "Returns a substring; 2nd argument = position from where to start;
     "3rd argument: length of the extracted substring
     substring( carrname, 3, 3 ) AS substring,

     "Searches for a PCRE expression and returns the matched substring
     "More parameters possible: occurrence, case_sensitive, start, group
     substring_regexpr( pcre = '\...',
                        value = url ) AS substring_regexpr,

     "All lower case letters are transformed to upper case letters
     upper( carrname ) AS upper
     FROM zdemo_abap_carr
     WHERE carrid = 'LH'
     INTO @DATA(string_functions).

    out->write( data = string_functions name = `string_functions` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18a) Special functions` ) ).

    SELECT SINGLE
      carrid,

      "Conversion functions
      "When used: Special conversions that cannot be handled in a
      "general CAST expression

      "Type conversion: string of fixed length (e.g. of type c) to
      "variable length string of type string
      to_clob( carrid ) AS clob,

      "Byte string -> character string
      bintohex( raw`3599421128650F4EE00008000978B976` ) AS bintohex,

      "Character string -> byte string
      hextobin( char`3599421128650F4EE00008000978B976` ) AS hextobin,

      "Byte field of type RAW to a byte string (BLOB) of type RAWSTRING
      to_blob( raw`3599421128650F4EE00008000978B976` ) AS blob,

      "Unit conversion function
      "More parameters are available.

      "Converts miles to kilometers
      unit_conversion( quantity = d34n`1`,
                       source_unit = unit`MI`,
                       target_unit = unit`KM` ) AS miles_to_km,

      "Date and time functions
      "There are plenty of functions; the below functions are a
      "selection.

      add_days( @( cl_abap_context_info=>get_system_date( ) ), 4
              ) AS add_days,
      add_months( @( cl_abap_context_info=>get_system_date( ) ), 2
              ) AS add_months,
      is_valid( @( cl_abap_context_info=>get_system_date( ) ) ) AS date_is_valid,
      is_valid( @( cl_abap_context_info=>get_system_time( ) ) ) AS time_is_valid

     FROM zdemo_abap_carr
     WHERE carrid = 'AA'
     INTO @DATA(special_functions).

    "Retrieving type information using RTTI to demonstrate the effect
    "of type conversions like to_clob etc.
    "type_kind: g (character string with variable length),
    "C (character string of fixed length), X (binary), y (byte string)
    DATA(components) = CAST cl_abap_structdescr(
     cl_abap_typedescr=>describe_by_data( special_functions )
      )->components.

    out->write( data = components name = `components` ).
    out->write( |\n| ).
    out->write( data = special_functions name = `special_functions` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18b) coalesce Function` ) ).

    "The null value is a special value that is returned by a database. It indicates an
    "undefined value or result. Note that, in ABAP, there are no special null values. Do
    "not confuse the null value with a type-dependent initial value. When using SELECT
    "statements to read data, null values can be produced by, for example, outer joins.
    "When the null values are passed to a data object, they are transformed to the
    "type-dependent initial values. For more information, refer to the ABAP Keyword Documentation.
    "The following example uses a left outer join to intentionally create null values. For
    "this purpose, two demo database tables of the ABAP cheat sheet repository are cleared and
    "populated with specific values to visualize null values.
    DELETE FROM zdemo_abap_tab1.
    DELETE FROM zdemo_abap_tab2.
    MODIFY zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 char1 = 'a' char2 = 'y' )
                                                  ( key_field = 2 char1 = 'b' char2 = 'z' ) ) ).
    MODIFY zdemo_abap_tab2 FROM TABLE @( VALUE #( ( key_field = 1 char1 = 'a' )
                                                  ( key_field = 2 char1 = 'a' )
                                                  ( key_field = 3 char1 = 'b' )
                                                  ( key_field = 4 ) ) ).

    "Note that for the entry 'key_field = 4' no char1 value was passed.
    "char1 is a shared column of the two database tables, and which is used in
    "the ON condition of the join. Since there is no entry in char1 for 'key_field = 4',
    "the joined values are null in that case.
    "The coalesce function is used to replace null values produced by an outer join with
    "a different value.
    SELECT tab2~key_field,
           coalesce( tab1~char1, '-' ) AS coalesced1,
           coalesce( tab1~char2, '#' ) AS coalesced2,
           "A coalesce function is a short form of a complex
           "case distinction such as the following:
           CASE WHEN tab1~char1 IS NOT NULL THEN tab1~char1
            ELSE '?'
           END AS coalesced3

        FROM zdemo_abap_tab2 AS tab2
        LEFT OUTER JOIN zdemo_abap_tab1 AS tab1 ON tab1~char1 = tab2~char1
        INTO TABLE @DATA(join_w_null).

    out->write( data = join_w_null name = `join_w_null` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) Aggregate Expressions` ) ).

    "Consist of aggregate functions and aggregate the values of
    "multiple rows of the result set of a query into a single value.
    "The example shows a selection of available functions.

    SELECT
     carrid,

     "Average value of the content of a column in a row set
     AVG( fltime ) AS fltime1,

     "AVG with data type specification for the result
     AVG( fltime AS DEC( 14,4 ) ) AS fltime2,

     "Maximum value of the results in a row set
     MAX( fltime ) AS max,

     "Minimum value
     MIN( fltime ) AS min,

     "Sum of the results in a row set.
     SUM( fltime ) AS sum,

     "Returns the number of rows in a row set.
     "The following two have the same meaning.
     COUNT( * ) AS count2,
     COUNT(*) AS count3,

     "Chains the results in a row set.
     "An optional separator can be specified
     STRING_AGG( airpfrom, ', ' ) AS string_agg

     FROM zdemo_abap_flsch
     WHERE carrid = 'LH'
     GROUP BY carrid
     INTO TABLE @DATA(agg_exp).

    out->write( data = agg_exp name = `agg_exp` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20a) Arithmetic Expressions` ) ).

    SELECT SINGLE
    carrid,

    "Arithmethic expressions
    "operators + - *
    "Note that / is not allowed in integer expressions as the one below
    ( 1 + 2 ) * 3 AS calc,

    "/ used in an expression using type adjustment in ABAP SQL.
    "A cast expression converts the value of the operands to the
    "specified dictionary type. The result is a representation of the
    "source value in the specified type.
    CAST( 1 AS D34N ) / CAST( 2 AS D34N ) AS ratio

  FROM zdemo_abap_carr
  WHERE carrid = 'AA'
  INTO @DATA(arithmetic_sql_expr).

    out->write( data = arithmetic_sql_expr name = `arithmetic_sql_expr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20b) Cast Expressions` ) ).

    SELECT SINGLE
        carrid,

        "A cast expression converts the value of the operands to the
        "specified dictionary type. The result is a representation of the
        "source value in the specified type.
        CAST( 1 AS D34N ) / CAST( 2 AS D34N ) AS ratio,
        CAST( connid AS INT4 ) AS connidnum,
        CAST( @( cl_abap_context_info=>get_system_date( ) ) AS CHAR ) AS dat

    FROM zdemo_abap_fli
    WHERE carrid = 'AA'
    INTO @DATA(cast_expr).

    out->write( data = cast_expr name = `cast_expr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20c) String Expressions` ) ).

    SELECT SINGLE
        carrid,

        "String expression using && to concatenate two character strings;
        "the result of the concatenation must not be longer than
        "255 characters.
        carrid && char`_` && carrname AS concat

    FROM zdemo_abap_carr
    WHERE carrid = 'AA'
    INTO @DATA(string_expr).

    out->write( data = string_expr name = `string_expr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20d) Case Expressions` ) ).

    SELECT SINGLE
      carrid,

      "Simple case distinction
      "The expression compares the values of an operand with other
      "operands. Result: The first operand after THEN for which the
      "comparison is true. If no matches are found, the result specified
      "after ELSE is selected.
      CASE currcode
        WHEN 'EUR' THEN 'A'
        WHEN 'USD' THEN 'B'
        ELSE 'C'
      END AS case_simple,

      "Complex case distinction
      "The expression evaluates logical expressions. Result: The first
      "operand after THEN for which the logical expression is true. If no
      "logical expressions are true, the result specified after ELSE is
      "selected.
      CASE WHEN length( carrname ) <= 5 THEN 'small'
           WHEN length( carrname ) BETWEEN 6 AND 10 THEN 'mid'
           WHEN length( carrname ) BETWEEN 11 AND 15 THEN 'large'
           ELSE 'huge'
      END AS case_complex

    FROM zdemo_abap_carr
    WHERE carrid = 'AA'
    INTO @DATA(case_expr).

    out->write( data = case_expr name = `case_expr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20e) Null Expressions` ) ).

    SELECT
    carrid,
    carrname,
    "The type of the null value is determined by the context.
    "When the null value is passed to the internal table,
    "it is converted to the initial value. In the first case,
    "it is ' '. In the second case, it is 0..
    CASE WHEN length( carrname ) > 12 THEN char`X`
      ELSE NULL
    END AS long_name,
    CAST( NULL AS INT1 ) AS null_val

FROM zdemo_abap_carr
INTO TABLE @DATA(null_expr).

    out->write( data = null_expr name = `null_expr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) Window expressions (1)` ) ).

    "A simple window is constructed in the OVER clause,
    "window functions - here aggregate functions - are applied.
    "To narrow the entries in the resulting table, duplicates
    "are deleted.

    SELECT carrid, currency,
     SUM( paymentsum ) OVER( PARTITION BY carrid ) AS sum,
     AVG( price AS DEC( 14,2 ) ) OVER( PARTITION BY carrid ) AS avg,
     MAX( price ) OVER( PARTITION BY carrid ) AS max
     FROM zdemo_abap_fli
     ORDER BY carrid
     INTO TABLE @DATA(win).

    DELETE ADJACENT DUPLICATES FROM win COMPARING ALL FIELDS.

    out->write( data = win name = `win` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Window expressions (2)` ) ).

    SELECT carrid, currency, fldate,
      "Sorts the rows by some columns and counts the number of rows from
      "the first row of the window to the current row.
      COUNT( * ) OVER( ORDER BY currency, fldate
                        ROWS BETWEEN
                        "UNBOUNDED PRECEDING: frame starts at the
                        "first row of the window
                        UNBOUNDED PRECEDING
                        "CURRENT ROW: determines starting or ending
                        "at the current row; here, it ends
                        AND CURRENT ROW ) AS count1,

      "If no window frame is used, the default window frame is
      "BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW,
      "i. e. the result of count1 equals count2
      COUNT( * ) OVER( ORDER BY currency, fldate ) AS count2,

      "Sorts the rows by some columns and counts the number of rows from
      "the current row to the last row of the window.
      "The result is reverse numbering.
      COUNT( * ) OVER( ORDER BY currency, fldate
                       ROWS BETWEEN CURRENT ROW
                       "UNBOUND FOLLOWING:
                       "Determines the ending frame boundary,
                       "this addition specifies the last row of the
                       "window
                       AND UNBOUNDED FOLLOWING ) AS count_reverse,

      "Sorts the rows by some columns and calculates the rolling
      "averages of a subset of rows from column price. The subset
      "consists of the current row plus one preceding and one following
      "row. A better use case as below example would be that, for
      "example, you can calculate the 3-day-average temperature for
      "every day from a list of temperature data.
      AVG( price AS DEC( 14,2 ) ) OVER( ORDER BY currency, fldate
           ROWS BETWEEN
           "n PRECEDING: for both start and end of frame;
           "frame to start/end n rows above the current row
           1 PRECEDING
           "n FOLLOWING: for both start and end of frame;
           "frame to start/end n rows beneath the current row
           AND 1 FOLLOWING ) AS avg

      FROM zdemo_abap_fli
      INTO TABLE @DATA(win_order).

    out->write( data = win_order name = `win_order` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `SQL conditions` ) ).
    out->write( |23) SQL conditions (1)\n\n| ).
    "The example demonstrates a WHERE clause with =, >, <, <=, >=, AND

    SELECT * FROM zdemo_abap_fli
          WHERE carrid = 'LH'    "or EQ
            AND price > 700      "or GT
            AND seatsocc < 320   "or LT
            AND seatsmax <= 330  "or LE
            AND seatsmax_b >= 30 "or GE
          INTO TABLE @DATA(itab_comp_op).

    out->write( data = itab_comp_op name = `itab_comp_op` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) SQL conditions (2)` ) ).

    "The example demonstrates a WHERE clause with
    "BETWEEN, NOT BETWEEN, OR

    SELECT * FROM zdemo_abap_fli
      WHERE seatsmax BETWEEN 350 AND 400            "#EC CI_CMPLX_WHERE
         OR price NOT BETWEEN 100 AND 1500
      INTO TABLE @DATA(it_sql_cond).

    out->write( data = it_sql_cond name = `it_sql_cond` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) SQL conditions (3)` ) ).

    "The example demonstrates a WHERE clause with character literals:
    "- LIKE '%FRAN%': Condition is true if the column cityfrom contains
    "  a string containing the pattern 'FRAN'
    "- NOT LIKE '_X%': Condition is true if the column airpto contains
    "  a value whose second character is not 'X'.
    "- IN ( ... ): condition is true if the column cityto contains
    "  one of the values specified within the brackets
    "- NOT IN ( ... ): condition is true if the column cityto does not
    "  contain one of the values specified within the brackets
    SELECT * FROM zdemo_abap_flsch
      WHERE cityfrom LIKE '%FRAN%'
        AND airpto NOT LIKE '_X%'
        AND cityto IN ( 'BERLIN', 'NEW YORK', 'LONDON' )
        AND cityto NOT IN ( 'SYDNEY' )
      INTO TABLE @DATA(itab_like_in).


    out->write( data = itab_like_in name = `itab_like_in` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25b) SQL conditions (4)` ) ).

    "---- SQL conditions demonstrated with the WHERE clause ----
    "Note:
    "- For most of the self-contained examples, an internal table is used as the
    "  data source of SELECT statements to work with simple data.
    "- For some examples that are covered, such as subqueries, demo database tables
    "  from the cheat sheet repository are used in addition.
    "- Dynamic specifications are also possible. They are not covered here. See
    "  the Dynamic Programming cheat sheet.

    "---- Types and internal table to work with in the examples ----
    "Note: You cannot use type string columns in WHERE conditions.
    TYPES: BEGIN OF demo_struc,
             id   TYPE i,
             name TYPE c LENGTH 15,
             "name TYPE string,
           END OF demo_struc.
    DATA itab_sql_cond TYPE SORTED TABLE OF demo_struc WITH UNIQUE KEY id.
    "Populating internal table with data to work with in the examples
    itab_sql_cond = VALUE #( ( id = 1 name = 'bear' )
                    ( id = 2 name = 'camel' )
                    ( id = 3 name = 'rabbit' )
                    ( id = 4 name = 'zebra' )
                    ( id = 5 name = 'dog' )
                    ( id = 6 name = 'deer' )
                    ( id = 7 name = 'squirrel' )
                    ( id = 8 name = 'cheetah' )
                    ( id = 9 name = 'elephant' )
                    ( id = 10 name = 'donkey' )
                    ( id = 11 name = 'fish' )
                    ( id = 12 name = 'sheep' ) ).

    "---- =, <>, >, >= (as a selection of possible comparison operators) ----
    SELECT id FROM @itab_sql_cond AS tab WHERE name = 'bear' INTO TABLE @DATA(it).
    SELECT id FROM @itab_sql_cond AS tab WHERE name <> 'bear' INTO TABLE @it.
    SELECT id FROM @itab_sql_cond AS tab WHERE id > 10 INTO TABLE @it.
    SELECT id FROM @itab_sql_cond AS tab WHERE id >= 10 INTO TABLE @it.

    "---- Combining logical expressions using AND, OR and parentheses  ----
    SELECT id FROM @itab_sql_cond AS tab WHERE id = 1 AND name = 'bear' INTO TABLE @it.
    SELECT id FROM @itab_sql_cond AS tab WHERE name = 'bear' OR name = 'sheep' INTO TABLE @it.

    "In the following example, the resulting table is initial. One of the expressions
    "in parentheses is false (AND is used between the expressions in parentheses).
    "In contrast, the example below returns an entry because of using OR.
    SELECT id FROM @itab_sql_cond AS tab
      WHERE ( id = 1 AND name = 'bear' )
      AND ( id = 20 AND name = 'camel' )
      INTO TABLE @it.

    SELECT id FROM @itab_sql_cond AS tab
      WHERE ( id = 1 AND name = 'bear' )
      OR ( id = 20 AND name = 'camel' )
      INTO TABLE @it.

    "------------------------ [NOT] BETWEEN ------------------------
    SELECT id FROM @itab_sql_cond AS tab WHERE id BETWEEN 1 AND 4 INTO TABLE @it.
    "The condition with BETWEEN above corresponds to the following condition.
    "The example makes use of a condition specified in parentheses to combine multiple
    "expressions.
    SELECT id FROM @itab_sql_cond AS tab WHERE ( id >= 1 AND id <= 4 ) INTO TABLE @it.
    "Negation with NOT
    SELECT id FROM @itab_sql_cond AS tab WHERE id NOT BETWEEN 1 AND 4 INTO TABLE @it.

    "------------------------ IS [NOT] INITIAL ------------------------
    SELECT id FROM @itab_sql_cond AS tab WHERE id IS NOT INITIAL INTO TABLE @it.

    SELECT id FROM @itab_sql_cond AS tab WHERE id IS INITIAL INTO TABLE @it.

    "------------------------ [NOT] LIKE ------------------------
    "For (not) matching a specified pattern
    "Note: % (any character string), _ (any character).
    SELECT name FROM @itab_sql_cond AS tab
      WHERE name LIKE '%ee%'
      OR name LIKE '_o%'
      INTO TABLE @DATA(names). "dog,deer,cheetah,donkey,sheep

    SELECT name FROM @itab_sql_cond AS tab
      WHERE name NOT LIKE '%ee%'
      INTO TABLE @names.

    "ESCAPE addition for defining a single-character escape character
    "In the following example, this character is #. It is placed before
    "the % character in the specification after LIKE. In this case, %
    "is escaped and does then not stand for any character string in the
    "evaluation.
    "Adding a table entry for this syntax example.
    itab_sql_cond = VALUE #( BASE itab_sql_cond ( id = 13 name = '100%' ) ).
    "Any character sequence followed by the % character
    SELECT name FROM @itab_sql_cond AS tab
      WHERE name LIKE '%#%' ESCAPE '#'
      INTO TABLE @names.

    "Deleting the entry because it is not relevant for the further examples.
    DELETE itab_sql_cond INDEX 13.

    "------------------------ [NOT] IN (using a value set) ------------------------
    "For (not) matching a value in a set of values specified in parentheses.

    "Single operands on the left side of IN
    SELECT id FROM @itab_sql_cond AS tab
      WHERE name IN ( 'camel', 'rabbit', 'dog', 'snake' )
      INTO TABLE @it.

    "Negation NOT IN; note to use host variables/expressions for local/global data objects
    DATA(animal) = 'sheep'.
    SELECT id FROM @itab_sql_cond AS tab
      WHERE name NOT IN ( 'fish', @animal )
      INTO TABLE @it.

    "Operand list (a parenthesized comma-separated list) on the left side of IN
    "For (not) matching value tuples from a set of value tuples specified in parentheses on the right side.
    "In the following example, two values are specified in the operand list on the left. Consequently,
    "two values with appropriate types must be specified in parentheses on the right.
    SELECT id FROM @itab_sql_cond AS tab
      WHERE ( id, name ) IN ( ( 1, 'bear' ), ( 3, 'rabbit' ), ( 8, 'zebra' ), ( 20, 'dog' ) )
      INTO TABLE @it.


    "------------------------ [NOT] IN (using a subquery) ------------------------
    "[NOT] IN for matching a value contained in the result set of a subquery

    "In the following example, the subquery reads data from a demo database table.
    "For a representative result, the table is cleared, and then filled with 'suitable'
    "data sets.
    DELETE FROM zdemo_abap_tab1.
    MODIFY zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 11 num1 = 11 )
                                                  ( key_field = 12 num1 = 12 )
                                                  ( key_field = 13 num1 = 13 )
                                                  ( key_field = 14 num1 = 14 ) ) ).

    SELECT id FROM @itab_sql_cond AS tab
      WHERE id IN ( SELECT key_field FROM zdemo_abap_tab1 ) INTO TABLE @it.

    "------------------------ [NOT] IN (using a ranges table) ------------------------
    "[NOT] IN for checking whether the operands on the left side match a ranges condition in a ranges table

    "Declaring a ranges table
    DATA rangestab TYPE RANGE OF i.
    "Populating a ranges table using the VALUE operator
    rangestab = VALUE #( ( sign   = 'I' option = 'BT' low = 1 high = 3 )
                         ( sign   = 'I' option = 'GE' low = 10  ) ).

    SELECT id FROM @itab_sql_cond AS tab WHERE id IN @rangestab INTO TABLE @it.


    "You cannot use logical operators such as CP (conforms to pattern) in the WHERE clause.
    "In a ranges table, they are possible.
    "Note:
    "- Regarding CP: * (any character sequence), + (any character), # (escape character)
    "- An equivalent example above uses the LIKE addition.
    DATA rt TYPE RANGE OF demo_struc-name.
    rt = VALUE #( ( sign   = 'I' option = 'CP' low = '*ee*' ) "ee in a string
                  ( sign   = 'I' option = 'CP' low = '+o*' ) ). "o in second position
    SELECT name FROM @itab_sql_cond AS tab
      WHERE name IN @rt
      INTO TABLE @names.

    "------------------------ EXISTS ------------------------
    "For checking the result set of a subquery.
    "The following example reads all entries from the internal table if entries having
    "the same key also exist in the database table.
    "Note: The SELECT list in the subquery only contains a literal to determine that
    "the entry exists. Specifying explicit column names is not relevant.
    SELECT id FROM @itab_sql_cond AS tab WHERE
      EXISTS ( SELECT @abap_true FROM zdemo_abap_tab1 WHERE key_field = tab~id )
      INTO TABLE @it.

    "------------------------ IS [NOT] NULL ------------------------
    "The null value is a special value that is returned by a database. It indicates an
    "undefined value or result. Note that, in ABAP, there are no special null values. Do
    "not confuse the null value with a type-dependent initial value. When using SELECT
    "statements to read data, null values can be produced by, for example, outer joins.
    "When the null values are passed to a data object, they are transformed to the
    "type-dependent initial values. For more information, refer to the ABAP Keyword Documentation.
    "The following example uses a left outer join to intentionally create null values. For
    "this purpose, two demo database tables of the cheat sheet repository are cleared and
    "populated with specific values to visualize null values.
    DELETE FROM zdemo_abap_tab1.
    DELETE FROM zdemo_abap_tab2.
    MODIFY zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 char1 = 'a' char2 = 'y' )
                                                  ( key_field = 2 char1 = 'b' char2 = 'z' ) ) ).
    MODIFY zdemo_abap_tab2 FROM TABLE @( VALUE #( ( key_field = 1 char1 = 'a' )
                                                  ( key_field = 2 char1 = 'a' )
                                                  ( key_field = 3 char1 = 'b' )
                                                  ( key_field = 4 ) ) ).

    "Note that for the entry 'key_field = 4' no char1 value was passed.
    "char1 is a shared column of the two database tables, and which is used in
    "the ON condition of the join. Since there is no entry in char1 for 'key_field = 4',
    "the joined values are null in that case. The WHERE clause uses the addition IS NULL.
    "Therefore, the result only contains this entry. char2 is assigned the type-initial
    "value in the result.
    SELECT tab2~key_field, tab1~char2
        FROM zdemo_abap_tab2 AS tab2
        LEFT OUTER JOIN zdemo_abap_tab1 AS tab1 ON tab1~char1 = tab2~char1
        WHERE tab1~char1 IS NULL
        INTO TABLE @DATA(joined_tab).

    "The following example visualizes the null values. The INDICATORS addition of the
    "INTO clause is used to specify indicators such as the null indicator. In the
    "example, an appropriate target table is defined to also store information about
    "which columns of the result set contain the null value and which do not.
    "For more information on the syntax, refer to the ABAP Keyword Documentation.
    TYPES: BEGIN OF st4null,
             BEGIN OF s2,
               key_field TYPE zdemo_abap_tab2-key_field,
               char2     TYPE zdemo_abap_tab1-char2,
             END OF s2,
             BEGIN OF nulls,
               key_field TYPE c LENGTH 1,
               char2     TYPE c LENGTH 1,
             END OF nulls,
           END OF st4null.
    DATA joined_tab_w_null_ind TYPE TABLE OF st4null WITH EMPTY KEY.

    SELECT tab2~key_field, tab1~char2
      FROM zdemo_abap_tab2 AS tab2
      LEFT OUTER JOIN zdemo_abap_tab1 AS tab1 ON tab1~char1 = tab2~char1
      INTO TABLE @joined_tab_w_null_ind INDICATORS NULL STRUCTURE nulls.

    "Negation IS NOT NULL
    SELECT tab2~key_field, tab1~char2
      FROM zdemo_abap_tab2 AS tab2
      LEFT OUTER JOIN zdemo_abap_tab1 AS tab1 ON tab1~char1 = tab2~char1
      WHERE tab1~char1 IS NOT NULL
      INTO TABLE @joined_tab.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Further clauses in SELECT statements` ) ).

    out->write( |26) GROUP BY: Combining groups of table rows in the result set\n\n| ).
    "In the example, the database table rows that have the same content
    "in column CARRID are combined. The lowest and highest values in
    "column PRICE are determined for each of these groups and placed
    "into the combined row. Note that the GROUP BY clause requires all
    "columns that are directly specified in the SELECT list or
    "specified there as an argument of an SQL expression to be
    "specified. Aggregate functions in aggregate expressions are an
    "exception, as shown below.

    SELECT FROM zdemo_abap_fli
      FIELDS carrid,
             MIN( price ) AS min_price,
             MAX( price ) AS max_price
      GROUP BY carrid
      INTO TABLE @DATA(itab_gr).

    out->write( data = itab_gr name = `itab_gr` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `27) HAVING: Limiting the number of rows` &&
    ` in groups in the result set` ) ).

    "The addition HAVING limits the number of rows in groups in the
    "result set of a query by using a logical expression on these rows.
    "The logical expression evaluates the content of row groups. Those
    "rows are placed in the result set for which the logical expression
    "is true.

    SELECT FROM zdemo_abap_flsch
      FIELDS carrid, connid, cityfrom, cityto
      WHERE carrid = 'LH'
      GROUP BY carrid, connid, cityfrom, cityto
      HAVING SUM( fltime ) > 100
      INTO TABLE @DATA(itab_hav).

    out->write( data = itab_hav name = `itab_hav` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `28) ORDER BY: Sorting the result set by ` &&
    `specified columns` ) ).

    "The following example shows the ordering of the result set based
    "on the content of the primary key of the data source. You can also
    "order by any columns and by explicitly specifying the sort order.
    "There are more options to order, for example, by using SQL
    "expressions.

    "Example 1: Sorting the result set by primary key
    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid <> 'UA'
      ORDER BY PRIMARY KEY
      INTO TABLE @DATA(itab_ord1)
      UP TO 3 ROWS.

    "Example 2: Sorting by arbitrary field and specifying the sort order
    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid <> 'UA'
      ORDER BY fltime DESCENDING
      INTO TABLE @DATA(itab_ord2)
      UP TO 3 ROWS.

    out->write( data = itab_ord1 name = `itab_ord1` ).
    out->write( |\n| ).
    out->write( data = itab_ord2 name = `itab_ord2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `WHERE clause variants: Selecting data by evaluating the content of other tables` ) ).
    out->write( |29) FOR ALL ENTRIES addition\n\n| ).

    "In the example, only those entries should be read from the
    "database table if entries exist in the internal table that meet
    "the conditions specified in the WHERE clause. Note that you should
    "ensure that the internal table is not initial.
    "Check the ABAP Keyword Documentation for various restrictions that
    "apply when using this addition. The following example is just for
    "demonstrating the syntax - as are all examples.

    "Filling an internal table
    SELECT * FROM zdemo_abap_fli
      WHERE seatsmax < 300
      INTO TABLE @DATA(cond_tab).

    IF ( 0 < lines( cond_tab ) ).
      SELECT carrid, connid, cityfrom, cityto      "#EC CI_NO_TRANSFORM
        FROM zdemo_abap_flsch
        FOR ALL ENTRIES IN @cond_tab
        WHERE carrid = @cond_tab-carrid
        AND connid = @cond_tab-connid
        INTO TABLE @DATA(itab_forall).
    ENDIF.

    out->write( data = itab_forall name = `itab_forall` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `30) Checking the result set of a subquery` ) ).

    "In the example, all available flights leaving from a city with
    "FRAN in the name (San Francisco, Frankfurt) existing in another
    "database table and for which further comparisons are true
    "(matching CARRID and CONNID) are read into an internal table.

    SELECT carrid, connid, fldate
      FROM zdemo_abap_fli AS zdemo_abap_fli
      WHERE EXISTS
      ( SELECT carrid FROM zdemo_abap_flsch
          WHERE carrid = zdemo_abap_fli~carrid
          AND connid = zdemo_abap_fli~connid
          AND cityfrom LIKE '%FRAN%' )
      ORDER BY carrid, connid, fldate
      INTO TABLE @DATA(itab_sub).

    out->write( data = itab_sub name = `itab_sub` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Combining Data of Multiple Database Tables` ) ).
    out->write( |31) Inner join\n\n| ).
    "Result set:
    "- Columns of the rows in the result set of the left side with the columns
    "  of the rows in the result set of the right side are joined into a single
    "  result set.
    "- Contains all combinations of rows for whose columns the join condition is true.

    "Example 1
    SELECT p~carrid, p~connid, p~cityto, f~fldate
      FROM zdemo_abap_flsch AS p
      INNER JOIN zdemo_abap_fli AS f
        ON p~carrid = f~carrid AND p~connid = f~connid
      WHERE p~cityfrom = 'NEW YORK'
      ORDER BY p~carrid
      INTO TABLE @DATA(itab_in1).

    "Example 2: Multiple inner joins
    SELECT p~carrid, s~carrname, p~connid, p~cityto, f~fldate
      FROM zdemo_abap_flsch AS p
      INNER JOIN zdemo_abap_fli AS f
        ON p~carrid = f~carrid AND p~connid = f~connid
      INNER JOIN zdemo_abap_carr AS s
        ON p~carrid = s~carrid
      WHERE p~cityfrom = 'FRANKFURT'
      ORDER BY p~carrid
      INTO TABLE @DATA(itab_in2).

    out->write( data = itab_in1 name = `itab_in1` ).
    out->write( |\n| ).
    out->write( data = itab_in2 name = `itab_in2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32) Left outer join` ) ).

    "Result set:
    "- Same result set as the inner join.
    "- Difference: For each selected row on the left side as LEFT OUTER JOIN,
    "  at least one row is created in the result set even if no rows on the
    "  other side meet the condition. The columns on the other side that do
    "  not meet the condition are filled with null values.
    "In the example, all rows from the left-hand side (zdemo_abap_carr)
    "are returned as well as the matching rows from the right-hand side
    "(zdemo_abap_flsch). However, the ON condition
    ""p~cityfrom = 'FRANKFURT'" is not met for several entries in
    "zdemo_abap_flsch and a CONNID does not exist.

    SELECT s~carrid, s~carrname, p~connid
      FROM zdemo_abap_carr AS s
      LEFT OUTER JOIN zdemo_abap_flsch AS p
        ON s~carrid = p~carrid AND p~cityfrom = 'FRANKFURT'
      WHERE s~carrid <> 'UA'
      ORDER BY s~carrid
      INTO TABLE @DATA(itab_lo).

    out->write( data = itab_lo name = `itab_lo` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33) Merging the result sets of multiple queries into a single result set using UNION` ) ).

    "Effect: The rows of the result set of the query after UNION are
    "inserted into the result set of the query in front of UNION.
    "The example demonstrates the union of two tables and
    "visualizes those columns that do not exist in the other table by
    "setting the value '-'. Here, a CAST is required for the column CONNID.

    SELECT FROM zdemo_abap_carr
           FIELDS carrname,
                  CAST( '-' AS CHAR( 4 ) ) AS connid,
                  '-' AS cityfrom,
                  '-' AS cityto
           WHERE carrid = 'LH'
      UNION
        SELECT FROM zdemo_abap_flsch
               FIELDS '-' AS carrname,
                      CAST( connid AS CHAR( 4 ) ) AS connid,
                      cityfrom,
                      cityto
               WHERE carrid = 'LH'
       ORDER BY carrname DESCENDING, connid, cityfrom, cityto
       INTO TABLE @DATA(itab_union).

    out->write( data = itab_union name = `itab_union` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33b) Returning distinct rows of a result set using INTERSECT` ) ).

    SELECT zdemo_abap_flsch~carrid, zdemo_abap_carr~carrname
        FROM zdemo_abap_flsch
        INNER JOIN zdemo_abap_carr ON zdemo_abap_carr~carrid = zdemo_abap_flsch~carrid
        ORDER BY zdemo_abap_flsch~carrid
        INTO TABLE @DATA(itab_no_intersect).

    out->write( data = itab_no_intersect name = `itab_no_intersect` ).
    out->write( |\n| ).

    "Using INTERSECT; the result set contains distinct rows
    SELECT zdemo_abap_flsch~carrid, zdemo_abap_carr~carrname
        FROM zdemo_abap_flsch
        INNER JOIN zdemo_abap_carr ON zdemo_abap_carr~carrid = zdemo_abap_flsch~carrid
    INTERSECT
    SELECT carrid, carrname
        FROM zdemo_abap_carr
        ORDER BY carrid
        INTO TABLE @DATA(itab_w_intersect).

    out->write( data = itab_no_intersect name = `itab_w_intersect` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33c) Returning distinct rows of a result set using EXCEPT` ) ).

    "Selecting all carrier IDs from a database table that do not exist in an
    "internal table
    TYPES: ty_demo_tab TYPE TABLE OF zdemo_abap_flsch WITH EMPTY KEY.
    DATA(itab_except) = VALUE ty_demo_tab( ( carrid = 'LH' ) ( carrid = 'LH' ) ( carrid = 'LH' )
                                           ( carrid = 'AA' ) ( carrid = 'AA' ) ).


    "Selecting all carrier IDs for comparison
    SELECT carrid
        FROM zdemo_abap_carr
        INTO TABLE @DATA(all_carrids).

    "Using EXCEPT; the result set excludes those carrier IDs present in the
    "internal table
    SELECT carrid
        FROM zdemo_abap_carr
        EXCEPT
            SELECT it~carrid
            FROM @itab_except AS it
                INNER JOIN zdemo_abap_carr ON zdemo_abap_carr~carrid = it~carrid
        ORDER BY carrid ASCENDING
        INTO TABLE @DATA(itab_w_except).

    out->write( data = itab_w_except name = `itab_w_except` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `34) Common Table Expressions (CTE) (1)` ) ).

    "The result sets of both common table expressions +connections
    "and +sum_seats are merged in the subquery of the CTE +result in
    "a join expression. An explicit name list assigns names to the
    "resulting columns. These names are used in the main query to sort
    "the results. For each flight connection of the selected airline,
    "the total number of occupied seats is output from the database
    "table.

    WITH
      +connections AS (
        SELECT zdemo_abap_flsch~carrid, carrname, connid, cityfrom, cityto
               FROM zdemo_abap_flsch
               INNER JOIN zdemo_abap_carr
                 ON zdemo_abap_carr~carrid = zdemo_abap_flsch~carrid
               WHERE zdemo_abap_flsch~carrid BETWEEN 'AA' AND 'JL' ),
      +sum_seats AS (
        SELECT carrid, connid, SUM( seatsocc ) AS sum_seats
               FROM zdemo_abap_fli
               WHERE carrid BETWEEN 'AA' AND 'JL'
               GROUP BY carrid, connid ),
      +result( name, connection, departure, arrival, occupied ) AS (
        SELECT carrname, c~connid, cityfrom, cityto, sum_seats
               FROM +connections AS c
                 INNER JOIN +sum_seats AS s
                   ON c~carrid = s~carrid AND
                      c~connid = s~connid )
      SELECT *
             FROM +result
             ORDER BY name, connection
             INTO TABLE @DATA(itab_cte).

    out->write( data = itab_cte name = `itab_cte` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `35) CTE and a SELECT Loop (2)` ) ).
    "The example shows a WITH statement, whose main query creates a
    "tabular result set. Since the data is written into work area
    "rather than to an internal table, a SELECT loop is opened, which
    "must be closed with ENDWITH.

    WITH
      +carriers AS ( SELECT FROM zdemo_abap_carr
                            FIELDS carrid, carrname )
      SELECT FROM zdemo_abap_flsch AS s
               INNER JOIN +carriers AS c
                 ON s~carrid = c~carrid
             FIELDS c~carrname, s~connid
             WHERE s~carrid = 'LH'
             INTO @DATA(wa_cte_loop)
             UP TO 3 ROWS.
      out->write( data = wa_cte_loop name = `wa_cte_loop` ).
      out->write( |\n| ).
    ENDWITH.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Changing data in database tables` ) ).

    "Deleting database table to work with
    DELETE FROM zdemo_abap_carr.

    "Creating table rows to be inserted in the database table
    DATA(row1) = VALUE zdemo_abap_carr( carrid = 'AF'
                                        carrname = 'Air France'
                                        currcode = 'EUR'
                                        url =  'http://www.airfrance.fr' ).

    DATA(row2) = VALUE zdemo_abap_carr( carrid = 'UA'
                                        carrname = 'United Airlines'
                                        currcode = 'USD'
                                        url =  'http://www.ual.com' ).

**********************************************************************

    out->write( |36) INSERT: Inserting individual line into a database table\n\n| ).

    "Inserting from an existing structure
    INSERT INTO zdemo_abap_carr VALUES @row1.

    "Alternative syntax having the same effect as the statement above
    INSERT zdemo_abap_carr FROM @row2.

    "Inserting from a structure created inline using a
    "constructor expression with VALUE within a host expression
    INSERT zdemo_abap_carr FROM @( VALUE #( carrid = 'SR'
                                            carrname = 'Swiss'
                                            currcode = 'CHF'
                                            url =  'http://www.swiss.com' ) ).


    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `37) INSERT: Inserting multiple rows into a database table` ) ).

    "Creating and filling an internal table
    DATA itab_insert TYPE TABLE OF zdemo_abap_carr.

    itab_insert = VALUE #( ( carrid = 'BA'
                             carrname = 'British Airways'
                             currcode = 'GBP'
                             url =  'http://www.british-airways.com' )
                           ( carrid = 'FJ'
                             carrname = 'Air Pacific'
                             currcode = 'USD'
                             url =  'http://www.airpacific.com' ) ).


    "Inserting from existing internal table
    INSERT zdemo_abap_carr FROM TABLE @itab_insert.

    "Inserting from an internal table created inline using
    "a constructor expression with VALUE within a host expression
    INSERT zdemo_abap_carr FROM TABLE @( VALUE #( ( carrid = 'ET'
                                                    carrname = 'Ethiopian Airlines'
                                                    currcode = 'ETB'
                                                    url =  'http://www.ethiopianairlines.com' )
                                                  ( carrid = 'QF'
                                                    carrname = 'Qantas Airways'
                                                    currcode = 'AUD'
                                                    url =  'http://www.qantas.com.au' ) ) ).

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `38) INSERT: Inserting multiple rows into a database table accepting duplicate keys` ) ).

    "ACCEPTING DUPLICATE KEYS addition: To avoid a runtime error when
    "inserting entries from an internal table having duplicate keys,
    "all lines that would produce duplicate entries in the database
    "table regarding the keys are discarded and sy-subrc is set to 4.

    "Creating and filling an internal table
    DATA itab_adk TYPE TABLE OF zdemo_abap_carr.

    itab_adk = VALUE #( ( carrid = 'SQ'
                          carrname = 'Singapore Airlines'
                          currcode = 'SGD'
                          url =  'http://www.singaporeair.com' )
                        ( carrid = 'SQ'
                          carrname = 'Singapore Airlines'
                          currcode = 'SGD'
                          url =  'http://www.singaporeair.com' ) ).

    INSERT zdemo_abap_carr FROM TABLE @itab_adk ACCEPTING DUPLICATE KEYS.

    DATA(subrc) = sy-subrc.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).
    out->write( |\n| ).
    out->write( data = subrc name = `subrc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `39) INSERT: Using a subquery` ) ).

    "The purpose of this abstract example is just to visualize that
    "subqueries are possible in INSERT statements. In the example,
    "the goal is just to get one entry from table zdemo_abap_flsch.
    "Since only MANDT and CARRID are shared fields in the two database
    "tables other values in zdemo_abap_carr remain empty. The line is
    "further processed in the following example.

    INSERT zdemo_abap_carr FROM ( SELECT carrid
                                  FROM zdemo_abap_flsch
                                  WHERE carrid = 'LH' AND
                                        connid = '0400' ).

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `40) UPDATE: Changing content of existing rows` ) ).

    "Creating and filling structure
    "In the case below, all field values except the key field are updated.
    DATA(row_upd) = VALUE zdemo_abap_carr(
                            carrid   = 'LH'
                            carrname = 'Lufthansa'
                            currcode = 'EUR'
                            url      =  'http://www.lufthansa.com' ).

    "Creating and filling internal table
    DATA itab_update LIKE itab_insert.

    itab_update = VALUE #( ( carrid = 'BA'
                             carrname = 'British Airways'
                             currcode = 'GBP'
                             url =  'http://www.britishairways.com' ) "updated
                           ( carrid = 'FJ'
                             carrname = 'Fiji Airways'   "updated
                             currcode = 'USD'
                             url =  'http://www.fijiairways.com' ) )."updated


    UPDATE zdemo_abap_carr FROM @row_upd.

    UPDATE zdemo_abap_carr FROM TABLE @itab_update.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `41) UPDATE: Changing values of specific fields in all table rows` ) ).

    "Using the SET addition, you can change the values of specific
    "fields in all table rows without overwriting existing values in
    "other fields.
    "In the example, the field CURRCODE is set as specified for all
    "rows for which the WHERE condition is true.

    UPDATE zdemo_abap_carr
      SET currcode = 'EUR'
      WHERE carrid <> 'UA' AND carrid <> 'ET'.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `42) INDICATORS addition to UPDATE statements: ` &&
    `Changing values of specific fields without overwriting ` &&
    `existing values of other fields ` ) ).

    "Example:
    "- Structured type is created with WITH INDICATORS addition
    "- Internal table from which to update a database table is created; it
    "  includes the indicator structure comp_ind
    "- Internal table is filled; only one component is flagged as
    "  to be updated
    "- Other fields remain unchanged; note that key fields must be
    "  included in ind_tab (indicator setting for key fields has
    "  no effect)

    "Structured type with WITH INDICATORS addition
    TYPES ind_wa TYPE zdemo_abap_carr WITH INDICATORS comp_ind TYPE abap_bool.

    DATA ind_tab TYPE TABLE OF ind_wa.

    "Filling internal table; only CURRCODE should be updated
    ind_tab = VALUE #( ( carrid = 'QF'
                         carrname = 'Qantas Airways'
                         currcode = 'AUD'
                         comp_ind-currcode = abap_true )
                       ( carrid = 'SQ'
                         carrname = 'Singapore Airlines'
                         currcode = 'SGD'
                         comp_ind-currcode = abap_true ) ).

    UPDATE zdemo_abap_carr
      FROM TABLE @ind_tab
      INDICATORS SET STRUCTURE comp_ind.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `43) MODIFY: Inserting and changing rows` ) ).
    "The example only uses host expressions.

    "Modifying an entry based on a row. Here, a new entry is created in
    "the database table since no row exists having the key.
    "The example uses a structure created inline using a constructor
    "expression with VALUE within a host expression.
    MODIFY zdemo_abap_carr FROM @(
          VALUE #( carrid = 'AZ'
                   carrname = 'ITA Airways'
                   currcode = 'EUR'
                   url =  'http://www.ita-airways.com' ) ).

    "Storing the value of system field sy-dbcnt to determine how many
    "table rows were modified.
    DATA(dbcnt) = sy-dbcnt.

    "Modifying entries based on an internal table. Here, no new entry
    "is created. Existing entries are updated.
    MODIFY zdemo_abap_carr FROM TABLE @( VALUE #( ( carrid = 'BA'
                                                    carrname = 'British Airways'
                                                    currcode = 'GBP'                      "modified
                                                    url =  'http://www.britishairways.co.uk' ) "mod
                                                  ( carrid = 'QF'
                                                    carrname = 'Qantas Airways'
                                                    currcode = 'AUD'
                                                    url =  'http://www.qantas.com' ) ) ). "modified

    "Adding the value of sy-dbcnt to the value from above to get
    "the total number of modified rows in this example.
    dbcnt = dbcnt + sy-dbcnt.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).
    out->write( |\n| ).
    out->write( |{ dbcnt } table rows were modified.| ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `44) DELETE: Deleting table rows` ) ).
    "Note that you specify the key fields only.

    "Deleting an entry based on a row. Here, the example uses a
    "structure created inline and by only specifying the key value
    "using a constructor expression with VALUE within a host
    "expression.
    DELETE zdemo_abap_carr FROM @( VALUE #( carrid = 'QF' ) ).

    "Deleting multiple entries based on an internal table.
    "Same as above, the internal table is created inline.
    DELETE zdemo_abap_carr FROM TABLE @( VALUE #( ( carrid = 'AF' )
                                                  ( carrid = 'AZ' )
                                                  ( carrid = 'LH' ) ) ).

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `45) DELETE: Deleting table rows based on a condition` ) ).

    DELETE FROM zdemo_abap_carr WHERE currcode <> 'EUR'.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `46) DELETE: Delete complete table` ) ).

    DELETE FROM zdemo_abap_carr.

    select_from_dbtab( ).
    out->write( data = itab_res name = `itab_res` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `47) Exploring ABAP SQL statements using constructor expressions created in place` ) ).

    TYPES it_type TYPE TABLE OF zdemo_abap_tab1 WITH EMPTY KEY.
    DELETE FROM zdemo_abap_tab1.

    "--- VALUE ---
    "VALUE operator as shown above, creating an internal table in place
    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 char1 = 'aaa' char2 = 'bbb' num1 = 10 num2 = 100 )
                                                  ( key_field = 2 char1 = 'ccc' char2 = 'ddd' num1 = 20 num2 = 200 ) ) ).

    "FOR LOOP with VALUE
    DATA(it_f) = VALUE it_type( ( key_field = 3 char1 = 'ee' char2 = 'ff' num1 = 30 num2 = 300 )
                                ( key_field = 4 char1 = 'gg' char2 = 'hh' num1 = 40 num2 = 400 )
                                ( key_field = 5 char1 = 'ii' char2 = 'jj' num1 = 50 num2 = 500 ) ).

    "In the example, the internal table from above is looped across. The index value is
    "stored and used to modify field values of the internal table. In doing so, the modified
    "internal table values are inserted into the database table.
    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( FOR wa IN it_f INDEX INTO idx ( key_field = wa-key_field
                                                                                  char1 = wa-char1 && idx
                                                                                  char2 = wa-char2 && idx
                                                                                  num1 = wa-num1 + idx
                                                                                  num2 = wa-num2 + idx ) ) ).

    "Using a constructor expression with VALUE and BASE in an UPDATE statement
    "The example assumes selecting an entry from a database, modifying it, and updating it again,
    "but the non-modified entries shall remain unchanged.
    INSERT zdemo_abap_tab1 FROM @( VALUE #( key_field = 100 char1 = 'xxx' char2 = 'yyy' num1 = 100 num2 = 101 ) ).

    SELECT SINGLE * FROM zdemo_abap_tab1 WHERE key_field = 100 INTO @DATA(read_line).
    UPDATE zdemo_abap_tab1 FROM @( VALUE #( BASE read_line char2 = '#' num1 = 1 ) ).

    "--- CORRESPONDING ---
    TYPES: BEGIN OF s1,
             key_field TYPE i,
             char1     TYPE c LENGTH 5,
             num1      TYPE i,
           END OF s1,
           it_type_s1 TYPE TABLE OF s1 WITH EMPTY KEY,
           BEGIN OF s2,
             key     TYPE i,
             char    TYPE c LENGTH 5,
             number1 TYPE i,
             num2    TYPE p LENGTH 8 DECIMALS 2,
           END OF s2,
           it_type_s2 TYPE TABLE OF s2 WITH EMPTY KEY.

    "Identical component names in the internal table
    "The example includes compatible and convertible types.
    DATA(it_g) = VALUE it_type_s1( ( key_field = 6 char1 = 'kkk' num1 = 60 )
                                   ( key_field = 7 char1 = 'lll' num1 = 70 ) ).

    INSERT zdemo_abap_tab1 FROM TABLE @( CORRESPONDING #( it_g ) ).

    "Non-identical component names in the internal table; using the MAPPING/EXCEPT additions
    "The example includes compatible and convertible types.
    DATA(it_h) = VALUE it_type_s2( ( key = 8 char = 'mmm' number1 = 80 num2 = '1.23' )
                                   ( key = 9 char = 'nnn' number1 = 90 num2 = '4.56' ) ).

    INSERT zdemo_abap_tab1 FROM TABLE @( CORRESPONDING #( it_h MAPPING key_field = key char2 = char num1 = number1 EXCEPT num2 ) ).

    SELECT * FROM zdemo_abap_tab1 INTO TABLE @DATA(itab_constr).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `48) Evaluating ABAP System Fields after ABAP SQL Statements` ) ).

    "Clearing a demo database table
    DELETE FROM zdemo_abap_tab1.

    "--------------------- INSERT ---------------------
    INSERT zdemo_abap_tab1 FROM @( VALUE #( key_field = 1 ) ).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 1.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 2 )
                                                  ( key_field = 3 ) ) ).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 2.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 2 )
                                                  ( key_field = 3 ) ) ) ACCEPTING DUPLICATE KEYS.

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 0.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 3 )
                                                  ( key_field = 4 ) ) ) ACCEPTING DUPLICATE KEYS.

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 1.

    "--------------------- UPDATE ---------------------
    UPDATE zdemo_abap_tab1 FROM @( VALUE #( key_field = 1 num1 = 1 ) ).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 1.

    UPDATE zdemo_abap_tab1 FROM @( VALUE #( key_field = 9999 num1 = 9999 ) ).

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 0.

    UPDATE zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 2 num1 = 2 )
                                                  ( key_field = 3 num1 = 3 ) ) ).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 2.

    UPDATE zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 4 num1 = 4 )
                                                  ( key_field = 1111 num1 = 1111 ) ) ).

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 1.

    "--------------------- MODIFY ---------------------
    MODIFY zdemo_abap_tab1 FROM @( VALUE #( key_field = 1 num1 = 11 ) ).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 1.

    MODIFY zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 2 num1 = 22 )     "Entry modified
                                                  ( key_field = 5 num1 = 5 ) ) ). "Entry inserted

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 2.

    "--------------------- SELECT ---------------------

    SELECT *
      FROM zdemo_abap_tab1
      INTO TABLE @DATA(tab).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 5.
    ASSERT sy-dbcnt = lines( tab ).

    SELECT *
          FROM zdemo_abap_tab1
          WHERE key_field <= 3
          INTO TABLE @DATA(tab2).

    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 3.

    SELECT *
      FROM zdemo_abap_tab1
      WHERE key_field > 10
      INTO TABLE @DATA(tab3).

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 0.

    "--------------------- DELETE ---------------------
    DELETE zdemo_abap_tab1 FROM @( VALUE #( key_field = 1 ) ).
    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 1.

    DELETE zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 ) "Entry not existent
                                                  ( key_field = 2 )
                                                  ( key_field = 3 ) ) ).

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 2.

    DELETE FROM zdemo_abap_tab1 WHERE key_field >= 5.
    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 1.

    "Only one entry left in the database table
    DELETE FROM zdemo_abap_tab1.
    ASSERT sy-subrc = 0.
    ASSERT sy-dbcnt = 1.

    SELECT *
      FROM zdemo_abap_tab1
      INTO TABLE @DATA(tab4).

    ASSERT sy-subrc = 4.
    ASSERT sy-dbcnt = 0.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `49) Typed literals` ) ).

    "Miscellaneous typed literals in an ABAP SQL statement
    "Note that typed literals can be specified in read
    "positions where host variables are possible.
    DATA(tmstamp) = CONV timestamp( '20240808112517' ).
    DATA(some_string) = `Some string`.
    SELECT SINGLE
      FROM zdemo_abap_fli
      FIELDS
        carrid,
        @some_string AS host_var,
        char`X` AS flag,
        int8`32984723948723` AS int8,
        raw`11` AS raw,
        numc`1234` AS numc,
        utclong`2024-01-01T10:01:02,2` AS utc,
        tims`101507` AS tims,
        curr`173.95` AS curr,
        "Multiple cast expressions splitting a time stamp into date and time parts
        CAST( CAST( div( @tmstamp, 1000000 ) AS CHAR ) AS DATS ) AS date,
        CAST( substring( CAST( @tmstamp AS CHAR ), 9, 6 ) AS TIMS ) AS time,
        "Untyped literal
        'ABAP' AS txt
      WHERE fldate = datn`20240102`
      INTO @DATA(misc_typed_literals).

    out->write( data = misc_typed_literals name = `misc_typed_literals` ).

  ENDMETHOD.


  METHOD select_from_dbtab.
    SELECT *
      FROM zdemo_abap_carr
      ORDER BY carrid
      INTO TABLE @itab_res.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_sql_group_by DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS: class_constructor.

protected section.
  PRIVATE SECTION.
    CLASS-DATA:
      wa      TYPE zdemo_abap_flsch,
      member  TYPE zdemo_abap_flsch,
      members TYPE STANDARD TABLE OF zdemo_abap_flsch WITH EMPTY KEY.

ENDCLASS.""",
    r"""CLASS ZCL_DEMO_ABAP_SQL_GROUP_BY IMPLEMENTATION.


  METHOD class_constructor.
    "Fill demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Grouping Internal Tables\n\n| ).

    SELECT *
           FROM zdemo_abap_flsch
           INTO TABLE @DATA(fli_tab).

    out->write( |1) Representative Binding\n| ).
    out->write( |1a) Grouping by one column\n| ).

    LOOP AT fli_tab INTO wa
                      GROUP BY wa-carrid.
      out->write( wa-carrid ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `1b) Members of one column groups` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY wa-carrid.
      CLEAR members.
      LOOP AT GROUP wa INTO member.
        members = VALUE #( BASE members ( member ) ).
      ENDLOOP.

      out->write( members ).
      out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `1c) Grouping by two columns` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY ( key1 = wa-carrid key2 = wa-airpfrom ).

     out->write( |{ wa-carrid } { wa-airpfrom }| ).
     out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `1d) Members of two column groups` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY ( key1 = wa-carrid key2 = wa-airpfrom ).
      CLEAR members.
      LOOP AT GROUP wa INTO member.
        members = VALUE #( BASE members ( member ) ).
      ENDLOOP.

      out->write( members ).
      out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `2) Group Key Binding` ) ).
    out->write( |2a) Grouping by one column\n| ).

    LOOP AT fli_tab INTO wa
                      GROUP BY wa-carrid
                      INTO DATA(key).

      out->write( key ).
      out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `2b) Members of one column groups` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY wa-carrid
                      INTO key.
      CLEAR members.
      LOOP AT GROUP key INTO member.
        members = VALUE #( BASE members ( member ) ).
      ENDLOOP.

      out->write( members ).
      out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `2c) Grouping by two columns` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY ( key1 = wa-carrid key2 = wa-airpfrom )
                      INTO DATA(keys).

      out->write( keys ).
      out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `2d) Members of two column groups` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY ( key1 = wa-carrid key2 = wa-airpfrom )
                    INTO keys.
      CLEAR members.
      LOOP AT GROUP keys INTO member.
        members = VALUE #( BASE members ( member ) ).
      ENDLOOP.

      out->write( members ).
      out->write( |\n| ).
    ENDLOOP.

    out->write( zcl_demo_abap_aux=>heading( `2e) Two column groups without members` ) ).

    LOOP AT fli_tab INTO wa
                      GROUP BY ( key1 = wa-carrid key2 = wa-airpfrom
                                 index = GROUP INDEX size = GROUP SIZE )
                      WITHOUT MEMBERS
                      INTO DATA(keysplus).

      out->write( keysplus ).
      out->write( |\n| ).
    ENDLOOP.

  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_string_proc DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_string_proc IMPLEMENTATION.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: String Processing\n\n| ).
    out->write( |1) Creating Strings and Assigning Values\n\n| ).

    "Data object declarations providing default values
    DATA: flag   TYPE c LENGTH 1 VALUE 'X',    "Single quotes
          str_a1 TYPE string VALUE `Hallo, how are you?`. "Backquotes

    DATA: char_a1 TYPE c LENGTH 5,
          str_a2  TYPE string,
          str_a3  LIKE str_a2.

    "Examples for type n
    DATA zip_code TYPE n LENGTH 5 VALUE '12345'.

    DATA isbn_number TYPE n LENGTH 13 VALUE '1234567890123'.

    "Value assignments to existing data objects
    char_a1 = 'ab123'.

    str_a2 = `<p>Hallo!</p>`.

    "Escaping a backquote using another backquote
    str_a3 = `This is a backquote: ``.`.

    "If possible, avoid unnecessary type conversion; in principle,
    "every convertible type can be specified
    "Assigning a fixed-length string to a variable-length string.
    str_a2 = 'abc'.

    DATA str_a4 TYPE string VALUE 'X'. "Type c length 1

    DATA str_a5 TYPE string VALUE -1. "Type i

    "Inline declaration: data object declaration and
    "value assignment
    "Data type is automatically derived
    DATA(char_a2) = 'abcd'. "Type c length 4

    DATA(str_a6) = `efgh`. "Type string

    "Note: Variable is of type c length 4. Characters are truncated.
    "In newer ABAP releases, the following statement shows a syntax
    "warning that the value of the literal (intentionally specified
    "here like this) is not an admissable value for the target type.
    "Therefore, the example is provided differently to circumvent the
    "syntax warning.

    "char_a2 = 'ijklmnopq'.

    TYPES c_l9 TYPE c LENGTH 9.
    DATA some_char TYPE c_l9 VALUE 'ijklmnopq'.
    char_a2 = some_char.

    "Treating trailing blanks
    DATA(char_a3) = 'ab   '.

    DATA(str_a7)  = `cdefgh`.

    str_a7 = char_a3. "Trailing blanks are not respected.

    "Excursion: Chaining strings
    "Note the conversion result of str_a5 above (i to string)
    DATA(str_a8) = str_a4 && ` ` && str_a5 && `!`.

    out->write( data = str_a3 name = `str_a3` ).
    out->write( |\n| ).
    out->write( data = char_a2 name = `char_a2` ).
    out->write( |\n| ).
    out->write( data = str_a7 name = `str_a7` ).
    out->write( |\n| ).
    out->write( data = str_a8 name = `str_a8` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Chaining Strings` ) ).

    DATA(str_b1) = `Hallo`.
    DATA(str_b2) = `how`.
    DATA(str_b3) = `are`.

    "Chaining using && operator
    DATA(str_b4) = str_b1 && ` ` && sy-uname && `, ` && str_b2 && ` ` && str_b3 && ` you?`.

    "Chaining only character literals of the same type using & operator
    "Note: Such a combination of literals is possible up to 255 chars.
    DATA(char_b1) = 'AB' & 'AP  '. "Trailing blanks are ignored

    DATA(str_b5) = `AB` & `AP  `.

    out->write( data = str_b4 name = `str_b4` ).
    out->write( |\n| ).
    out->write( data = char_b1 name = `char_b1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3a) String Templates (1): Constructing Strings` ) ).

    "The expression must be convertible to a string. A blank (not
    "within the curly brackets) means a blank in the resulting string.
    DATA(str_c1) = `Hallo`.
    DATA(str_c2) = `how`.
    DATA(str_c3) = `are`.
    DATA(str_c4) = |{ str_c1 } { sy-uname }, | &&
                   |{ str_c2 } { str_c3 } you?|.

    out->write( data = str_c4 name = `str_c4` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3b) String Templates (2): Control Characters` ) ).

    "Interpretation of character combinations as control characters
    "\n interpreted as a line break
    DATA(str_c5) = |{ str_c1 }\n{ sy-uname },| &&
                   |\n{ str_c2 }\n{ str_c3 }\nyou?|.

    out->write( data = str_c5 name = `str_c5` ).
    out->write( |\n| ).

    "Excursion: Class CL_ABAP_CHAR_UTILITIES provides attributes and methods as utilities for string processing.
    "See the class documentation.
    "The following examples demonstrate that attributes that contain control characters can be replaced by
    "a representation of control characters in a string template.
    DATA(str_c6) = |{ str_c1 }{ cl_abap_char_utilities=>newline }{ sy-uname }|.
    DATA(str_c7) = |{ str_c1 }\n{ sy-uname }|.
    DATA(str_c8) = |{ str_c1 }{ cl_abap_char_utilities=>horizontal_tab }{ sy-uname }|.
    DATA(str_c9) = |{ str_c1 }\t{ sy-uname }|.
    DATA(str_c10) = |{ str_c1 }{ cl_abap_char_utilities=>cr_lf  }{ sy-uname }|.
    DATA(str_c11) = |{ str_c1 }\r\n{ sy-uname }|.
    ASSERT str_c10 = str_c11.

    out->write( data = str_c6 name = `str_c6` ).
    out->write( |\n| ).
    out->write( data = str_c7 name = `str_c7` ).
    out->write( |\n| ).
    out->write( data = str_c8 name = `str_c8` ).
    out->write( |\n| ).
    out->write( data = str_c9 name = `str_c9` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) String Templates (3): Formatting Options` ) ).
    "Time, date
    DATA(str_d1a) = |Date: { cl_abap_context_info=>get_system_date( ) DATE = USER }|.
    DATA(str_d1b) = |Time: { cl_abap_context_info=>get_system_time( ) TIME = ISO }|.
    DATA(str_d1c) = |Timestamp: { utclong_current( ) TIMESTAMP = SPACE }|.

    "Upper, lower case
    DATA(str_d2) = |AbCdEfG|.
    DATA(str_d3) = |{ str_d2 CASE = LOWER }|.
    DATA(str_d4) = |{ str_d2 CASE = UPPER }|.

    "Width and alignment
    DATA(str_d5) = |{ 'Left'   WIDTH = 20 ALIGN = LEFT }<---|.
    DATA(str_d6) = |{ 'Center' WIDTH = 20 ALIGN = CENTER }<---|.
    DATA(str_d7) = |{ 'Right'  WIDTH = 20 ALIGN = RIGHT }<---|.
    DATA(str_d8) = |{ 'Left'   WIDTH = 20 ALIGN = LEFT  PAD = '.'  }<---|.
    DATA(str_d9) = |{ 'Center' WIDTH = 20 ALIGN = CENTER PAD = '.' }<---|.
    DATA(str_d10) = |{ 'Right' WIDTH = 20 ALIGN = RIGHT  PAD = '.' }<---|.

    "Numbers
    DATA(str_d11) = |{                   - 2 / 3   DECIMALS = 3 }, {
                        CONV decfloat34( - 2 / 3 ) DECIMALS = 3 }, {
                        CONV          f( - 2 / 3 ) DECIMALS = 3 }|.

    "Escaping \|{}  in string templates
    DATA(str_d14) = |\\ \| \{ \}|.

    out->write( data = str_d1a name = `str_d1a` ).
    out->write( |\n| ).
    out->write( data = str_d1b name = `str_d1b` ).
    out->write( |\n| ).
    out->write( data = str_d1c name = `str_d1c` ).
    out->write( |\n| ).
    out->write( data = str_d3 name = `str_d3` ).
    out->write( |\n| ).
    out->write( data = str_d4 name = `str_d4` ).
    out->write( |\n| ).
    out->write( data = str_d5 name = `str_d5` ).
    out->write( |\n| ).
    out->write( data = str_d6 name = `str_d6` ).
    out->write( |\n| ).
    out->write( data = str_d7 name = `str_d7` ).
    out->write( |\n| ).
    out->write( data = str_d8 name = `str_d8` ).
    out->write( |\n| ).
    out->write( data = str_d9 name = `str_d9` ).
    out->write( |\n| ).
    out->write( data = str_d10 name = `str_d10` ).
    out->write( |\n| ).
    out->write( data = str_d11 name = `str_d11` ).
    out->write( |\n| ).
    out->write( data = str_d14 name = `str_d14` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Determining the Length of Strings` ) ).

    DATA(str_e1)  = `abc def ghi   `.
    DATA(char_e1) = 'abc def ghi   '.

    "strlen
    "Result depends on the type of the data object
    "Fixed-length string ignores trailing blanks
    DATA(length_e1) = strlen( str_e1 ).
    DATA(length_e2) = strlen( char_e1 ).

    "numofchar
    "To exclude trailing blanks in any case.
    DATA(length_e3) = numofchar( str_e1 ).
    DATA(length_e4) = numofchar( char_e1 ).

    "Excursion:
    "To emphasizes modern, expression-enabled ABAP, the expression
    "with the string function can be placed directly in the DO
    "statement instead of having an extra variable.
    DATA(str_e3) = `abcde`.
    DATA(length_e5) = strlen( str_e3 ).
    DATA(int_e1) = 0.

    DO length_e5 TIMES.
      int_e1 += 1.
    ENDDO.

    DATA(int_e2) = 0.

    DO strlen( str_e3 ) TIMES.
      int_e2 += 1.
    ENDDO.

    out->write( data = length_e1 name = `length_e1` ).
    out->write( |\n| ).
    out->write( data = length_e2 name = `length_e2` ).
    out->write( |\n| ).
    out->write( data = length_e3 name = `length_e3` ).
    out->write( |\n| ).
    out->write( data = length_e4 name = `length_e4` ).
    out->write( |\n| ).
    out->write( data = int_e1 name = `int_e1` ).
    out->write( |\n| ).
    out->write( data = int_e2 name = `int_e2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6a) Concatenating Strings` ) ).

    DATA(str_f1) = `Hallo`.
    DATA(str_f2) = `world`.

    "Concatenation using && operator and string templates
    DATA(str_f3) = str_f1 && str_f2.
    DATA(str_f4) = str_f1 && ` ` && str_f2.
    DATA(str_f5) = |{ str_f1 } { str_f2 }|.

    "CONCATENATE statements
    CONCATENATE str_f1 str_f2 INTO DATA(str_f6).
    "Adding a separation sign using the addition SEPARATED BY
    CONCATENATE str_f1 str_f2 INTO DATA(str_f7) SEPARATED BY ` `.
    CONCATENATE str_f1 str_f2 INTO DATA(str_f8) SEPARATED BY `#`.

    DATA(char_f1) = '2 trailing blanks:  '.
    DATA(char_f2) = '3 trailing blanks:   '.
    DATA(char_f3) = '<-'.
    "Keeping trailing blanks in the result when concatenating
    "fixed-length strings. The ones of variable-length strings are
    "respected by default
    CONCATENATE char_f1 char_f2 char_f3
      INTO DATA(char_f4) RESPECTING BLANKS.
    "Trailing blanks are ignored
    CONCATENATE char_f1 char_f2 char_f3 INTO DATA(char_f5).

    "Example use case: Concatenating smaller text fragments
    "sequentially into a longer character sequence.
    DATA: itab_g    TYPE TABLE OF string,
          alphabet1 TYPE string.

    itab_g = VALUE #( ( `abc` ) ( `def` ) ( `ghi` ) ).

    LOOP AT itab_g ASSIGNING FIELD-SYMBOL(<abc>).
      alphabet1 = alphabet1 && <abc>.
      "Alternative:
      "CONCATENATE alphabet <abc> INTO alphabet.
    ENDLOOP.

    "Avoiding loops if your use case is to concatenate lines of an
    "internal table into a string in one go
    CONCATENATE LINES OF itab_g INTO DATA(alphabet2).

    ""Adding a separation sign using the addition SEPARATED BY
    CONCATENATE LINES OF itab_g INTO DATA(alphabet3)
                                SEPARATED BY ` `.

    "String function concat_lines_of
    DATA(alphabet4) = concat_lines_of( table = itab_g ).
    "sep parameter specifying the separation sign
    DATA(alphabet5) = concat_lines_of( table = itab_g sep = `,` ).

    out->write( data = str_f3 name = `str_f3` ).
    out->write( |\n| ).
    out->write( data = str_f4 name = `str_f4` ).
    out->write( |\n| ).
    out->write( data = str_f5 name = `str_f5` ).
    out->write( |\n| ).
    out->write( data = str_f6 name = `str_f6` ).
    out->write( |\n| ).
    out->write( data = str_f7 name = `str_f7` ).
    out->write( |\n| ).
    out->write( data = str_f8 name = `str_f8` ).
    out->write( |\n| ).
    out->write( data = char_f4 name = `char_f4` ).
    out->write( |\n| ).
    out->write( data = char_f5 name = `char_f5` ).
    out->write( |\n| ).
    out->write( data = alphabet1 name = `alphabet1` ).
    out->write( |\n| ).
    out->write( data = alphabet2 name = `alphabet2` ).
    out->write( |\n| ).
    out->write( data = alphabet3 name = `alphabet3` ).
    out->write( |\n| ).
    out->write( data = alphabet4 name = `alphabet4` ).
    out->write( |\n| ).
    out->write( data = alphabet5 name = `alphabet5` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6b) Literal Operator` ) ).

    "Literal operator
    "Used to combine character literals of the same type into a single character literal
    DATA(abap) = 'AB' & 'AP'.

    "Note an upper limit of 255 characters
    "If you remove the comment, which results in a combined character literal
    "of 256 characters, a syntax error is displayed.
    DATA(c_limit_255) =
    '##################################################' & "50 x #
    '##################################################' &
    '##################################################' &
    '##################################################' &
    '##################################################' &
    '#####'
    "& '#'
    .

    "Trailing blanks are respected
    DATA(char_with_blanks) = 'AB' & 'AP' & '           '.

    "Using RTTI to get type information, retrieving the output length of the combined literal
    DATA(output_length) = CAST cl_abap_elemdescr( cl_abap_typedescr=>describe_by_data( char_with_blanks ) )->output_length.
    out->write( data = output_length name = `output_length` ).
    out->write( |\n| ).

    DATA(ch1) = 'AB'.
    DATA(ch2) = 'AP'.
    "Not possible as the operands are not character literals but data objects
    "DATA(combined_ch) = ch1 & ch2.

    "Not to be confused with the concatenation operator && to concatenate
    "character-like operands; at runtime, any number of character-like operands
    "are possible
    "The result in the example is of type string.
    DATA(combined_ch_with_conc_op) = ch1 && ch2.

    "Concatenation similar to the example above
    "As the result is of type string using the concatenation operator, the
    "trailing blanks are not respected.
    DATA(char_with_blanks_conc_op) = 'AB' && 'AP' && '           '.

    DATA(len1) = strlen( char_with_blanks_conc_op ).
    DATA(len2) = numofchar( char_with_blanks_conc_op ).

    out->write( data = len1 name = `len1` ).
    out->write( |\n| ).
    out->write( data = len2 name = `len2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Splitting Strings` ) ).

    DATA(str_g1) = `Hallo,world,12345`.

    SPLIT str_g1 AT `,` INTO DATA(str_g2) DATA(str_g3) DATA(str_g4).

    "Less data objects than possible splittings
    SPLIT str_g1 AT `,` INTO DATA(str_g5) DATA(str_g6).

    "Splitting string into an internal table
    DATA itab_g1 TYPE TABLE OF string.

    SPLIT str_g1 AT ',' INTO TABLE itab_g1.

    "Getting the value of a specific segment
    DATA(str_g7) = segment( val = str_g1 index = 2 sep = `,` ).

    "Example with segment
    "A string is split and the values of segments are retrieved. Here,
    "all segments are retrieved and inserted into an internal table
    "using a DO loop. If you specify an empty string, an exception of
    "the class CX_SY_STRG_PAR_VAL is raised. This is true for this
    "example since the DO loop inevitably runs into the error because
    "of not specifying an appropriate number of loops. Note that
    "if the index parameter of the segment function is positive, the
    "occurrences are counted from the left. If index is negative, the
    "occurrences are counted from the right.
    DATA itab_g2 TYPE TABLE OF string.
    DO.
      TRY.
          DATA(str_g8) = segment( val   = str_g1
                                   index = sy-index
                                   sep   = `,` ).

          APPEND |Segment value: '{ str_g8 }' | &&
                 |Segment index: '{ sy-index }'| TO itab_g2.

        CATCH cx_sy_strg_par_val.
          DATA(seg_nom) = |There are { sy-index - 1 } | &&
                          |segments in the string.|.
          EXIT.
      ENDTRY.
    ENDDO.

    "SPLIT statement specifying a colon after INTO
    DATA(some_text) = `Lorem ipsum dolor sit amet, consectetur adipiscing elit`.

    SPLIT some_text AT ` ` INTO: DATA(str1) DATA(str2) DATA(str3) DATA(str4), TABLE DATA(tab).

    out->write( data = str_g2 name = `str_g2` ).
    out->write( |\n| ).
    out->write( data = str_g3 name = `str_g3` ).
    out->write( |\n| ).
    out->write( data = str_g4 name = `str_g4` ).
    out->write( |\n| ).
    out->write( data = str_g5 name = `str_g5` ).
    out->write( |\n| ).
    out->write( data = str_g6 name = `str_g6` ).
    out->write( |\n| ).
    out->write( data = itab_g1 name = `itab_g1` ).
    out->write( |\n| ).
    out->write( data = str_g7 name = `str_g7` ).
    out->write( |\n| ).
    out->write( data = str_g8 name = `str_g8` ).
    out->write( |\n| ).
    out->write( data = itab_g2 name = `itab_g2` ).
    out->write( |\n| ).
    out->write( data = seg_nom name = `seg_nom` ).
    out->write( |\n| ).
    out->write( data = str1 name = `str1` ).
    out->write( |\n| ).
    out->write( data = str2 name = `str2` ).
    out->write( |\n| ).
    out->write( data = str3 name = `str3` ).
    out->write( |\n| ).
    out->write( data = str4 name = `str4` ).
    out->write( |\n| ).
    out->write( data = tab name = `tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Modifying Strings` ) ).
    out->write( |8) Transforming to Lower and Upper Case\n\n| ).

    DATA(str_h1) = `It's a string`.
    DATA(str_h2) = str_h1.

    "The string functions store the result in a target variable.
    DATA(str_h3) = to_upper( str_h1 ).
    DATA(str_h4) = to_lower( str_h1 ).

    "TRANSLATE does the transformation on the source variable.
    TRANSLATE str_h1 TO UPPER CASE.
    TRANSLATE str_h2 TO LOWER CASE.

    "to_mixed/from_mixed functions
    "sep: Specifies the separator
    "case: A character-like text field. A small character specifies
    "that the first character of the string is in lower case. If the
    "specification is, for example, case = 'X', the first character
    "is capitalized.
    "min: A positive number that specifies the minimum number of
    "characters that must appear before the separator. The default
    "value is 1.
    DATA(str_h5) = `A_GREAT_STRING`.
    DATA(str_h6) = to_mixed( val = str_h5 sep = `_` ).
    DATA(str_h7) = to_mixed( val = str_h5 sep = `_` case = 'x' ).
    DATA(str_h8) = to_mixed( val = str_h5 sep = `_`
                             case = 'a' min = 3 ).

    DATA(str_h9) = from_mixed( val = `someGreatString` sep = ` `
                               case = 'a' min = 4 ).

    out->write( data = str_h3 name = `str_h3` ).
    out->write( |\n| ).
    out->write( data = str_h4 name = `str_h4` ).
    out->write( |\n| ).
    out->write( data = str_h1 name = `str_h1` ).
    out->write( |\n| ).
    out->write( data = str_h2 name = `str_h2` ).
    out->write( |\n| ).
    out->write( data = str_h6 name = `str_h6` ).
    out->write( |\n| ).
    out->write( data = str_h7 name = `str_h7` ).
    out->write( |\n| ).
    out->write( data = str_h8 name = `str_h8` ).
    out->write( |\n| ).
    out->write( data = str_h9 name = `str_h9` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Shifting Content in Strings` ) ).

    DATA(str_i1) = `hallo`.
    DATA(str_i2) = str_i1.
    DATA(str_i3) = str_i1.
    DATA(str_i4) = str_i1.

    "No addition; string is shifted one place to the left
    SHIFT str_i2.

    "Shifting string by n places; without direction,
    "left by default
    SHIFT str_i3 BY 2 PLACES.

    "Direction explicitly specified
    "Variable-length strings are extended
    SHIFT str_i4 BY 3 PLACES RIGHT.

    DATA(char_i1) = 'world  '.
    DATA(char_i2) = char_i1.
    DATA(char_i3) = char_i1.
    DATA(str_i5) = `world  `.

    "Comparison of behavior for fixed- and variable-length strings
    SHIFT char_i1 BY 3 PLACES RIGHT.
    SHIFT str_i5 BY 3 PLACES RIGHT.

    "CIRCULAR addition: characters that are moved out of the string are
    "added at the other end again
    SHIFT char_i2 BY 3 PLACES RIGHT CIRCULAR.
    SHIFT char_i3 BY 2 PLACES LEFT CIRCULAR.

    DATA(str_i6) = ` hallo world `.
    DATA(str_i7) = str_i6.

    "Moving characters up to a specific character set
    SHIFT str_i6 UP TO 'or'.

    "Deleting leading and trailing characters with this sequence
    "of statements
    SHIFT str_i7 RIGHT DELETING TRAILING ` `.
    SHIFT str_i7 LEFT DELETING LEADING ` `.

    "String functions storing the result in a target variable
    DATA(str_i8) = `some string`.

    "shift_left
    DATA(str_i9) = shift_left( val = str_i8  places = 3 ).

    DATA(str_i10) = shift_left( val = str_i8  circular = 7 ).

    "shift_right
    "Note: When the parameter places is specified, the function
    "shift_right has a different behavior than the SHIFT statement.
    "Here, the length of the string is reduced. SHIFT extends the
    "length or it remains the same.
    DATA(str_i11) = shift_right( val = str_i8  places = 3 ).

    DATA(str_i12) = `shift_right and trailing blanks  `.

    "sub: Specifying a substring; all substrings in the string that
    "match the value are removed (sub also available for shift_left)
    DATA(str_i13) = shift_right( val = str_i12
                                 sub = ` and trailing blanks  ` ).

    DATA(str_i14) = shift_right( val = str_i12  sub = ` ` ).

    DATA(str_i15) = shift_right( val = str_i12 ). "Same effect as above

    out->write( |SHIFT statements:\n\n| ).
    out->write( data = str_i2 name = `str_i2` ).
    out->write( |\n| ).
    out->write( data = str_i3 name = `str_i3` ).
    out->write( |\n| ).
    out->write( data = str_i4 name = `str_i4` ).
    out->write( |\n| ).
    out->write( data = char_i1 name = `char_i1` ).
    out->write( |\n| ).
    out->write( data = str_i5 name = `str_i5` ).
    out->write( |\n| ).
    out->write( data = char_i2 name = `char_i2` ).
    out->write( |\n| ).
    out->write( data = char_i3 name = `char_i3` ).
    out->write( |\n| ).
    out->write( data = str_i6 name = `str_i6` ).
    out->write( |\n| ).
    out->write( data = str_i7 name = `str_i7` ).
    out->write( |\n| ).

    out->write( |String functions:\n\n| ).
    out->write( |\n| ).
    out->write( data = str_i9 name = `str_i9` ).
    out->write( |\n| ).
    out->write( data = str_i10 name = `str_i10` ).
    out->write( |\n| ).
    out->write( data = str_i11 name = `str_i11` ).
    out->write( |\n| ).
    out->write( data = str_i13 name = `str_i13` ).
    out->write( |\n| ).
    out->write( data = str_i14 name = `str_i14` ).
    out->write( |\n| ).
    out->write( data = str_i15 name = `str_i15` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Condensing Strings` ) ).

    DATA(char_j1) = ' some text '.
    DATA(char_j2) = '    some     more text   '.
    DATA(char_j3) = ' a third text field literal '.

    "No addition: Removes leading and trailing blanks. This is also
    "true for multiple blanks. It also replaces sequences of multiple
    "blanks with a single blank.
    CONDENSE char_j1.
    CONDENSE char_j2.

    "NO-GAPS: Removes all blanks, also between words. When NO-GAPS
    "is used with variable-length strings, trailing blanks remain
    "removed.
    CONDENSE char_j3 NO-GAPS.

    "RESPECTING BLANKS: Avoiding condensing
    "A use case might be the assignment of strings with fixed- to
    "variable-length strings.
    DATA(char_j4) = '  abcef  '.
    DATA(char_j5) = '  ghij  '.
    DATA str_j TYPE string.

    "Result: '  abcef    ghij  '
    CONCATENATE char_j4 char_j5 INTO str_j RESPECTING BLANKS.

    "String function condense
    "The advantage of using the string functions is
    "that you can also specify random characters to be removed and
    "not only blanks.
    DATA(str_j1) = `  hi   there  `.

    "No parameters specified (i. e. their default values are provided);
    "works like CONDENSE statements without the NO-GAPS addition
    DATA(str_j2) = condense( str_j1 ).

    "Parameter 'from' specified with an initial string, 'del'/'to' not
    "specified: Removes leading and trailing blanks. The 'from'
    "parameter could also be specified with a text field literal:
    "from = ' '
    DATA(str_j3) = condense( val = str_j1 from = `` ).

    "Parameter 'to' specified with an initial string, 'from'/'del' not
    "specified: works like CONDENSE statements with the NO-GAPS
    "addition
    DATA(str_j4) = condense( val = str_j1 to = `` ).

    DATA(str_j5) = `ZZseeZZZyouZZ`.
    DATA(str_j6) = condense( val = str_j5 del = `Z` ).

    "Parameters 'from', 'to' and 'del' are specified: Leading and
    "trailing characters specified in 'del' are first removed. Then,
    "in the remaining string, all substrings composed of characters
    "specified in 'from' are replaced with the first character of the
    "string specified in the 'to' parameter (in the example, it is a
    "blank; the characters 'a', 'b', 'c' are not respected at all).
    DATA(str_j7) = condense( val  = str_j5
                             del  = `Z`
                             from = `Z`
                             to   = ` abc` ).

    out->write( |CONDENSE statements:\n| ).
    out->write( |\n| ).
    out->write( data = char_j1 name = `char_j1` ).
    out->write( |\n| ).
    out->write( data = char_j2 name = `char_j2` ).
    out->write( |\n| ).
    out->write( data = char_j3 name = `char_j3` ).
    out->write( |\n| ).
    out->write( data = str_j name = `str_j` ).
    out->write( |\n| ).
    out->write( zcl_demo_abap_aux=>heading( `String function condense:` ) ).
    out->write( data = str_j2 name = `str_j2` ).
    out->write( |\n| ).
    out->write( data = str_j3 name = `str_j3` ).
    out->write( |\n| ).
    out->write( data = str_j4 name = `str_j4` ).
    out->write( |\n| ).
    out->write( data = str_j6 name = `str_j6` ).
    out->write( |\n| ).
    out->write( data = str_j7 name = `str_j7` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Reversing Strings` ) ).

    DATA(str_k) = reverse( `ollah` ).

    out->write( data = str_k name = `str_k` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Inserting Substrings into Strings` ) ).

    DATA(str_l1) = `abcghi`.

    "Inserting into specific position
    DATA(str_l2) = insert( val = str_l1 sub = `def` off = 3 ).

    "off is optional. If not specified (default value off = 0)
    "the result is like concatenating a string with &&
    DATA(str_l3) = insert( val = str_l1 sub = `def` ).

    DATA(str_l4) = `def` && str_l1.

    out->write( data = str_l2 name = `str_l2` ).
    out->write( |\n| ).
    out->write( data = str_l3 name = `str_l3` ).
    out->write( |\n| ).
    out->write( data = str_l4 name = `str_l4` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Overlaying Content` ) ).

    DATA(incl) = '==============================CP'.
    DATA(cl_name) = 'CL_SOME_CLASS                   '.

    "Addition ONLY is not specified: All blanks are replaced
    OVERLAY cl_name WITH incl.

    DATA(t1) = 'a.b.c.a.b.c.A'.
    DATA(t2) = 'z.x.y.Z.x.y.z'.

    "Addition ONLY is specified: All characters that are specified after ONLY and that
    "occur in the operand are replaced. Note that this is case-sensitive.
    OVERLAY t1 WITH t2 ONLY 'ab'.

    out->write( data = cl_name name = `cl_name` ).
    out->write( |\n| ).
    out->write( data = t1 name = `t1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) Processing Substrings` ) ).

    DATA(str_m1) = `Lorem ipsum dolor sit amet`.

    "Extracting substring starting at a specific position
    "'len' not specified means the rest of the remaining characters are
    "respected
    DATA(str_m2) = substring( val = str_m1 off = 6 ).

    "Extracting substring with a specific length
    "'off' is not specified and has the default value 0.
    DATA(str_m3) = substring( val = str_m1 len = 5 ).

    "Specifying both off and len parameters
    DATA(str_m4) = substring( val = str_m1 off = 6 len = 5 ).

    "Excursion: Getting last character of a string
    DATA(str_m5) = substring( val = str_m1
                              off = strlen( str_m1 ) - 1
                              len = 1 ). "t

    "Offset and length specification using the + sign after a variable
    "After +, it is the offset, length is specified within parentheses.
    DATA(str_m6) = str_m1+0(5).

    "* means respecting the rest of the remaining string
    DATA(str_m7) = str_m1+12(*).

    "Excursion: Write access on substrings in fixed-length strings
    DATA(char_m1) = 'Lorem ipsum dolor sit amet'.
    DATA(char_m2) = char_m1.
    DATA(char_m3) = char_m1.

    "Deleting content
    CLEAR char_m2+11(*).
    "Modifying string
    char_m3+0(5) = 'abcde'.

    "More string functions to access substrings
    "Note that lots of parameters are possible (not all covered here).
    DATA(str_m8) = `aa1bb2aa3bb4`.

    "Extracting a substring ...
    "... after a specified substring
    DATA(str_m9) = substring_after( val = str_m8 sub = `aa`  ).

    "... after a specified substring specifying the occurence in a
    "string and restricting the length
    DATA(str_m10) = substring_after( val = str_m8 sub = `aa`
                                     occ = 2 len = 4  ).

    "... before a specified substring
    DATA(str_m11) = substring_before( val = str_m8 sub = `b2` ).

    "... from a specified substring on. It includes the substring
    "specified in sub. len/off and other parameters are possible.
    DATA(str_m12) = substring_from( val = str_m8 sub = `a3` ).

    "... up to a specified substring. It includes the substring
    "specified in sub. len/off and other parameters are possible.
    "aa1bb2aa3b
    DATA(str_m13) = substring_to( val = str_m8 sub = `3b` ).

    out->write( data = str_m2 name = `str_m2` ).
    out->write( |\n| ).
    out->write( data = str_m3 name = `str_m3` ).
    out->write( |\n| ).
    out->write( data = str_m4 name = `str_m4` ).
    out->write( |\n| ).
    out->write( data = str_m5 name = `str_m5` ).
    out->write( |\n| ).
    out->write( data = str_m6 name = `str_m6` ).
    out->write( |\n| ).
    out->write( data = str_m7 name = `str_m7` ).
    out->write( |\n| ).
    out->write( data = char_m2 name = `char_m2` ).
    out->write( |\n| ).
    out->write( data = char_m3 name = `char_m3` ).
    out->write( |\n| ).
    out->write( data = str_m9 name = `str_m9` ).
    out->write( |\n| ).
    out->write( data = str_m10 name = `str_m10` ).
    out->write( |\n| ).
    out->write( data = str_m11 name = `str_m11` ).
    out->write( |\n| ).
    out->write( data = str_m12 name = `str_m12` ).
    out->write( |\n| ).
    out->write( data = str_m13 name = `str_m13` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Searching and Replacing in Strings` ) ).
    out->write( |15) Searching Specific Characters in Strings Using Comparison Operators and String Functions\n| ).

    DATA(str_n1) = `cheers`.

    "CA (contains any)
    "sy-fdpos contains the offset of the first found character.
    "If nothing is found, sy-fdpos contains the length of the string.
    "Note that position 0 stands for the very first position.
    IF str_n1 CA `aeiou`.
      out->write( |CA: str_n1 contains any of the characters. | &&
       |The position of the first found character is { sy-fdpos }.| ).
      out->write( |\n| ).
    ELSE.
      out->write( |CA: str_n1 does not contain any of the characters. | &&
             |The length of str_n1 is { sy-fdpos }.| ).
      out->write( |\n| ).
    ENDIF.

    "NA (contains not any)
    IF str_n1 NA `xyz`.
      out->write( |NA: str_n1 does not contain any of the characters.| &&
             |The length of str_n1 is { sy-fdpos }.| ).
      out->write( |\n| ).
    ELSE.
      out->write( |NA: str_n1 contains any of the characters. | &&
       |The position of the first found character is { sy-fdpos }.| ).
      out->write( |\n| ).
    ENDIF.

    "Determining if a string is exclusively composed of a certain
    "character set
    IF str_n1 CO `rs`.
      out->write( |CO: str_n1 contains only the characters. |
      && |The length of str_n1 is { sy-fdpos }.| ).
      out->write( |\n| ).
    ELSE.
      out->write( |CO: str_n1 does not contain only the characters. |
      && |Offset of the first character in str_n1 that is not |
      && |contained in the second operand: { sy-fdpos }.| ).
      out->write( |\n| ).
    ENDIF.

    "Negation of CO
    IF str_n1 CN `chers`.
      out->write( |CN: str_n1 does not contain only the characters. |
       && |Offset of the first character in str_n1 that is |
       && |not contained in the second operand: { sy-fdpos }.| ).
      out->write( |\n| ).
    ELSE.
      out->write( |CN: str_n1 contains only the characters. |
      && |The length of str_n1 is { sy-fdpos }.| ).
      out->write( |\n| ).
    ENDIF.

    "String functions
    DATA(str_n2) = `Pieces of cakes.`.

    "find_end returns the sum of the offset of the occurrence
    DATA(res_n3) = find_end( val = str_n2 sub = `of` ). "9

    "find_any_of returns the offset of the occurrence of any character contained in substring
    "The search is always case-sensitive.
    DATA(res_n4) = find_any_of( val = str_n2 sub = `x523z4e` ).
    DATA(res_n5) = find_any_of( val = str_n2 sub = `zwq85t` ).

    "find_any_not_of: Negation of the one above
    "The search is always case-sensitive.
    DATA(res_n6) = find_any_not_of( val = str_n2 sub = `ieces` ).
    DATA(res_n7) = find_any_not_of( val = str_n2 sub = `P` ).

    "count returns the number of all occurrences
    DATA(res_n8) = count( val = str_n2 sub = `e` ).
    DATA(res_n9) = count( val = str_n2 sub = `x` ).

    "count_any_of
    DATA(res_n10) = count_any_of( val = str_n2 sub = `x523z4e` ).
    DATA(res_n11) = count_any_of( val = str_n2 sub = `eco` ).

    "count_any_not_of
    DATA(res_n12) = count_any_not_of( val = str_n2 sub = `fP` ).
    DATA(res_n13) = count_any_not_of( val = str_n2 sub = `Piecs ofak.` ).

    out->write( data = res_n3 name = `res_n3` ).
    out->write( |\n| ).
    out->write( data = res_n4 name = `res_n4` ).
    out->write( |\n| ).
    out->write( data = res_n5 name = `res_n5` ).
    out->write( |\n| ).
    out->write( data = res_n6 name = `res_n6` ).
    out->write( |\n| ).
    out->write( data = res_n7 name = `res_n7` ).
    out->write( |\n| ).
    out->write( data = res_n8 name = `res_n8` ).
    out->write( |\n| ).
    out->write( data = res_n9 name = `res_n9` ).
    out->write( |\n| ).
    out->write( data = res_n10 name = `res_n10` ).
    out->write( |\n| ).
    out->write( data = res_n11 name = `res_n11` ).
    out->write( |\n| ).
    out->write( data = res_n12 name = `res_n12` ).
    out->write( |\n| ).
    out->write( data = res_n13 name = `res_n13` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Replacing Specific Characters in Strings` ) ).

    DATA(str_o1) = `___abc_def_____ghi_`.

    "The replacement is done as follows: Each character specified in
    "'from' is replaced by the character in 'to' that is on the same
    "position, i. e. the second character in 'from' is replaced by the
    "second character specified in 'to'. If there is no equivalent in
    "'to', the character in 'from' is removed from the result.

    "abcdefgZZ
    DATA(str_o2) = translate( val = str_o1 from = `hi_`  to = `ZZ` ).

    "ZZZabcZdefZZZZZghiZ
    DATA(str_o3) = translate( val = str_o1 from = `_`  to = `ZZ` ).

    "TRANSLATE statement. The value after USING is interpreted as a
    "string composed of character pairs. Starting with the first pair,
    "a search is performed in text for the first character in every
    "pair and each occurrence is replaced with the second character of
    "the pair.
    "...Zbc.def.....Yhi.
    TRANSLATE str_o1 USING `_.aZgY`.

    out->write( data = str_o2 name = `str_o2` ).
    out->write( |\n| ).
    out->write( data = str_o3 name = `str_o3` ).
    out->write( |\n| ).
    out->write( data = str_o1 name = `str_o1` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Searching for Substrings in Strings` ) ).
    out->write( |17) Substring Search: Simple Search Using Comparison Operators\n| ).

    DATA(str_p1) = `cheers`.

    "CS (contains string)
    "sy-fdpos contains the offset of the found substring.
    "If the substring is not found, sy-fdpos contains the length of the
    "searched string.
    IF str_p1 CS `rs`.
      out->write( |CS: The string contains the substring. |
      && |The offset is { sy-fdpos }.| ).
      out->write( |\n| ).
    ELSE.
      out->write( |CS: The string does not contain the substring. |
      && |The length of the string is { sy-fdpos }.| ).
      out->write( |\n| ).
    ENDIF.

    "NS (contains no string)
    IF str_p1 NS `abc`.
      out->write( |NS: The string does not contain the substring. |
      && |The length of the string is { sy-fdpos }.| ).
      out->write( |\n| ).
    ELSE.
      out->write( |NS: The string contains the substring. |
       && |The offset is { sy-fdpos }.| ).
      out->write( |\n| ).
    ENDIF.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) Substring Search in Strings ` &&
    `Using FIND Statements` ) ).
    "The code examples demonstrate different additions.

    DATA(str_qa) = `She sells seashells by the seashore.`.

    "Determining if a substring is found
    "Simple find statement
    FIND `se` IN str_qa.

    IF sy-subrc = 0.
      out->write( `'se' found in the string` ).
    ELSE.
      out->write( `'se' not found in the string` ).
    ENDIF.

    out->write( |\n| ).

    "Addition SUBSTRING is optional
    FIND SUBSTRING `hi` IN str_qa.

    IF sy-subrc = 0.
      out->write( `'hi' Found in the string` ).
    ELSE.
      out->write( `'hi' not found in the string` ).
    ENDIF.

    out->write( |\n| ).
    out->write( |\n| ).

    "The following examples use the additions MATCH COUNT and MATCH OFFSET
    "to determine the number of occurrences and offset and for display purposes.

    "Addition FIRST OCCURRENCE OF: Explicit specification to search
    "for the first occurrence
    FIND FIRST OCCURRENCE OF `se` IN str_qa
      MATCH COUNT DATA(cnt_q1)
      MATCH OFFSET DATA(off_q2).

    "Omitting FIRST OCCURRENCE OF and ALL OCCURRENCES OF addition means
    "searching for the first occurrence by default; same effect as the
    "previous statement
    FIND `se` IN str_qa
      MATCH COUNT DATA(cnt_q3)
      MATCH OFFSET DATA(off_q4).

    "Addition ALL OCCURRENCES: Searching for all occurrences
    FIND ALL OCCURRENCES OF `se` IN str_qa
      MATCH COUNT DATA(cnt_q5)
      MATCH OFFSET DATA(off_q6). "value for the last occurrence

    "Addition IN SECTION ... OF:
    "Searching in a specified section; both additions OFFSET and LENGTH
    "are specified
    FIND ALL OCCURRENCES OF `se`
      IN SECTION OFFSET 9 LENGTH 5 OF str_qa
      MATCH COUNT DATA(cnt_q7)
      MATCH OFFSET DATA(off_q8).

    "Only LENGTH specified (OFFSET is 0 by default)
    FIND ALL OCCURRENCES OF `se`
      IN SECTION LENGTH 7 OF str_qa
      MATCH COUNT DATA(cnt_q9)
      MATCH OFFSET DATA(off_q10).

    "Only OFFSET specified (LENGTH: up to end of string)
    FIND ALL OCCURRENCES OF `se`
      IN SECTION OFFSET 7 OF str_qa
      MATCH COUNT DATA(cnt_q11).

    "Another string to be searched
    DATA(str_qb) = `abap ABAP abap`.

    "Further additional options for advanced evaluation options

    "Specifying the case-sensitivity of the search
    "Not specifying the CASE addition means RESPECTING CASE is used by default.
    "Here, it is explicitly specified.
    FIND FIRST OCCURRENCE OF `A` IN str_qb
      MATCH OFFSET DATA(off_q12)
      RESPECTING CASE.

    "Making search case-insensitive
    FIND FIRST OCCURRENCE OF `A` IN str_qb
      MATCH OFFSET DATA(off_q13)
      IGNORING CASE.

    "MATCH LENGTH addition
    "The example uses a regular expression: Non-greedy search for
    "a substring starting with lower case a up to an upper case P
    FIND FIRST OCCURRENCE OF PCRE `a.*?P` IN str_qb
      MATCH LENGTH DATA(len_q14) "9
      RESPECTING CASE.

    "RESULTS addition
    "Example: Because of using ALL OCCURRENCES, the data object declared
    "inline automatically has the type match_result_tab
    FIND ALL OCCURRENCES OF `ab` IN str_qb
      RESULTS DATA(res_q15)
      IGNORING CASE.

    "Because of searching for the first occurrence, the data object declared
    "inline automatically has the type match_result
    FIND FIRST OCCURRENCE OF `ab` IN str_qb
      RESULTS DATA(res_q16)
      IGNORING CASE.

    out->write( data = cnt_q1 name = `cnt_q1` ).
    out->write( |\n| ).
    out->write( data = off_q2 name = `off_q2` ).
    out->write( |\n| ).
    out->write( data = cnt_q3 name = `cnt_q3` ).
    out->write( |\n| ).
    out->write( data = off_q4 name = `off_q4` ).
    out->write( |\n| ).
    out->write( data = cnt_q5 name = `cnt_q5` ).
    out->write( |\n| ).
    out->write( data = off_q6 name = `off_q6` ).
    out->write( |\n| ).
    out->write( data = cnt_q7 name = `cnt_q7` ).
    out->write( |\n| ).
    out->write( data = off_q8 name = `off_q8` ).
    out->write( |\n| ).
    out->write( data = cnt_q9 name = `cnt_q9` ).
    out->write( |\n| ).
    out->write( data = off_q10 name = `off_q10` ).
    out->write( |\n| ).
    out->write( data = cnt_q11 name = `cnt_q11` ).
    out->write( |\n| ).
    out->write( data = off_q12 name = `off_q12` ).
    out->write( |\n| ).
    out->write( data = off_q13 name = `off_q13` ).
    out->write( |\n| ).
    out->write( data = len_q14 name = `len_q14` ).
    out->write( |\n| ).
    out->write( data = res_q15 name = `res_q15` ).
    out->write( |\n| ).
    out->write( data = res_q16 name = `res_q16` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) Substring Search in Internal Tables ` &&
    `Using FIND ... IN TABLE Statements` ) ).

    DATA(str_table_r) = VALUE string_table( ( `aZbzZ` ) ( `cdZze` ) ( `Zzzf` ) ( `ghz` ) ).

    "Finding all occurrences in a table
    "Note: res_tab is of type match_result_tab
    "You can also restrict the search range in an internal table; see an example
    "in the context of REPLACE ... IN TABLE
    FIND ALL OCCURRENCES OF `Z`
      IN TABLE str_table_r
      RESULTS DATA(res_r1)
      RESPECTING CASE.

    "Finding the first occurrence in a table
    "Note: res_struc, which is declared inline here, is of type match_result
    FIND FIRST OCCURRENCE OF `Z`
      IN TABLE str_table_r
      RESULTS DATA(res_r2)
      RESPECTING CASE.

    "Alternative to the statement above (storing the information in individual data objects)
    FIND FIRST OCCURRENCE OF `Z`
      IN TABLE str_table_r
      MATCH LINE DATA(line_r3)
      MATCH OFFSET DATA(off_r4)
      MATCH LENGTH DATA(len_r5)
      RESPECTING CASE.

    out->write( data = res_r1 name = `res_r1` ).
    out->write( |\n| ).
    out->write( data = res_r2 name = `res_r2` ).
    out->write( |\n| ).
    out->write( data = line_r3 name = `line_r3` ).
    out->write( |\n| ).
    out->write( data = off_r4 name = `off_r4` ).
    out->write( |\n| ).
    out->write( data = len_r5 name = `len_r5` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) Substring Search in Strings ` &&
    `Using the String Function find` ) ).

    DATA(str_s) = `Pieces of cakes.`.

    "Searching for substring
    "Returns offset of substring found
    DATA(res_s1) = find( val = str_s sub = `ca` ).

    "Substring not found returns -1
    DATA(res_s2) = find( val = str_s sub = `xy` ).

    "Actual parameter of sub must not be initial when using the find function
    TRY.
        DATA(res_s3) = find( val = str_s sub = `` ).
      CATCH cx_sy_strg_par_val.
        "Nope!
    ENDTRY.

    "The search is case-sensitive by default
    DATA(res_s4) = find( val = str_s sub = `OF` ).
    "Making search case-insensitive
    DATA(res_s5) = find( val = str_s sub = `OF` case = abap_false ).

    "Specifying occ
    DATA(res_s6) = find( val = str_s sub = `c` ).
    DATA(res_s7) = find( val = str_s sub = `c` occ = 2 ).
    DATA(res_s8) = find( val = str_s sub = `e` occ = -1 ).
    DATA(res_s9) = find( val = str_s sub = `e` occ = -3 ).

    "Specifying off and len
    "Specifying a subarea in which a string is searched
    DATA(res_s10) = find( val = str_s sub = `e` off = 5 ).
    DATA(res_s11) = find( val = str_s sub = `e` off = 5 len = 7 ).
    DATA(res_s12) = find( val = str_s sub = `e` len = 2  ).

    out->write( data = res_s1 name = `res_s1` ).
    out->write( |\n| ).
    out->write( data = res_s2 name = `res_s2` ).
    out->write( |\n| ).
    out->write( data = res_s3 name = `res_s3` ).
    out->write( |\n| ).
    out->write( data = res_s4 name = `res_s4` ).
    out->write( |\n| ).
    out->write( data = res_s5 name = `res_s5` ).
    out->write( |\n| ).
    out->write( data = res_s6 name = `res_s6` ).
    out->write( |\n| ).
    out->write( data = res_s7 name = `res_s7` ).
    out->write( |\n| ).
    out->write( data = res_s8 name = `res_s8` ).
    out->write( |\n| ).
    out->write( data = res_s9 name = `res_s9` ).
    out->write( |\n| ).
    out->write( data = res_s10 name = `res_s10` ).
    out->write( |\n| ).
    out->write( data = res_s11 name = `res_s11` ).
    out->write( |\n| ).
    out->write( data = res_s12 name = `res_s12` ).
    out->write( |\n| ).

    "Demonstrating a false range to be searched
    TRY.
        DATA(res_s13) = find( val = str_s sub = `e` off = 5 len = 15 ).
      CATCH cx_sy_range_out_of_bounds.
        out->write( `The exception cx_sy_range_out_of_bounds was raised.` ).
    ENDTRY.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) Replacing Substrings in Strings Using REPLACE Statments` ) ).

    DATA(str_t) = `abap ABAP abap`.
    DATA(str_t1) = str_t.

    "Simple REPLACE statement
    "Omitting the FIRST OCCURRENCE and ALL OCCURRENCES OF additions means
    "replacing the first occurrence by default.
    REPLACE `ab` IN str_t1 WITH `##`.

    out->write( data = str_t1 name = `str_t1` ).
    out->write( |\n| ).
    DATA(str_t2) = str_t.

    "Addition SUBSTRING is optional; same effect as the statement above
    REPLACE SUBSTRING `ab` IN str_t2 WITH `##`.

    out->write( data = str_t2 name = `str_t2` ).
    out->write( |\n| ).
    DATA(str_t3) = str_t.

    "Addition FIRST OCCURRENCE OF: Explicit specification to replace the
    "first occurrence; same effect as the statements above
    REPLACE FIRST OCCURRENCE OF `ab` IN str_t3 WITH `##`.

    out->write( data = str_t3 name = `str_t3` ).
    out->write( |\n| ).
    DATA(str_t4) = str_t.

    "Addition ALL OCCURRENCES OF: All occurrences are replaced
    "Note that the replacement is case-sensitive by default.
    REPLACE ALL OCCURRENCES OF `ab` IN str_t4 WITH `##`.

    out->write( data = str_t4 name = `str_t4` ).
    out->write( |\n| ).
    DATA(str_t5) = str_t.

    "Further additional options for advanced evaluation options

    "IGNORING CASE addition: Making replacements case-insensitive
    REPLACE ALL OCCURRENCES OF `ab`
      IN str_t5 WITH `##`
      IGNORING CASE.

    out->write( data = str_t5 name = `str_t5` ).
    out->write( |\n| ).
    DATA(str_t6) = str_t.

    "REPLACEMENT COUNT addition
    REPLACE ALL OCCURRENCES OF `ab`
      IN str_t6 WITH `##`
      REPLACEMENT COUNT DATA(cnt_t7)
      IGNORING CASE.

    out->write( data = str_t6 name = `str_t6` ).
    out->write( |\n| ).
    out->write( data = cnt_t7 name = `cnt_t7` ).
    out->write( |\n| ).
    DATA(str_t8) = str_t.

    "REPLACEMENT OFFSET and LENGTH additions
    REPLACE FIRST OCCURRENCE OF `ap`
      IN str_t8 WITH `##`
      REPLACEMENT COUNT DATA(cnt_t9) "always 1 for replaced first occurrence
      REPLACEMENT OFFSET DATA(off_t10)
      REPLACEMENT LENGTH DATA(len_t11)
      IGNORING CASE.

    out->write( data = str_t8 name = `str_t8` ).
    out->write( |\n| ).
    out->write( data = cnt_t9 name = `cnt_t9` ).
    out->write( |\n| ).
    out->write( data = off_t10 name = `off_t10` ).
    out->write( |\n| ).
    out->write( data = len_t11 name = `len_t11` ).
    out->write( |\n| ).
    DATA(str_t12) = str_t.

    "SECTION ... OF addition: Replacing within a specified area
    REPLACE ALL OCCURRENCES OF `ap`
      IN SECTION OFFSET 4 LENGTH 5
      OF str_t12 WITH `##`
      REPLACEMENT COUNT DATA(cnt_t13)
      REPLACEMENT OFFSET DATA(off_t14)
      REPLACEMENT LENGTH DATA(len_t15)
      IGNORING CASE.

    out->write( data = str_t12 name = `str_t12` ).
    out->write( |\n| ).
    out->write( data = cnt_t13 name = `cnt_t13` ).
    out->write( |\n| ).
    out->write( data = off_t14 name = `off_t14` ).
    out->write( |\n| ).
    out->write( data = len_t15 name = `len_t15` ).
    out->write( |\n| ).
    DATA(str_t16) = str_t.

    "RESULTS additions with ...
    "... ALL OCCURRENCES OF
    "Note: The data object, which is declared inline here, is of type repl_result_tab.
    REPLACE ALL OCCURRENCES OF `ap`
      IN str_t16 WITH `##`
      RESULTS DATA(tab_t17)
      IGNORING CASE.

    out->write( data = str_t16 name = `str_t16` ).
    out->write( |\n| ).
    out->write( data = tab_t17 name = `tab_t17` ).
    out->write( |\n| ).
    DATA(str_t18) = str_t.

    "... FIRST OCCURRENCE OF
    "Note: The data object, which is declared inline here, is of type repl_result.
    REPLACE FIRST OCCURRENCE OF `ap`
      IN str_t18 WITH `##`
      RESULTS DATA(struc_t19)
      IGNORING CASE.

    out->write( data = str_t18 name = `str_t18` ).
    out->write( |\n| ).
    out->write( data = struc_t19 name = `struc_t19` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) Position-Based Replacements with REPLACE SECTION ... OF` ) ).

    DATA(str_u) = `abap ABAP abap`.
    DATA(str_u1) = str_u.

    "OFFSET and LENGTH specified
    REPLACE SECTION OFFSET 5 LENGTH 4 OF str_u1 WITH `#`.

    out->write( data = str_u1 name = `str_u1` ).
    out->write( |\n| ).
    DATA(str_u2) = str_u.

    "Only OFFSET specified, LENGTH: up to the end of the string
    REPLACE SECTION OFFSET 5 OF str_u2 WITH `#`.

    out->write( data = str_u2 name = `str_u2` ).
    out->write( |\n| ).
    DATA(str_u3) = str_u.

    "Only LENGTH specified, OFFSET: starting from the leftmost position
    REPLACE SECTION LENGTH 6 OF str_u3 WITH `#`.

    out->write( data = str_u3 name = `str_u3` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Replacements in Internal Tables with REPLACE ... IN TABLE` ) ).

    DATA(tab_v) = VALUE string_table( ( `aZbzZ` ) ( `cdZze` ) ( `Zzzf` ) ( `ghz` ) ).
    DATA(tab_v1) = tab_v.

    "Replacing all occurrences in a table
    "RESULTS addition: Storing information in an internal table of type repl_result_tab
    REPLACE ALL OCCURRENCES OF `Z`
      IN TABLE tab_v1
      WITH `#`
      RESULTS DATA(res_v2)
      RESPECTING CASE.

    out->write( data = tab_v1 name = `tab_v1` ).
    out->write( |\n| ).
    out->write( data = res_v2 name = `res_v2` ).
    out->write( |\n| ).
    DATA(tab_v3) = tab_v.

    "Replacing the first occurrence in a table
    "RESULTS addition: Storing information in a structure of type repl_result
    REPLACE FIRST OCCURRENCE OF `Z`
      IN TABLE tab_v3
      WITH `#`
      RESULTS DATA(res_v4)
      RESPECTING CASE.

    out->write( data = tab_v3 name = `tab_v3` ).
    out->write( |\n| ).
    out->write( data = res_v4 name = `res_v4` ).
    out->write( |\n| ).
    DATA(tab_v5) = tab_v.

    "Restricting the search range in an internal table
    REPLACE ALL OCCURRENCES OF `Z`
      IN TABLE tab_v5
      FROM 1 TO 2
      WITH `#`
      RESPECTING CASE.

    out->write( data = tab_v5 name = `tab_v5` ).
    out->write( |\n| ).
    DATA(tab_v6) = tab_v.

    "Offsets can be optionally specified (also only the offset of start or end line possible)
    REPLACE ALL OCCURRENCES OF `Z`
      IN TABLE tab_v6
      FROM 1 OFFSET 3 TO 2 OFFSET 2
      WITH `#`
      RESPECTING CASE.

    out->write( data = tab_v6 name = `tab_v6` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Replacing Substrings in Strings Using the String Function replace` ) ).

    DATA(str_w) = `abap ABAP abap`.

    "Note that here only the first occurrence is replaced.
    DATA(str_w_1) = replace( val = str_w sub = `ap` with = `#` ).

    "Making the search case-insensitive
    DATA(str_w_2) = replace( val = str_w sub = `AB` with = `#` case = abap_false ).

    "Setting occ
    DATA(str_w_3) = replace( val = str_w sub = `ab` with = `#` occ = 2 case = abap_false ).

    "Replacing all occurrences: Setting occ to 0
    DATA(str_w_4) = replace( val = str_w sub = `ab` with = `#` occ = 0 case = abap_false ).

    "Negative value for occ: Occurrences are counted from the right
    DATA(str_w_5) = replace( val = str_w sub = `ab` with = `#` occ = -1  ).

    "Setting off and len for determining a subarea for replacements
    "Note: When using off/len, sub and occ cannot be specified.
    "Specifying both off and len
    DATA(str_w_6) = replace( val = str_w  with = `#` off = 5 len = 3  ).

    "Specifying only off (len is 0 by default)
    DATA(str_w_7) = replace( val = str_w  with = `#` off = 2 ).

    "Note: When specifying only off and not specifying len or len = 0,
    "replace works like insert
    DATA(str_w_8) = insert( val = str_w sub = `#` off = 2  ).

    "Specifying only len (off is 0 by default): First segment of length in len is replaced
    DATA(str_w_9) = replace( val = str_w  with = `#` len = 3 ).

    "Special case
    "- off: equal to the length of the string
    "- len: not specified or 0
    "- Result: Value specified for 'with' is appended to the end of the string
    DATA(str_w_10) = replace( val = str_w  with = `#` off = strlen( str_w ) ).

    out->write( data = str_w_1 name = `str_w_1` ).
    out->write( |\n| ).
    out->write( data = str_w_2 name = `str_w_2` ).
    out->write( |\n| ).
    out->write( data = str_w_3 name = `str_w_3` ).
    out->write( |\n| ).
    out->write( data = str_w_4 name = `str_w_4` ).
    out->write( |\n| ).
    out->write( data = str_w_5 name = `str_w_5` ).
    out->write( |\n| ).
    out->write( data = str_w_6 name = `str_w_6` ).
    out->write( |\n| ).
    out->write( data = str_w_7 name = `str_w_7` ).
    out->write( |\n| ).
    out->write( data = str_w_8 name = `str_w_8` ).
    out->write( |\n| ).
    out->write( data = str_w_9 name = `str_w_9` ).
    out->write( |\n| ).
    out->write( data = str_w_10 name = `str_w_10` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Pattern-Based Searching and Replacing in Strings` ) ).
    out->write( `24) Simple Pattern-Based Searching ` &&
                     `Using Logical Operators` ).

    DATA(str_x) = `abc_def_ghi`.

    "CP (conforms to pattern)
    "*: Any character sequence (including blanks).
    "+: Any character (only one character, including blanks).
    "#: Escaping symbol. The following character is marked for an exact
    "comparison.
    "Note: Patterns are not case sensitive except for characters marked
    "by #. If a pattern is found, the system variable sy-fdpos returns
    "the offset of the first finding. Otherwise, it contains the length
    "of the searched string.
    IF str_x CP `*f#_*`.
      out->write( |CP: The string covers the pattern. |
      && |The offset is { sy-fdpos }.| ).
    ELSE.
      out->write( |CP: The string does not cover the pattern. |
      && |The length of the string is { sy-fdpos }.| ).
    ENDIF.

    out->write( |\n| ).

    "NP (does not conform to pattern)
    IF str_x NP `i+`.
      out->write( |NP: The string does not cover the pattern. |
      && |The length of the string is { sy-fdpos }.| ).
    ELSE.
      out->write( |NP: The string covers the pattern. |
      && |The offset is { sy-fdpos }.| ).
    ENDIF.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) Complex Searching Using ` &&
    `Regular Expressions` ) ).
    "Also note the cheat sheet example on regular expressions in ABAP.

    DATA(str_y) = `Cathy's black cat was fast asleep on the mat. ` &&
                  `Later that day, the cat played with Matt.`.

    "Using string functions

    "Determining the position of the first finding
    "here, parameter occ is 1 by default
    DATA(off_y1) = find( val = str_y  pcre = `at.` ).

    "Determining the number of findings
    "Considers all 'a' characters not followed by 't',
    "all 'at' plus 'att'
    DATA(cnt_y2) = count( val = str_y  pcre = `at*` ).
    "Considers all 'at' plus 'att' and so on
    DATA(cnt_y3) = count( val = str_y  pcre = `at+` ).

    "String function match
    "Extracting a substring matching a given pattern
    DATA(str_y_email1) = `The email address is jon.doe@email.com.`.
    DATA(str_y4) = match( val   = str_y_email1
                          pcre = `\w+(\.\w+)*@(\w+\.)+(\w{2,4})` ).

    "Predicate function matches
    "Checking a string if it matches a given pattern
    DATA(str_y_email2) = `jon.doe@email.com`.

    IF matches( val   = str_y_email2
                pcre = `\w+(\.\w+)*@(\w+\.)+(\w{2,4})` ).
      DATA(str_y5) = |{ str_y_email2 } is a valid email address.|.
    ELSE.
      str_y5 = |{ str_y_email2 } is not a valid email address.|.
    ENDIF.

    "Example with a false email
    DATA(str_y_email3) = `jon.doe@email.abcdef`.

    IF matches( val   = str_y_email3
                pcre = `\w+(\.\w+)*@(\w+\.)+(\w{2,4})` ).
      DATA(str_y6) = |{ str_y_email3 } is a valid email address.|.
    ELSE.
      str_y6 = |{ str_y_email3 } is not a valid email address.|.
    ENDIF.

    "Examples with the FIND statement
    "Storing submatches in variables.
    "Pattern: anything before and after ' on '
    FIND PCRE `(.*)\son\s(.*)` IN str_y
      SUBMATCHES DATA(subm_y7) DATA(subm_y8)
      IGNORING CASE.

    "Determining the number of letters in a string
    FIND ALL OCCURRENCES OF PCRE `[A-Za-z]`
      IN str_y
      MATCH COUNT DATA(cnt_y9).

    "Extracting all findings of a certain pattern in a string and
    "storing them in an internal table
    DATA tab_y10 TYPE string_table.

    "Pattern: An 'a' followed by any two characters
    FIND ALL OCCURRENCES OF PCRE `a..` IN str_y
      RESULTS DATA(res_y11).

    "The internal table includes the offset and length information of the individual findings.
    "The substrings are extracted from the original string based on that information and
    "added to an internal table of type string.
    LOOP AT res_y11 ASSIGNING FIELD-SYMBOL(<fs_y>).
      APPEND substring( val = str_y off = <fs_y>-offset len = <fs_y>-length ) TO tab_y10.
    ENDLOOP.

    "Searching in an internal table and retrieving line, offset, length information
    DATA(tab_y12) = VALUE string_table( ( `Cathy's black cat on the mat played with the friend of Matt.` )
                                        ( `Later that day, the cat played with Matt.` ) ).

    "Pattern: any character + 'y' followed by any character that is not a word character
    "Only the first occurrence is searched. The search is specified as case-insensitive (which is not relevant here).
    FIND FIRST OCCURRENCE OF PCRE `.y\W` IN TABLE tab_y12
       MATCH LINE DATA(line_y13)
       MATCH OFFSET DATA(off_y14)
       MATCH LENGTH DATA(len_y15)
       IGNORING CASE.

    "Pattern: any character + 'y' followed by any character that is not a word character
    "Here, all occurrences are searched and the result is stored in an internal table specified
    "after the RESULTS addition. Since a group is included in the PCRE pattern denoted by the
    "parentheses (\W), the resulting internal table includes entries in the 'submatches'
    "component holding offset/length information for the particular match.
    FIND ALL OCCURRENCES OF PCRE `.y(\W)` IN TABLE tab_y12
      RESULTS DATA(res_y16)
      IGNORING CASE.

    "Extracting all findings of certain patterns in a string and
    "storing them in an internal table; the capturing groups are
    "also evaluated
    DATA tab_y17 TYPE string_table.
    DATA(str_y18) = `az.ay.bx.bw.cv.cu.dt.ds.ar.bq`.

    FIND ALL OCCURRENCES OF PCRE `(a.)|(b.)|(c.)`
      IN str_y18
      RESULTS DATA(res_y19)
      IGNORING CASE.

    LOOP AT res_y19 ASSIGNING FIELD-SYMBOL(<fs_y20>).
      LOOP AT <fs_y20>-submatches ASSIGNING FIELD-SYMBOL(<fs_y21>).
        IF <fs_y21>-offset <> -1.
          APPEND |Substring "{ substring( val = str_y18 off = <fs_y21>-offset len = <fs_y21>-length ) }" found, capturing group { sy-tabix }| TO tab_y17.
        ENDIF.
      ENDLOOP.
    ENDLOOP.

    out->write( data = off_y1 name = `off_y1` ).
    out->write( |\n| ).
    out->write( data = cnt_y2 name = `cnt_y2` ).
    out->write( |\n| ).
    out->write( data = cnt_y3 name = `cnt_y3` ).
    out->write( |\n| ).
    out->write( data = str_y4 name = `str_y4` ).
    out->write( |\n| ).
    out->write( data = str_y5 name = `str_y5` ).
    out->write( |\n| ).
    out->write( data = str_y6 name = `str_y6` ).
    out->write( |\n| ).
    out->write( data = subm_y7 name = `subm_y7` ).
    out->write( |\n| ).
    out->write( data = subm_y8 name = `subm_y8` ).
    out->write( |\n| ).
    out->write( data = cnt_y9 name = `cnt_y9` ).
    out->write( |\n| ).
    out->write( data = tab_y10 name = `tab_y10` ).
    out->write( |\n| ).
    out->write( data = line_y13 name = `line_y13` ).
    out->write( |\n| ).
    out->write( data = off_y14 name = `off_y14` ).
    out->write( |\n| ).
    out->write( data = len_y15 name = `len_y15` ).
    out->write( |\n| ).
    out->write( data = res_y16 name = `res_y16` ).
    out->write( |\n| ).
    out->write( data = tab_y17 name = `tab_y17` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26) Replacing Using Regular Expressions` ) ).

    DATA(str_z) = `Cathy's black cat was fast asleep on the mat. ` &&
                   `Later that day, the cat played with Matt.`.

    "Considers all 'a' characters not followed by 't',
    "all 'at' plus 'att'
    "occ = 0 -> replaces all occurrences
    DATA(str_z1) = replace( val  = str_z
                            pcre = `at*`
                            with = `#`
                            occ  = 0 ).

    "Considers all 'at' plus 'att'
    DATA(str_z2) = replace( val  = str_z
                            pcre = `at+`
                            with = `#`
                            occ  = 0 ).

    "Replaces 2 'e' characters in a row
    DATA(str_z3) = replace( val  = str_z
                            pcre = `e{2}`
                            with = `#`
                            occ = 0 ).

    "Replaces 'ay'. Preceding d is optional ('day' is replaced too)
    DATA(str_z4) = replace( val  = str_z
                            pcre = `d?ay`
                            with = `#`
                            occ  = 0 ).

    "Subgroup specified, replacement happens if 'at' is followed
    "by 'h' or 't'
    DATA(str_z5) = replace( val  = str_z
                            pcre = `at(h|t)`
                            with = `#`
                            occ  = 0 ).

    "Replaces 'at' when followed by any whitespace character
    DATA(str_z6) = replace( val  = str_z
                            pcre = `at\s`
                            with = `#`
                            occ = 0 ).

    "Replacement starts at beginning of string that is followed by 'c'
    "Marked as not case sensitive
    "Instead of ^, you could also use \A
    DATA(str_z7) = replace( val  = str_z
                            pcre = `^c`
                            with = `#`
                            case = abap_false ).

    "Replacement starts at end of string
    "Instead of $, you could also use \Z
    DATA(str_z8) = replace( val  = str_z
                            pcre = `$`
                            with = ` Awesome!` ).

    "Replaces words starting with 'ma', ending with another character
    DATA(str_z9) = replace( val  = str_z
                            pcre = `\bma.\b`
                            with = `#`
                            case = abap_false
                            occ  = 0 ).

    "Replaces the beginning of words with 'ma' followed by another
    "character.
    "Marked as not case sensitive, hence 'Mat' is considered, too.
    DATA(str_z10) = replace( val  = str_z
                             pcre = `\bma.`
                             with = `#`
                             case = abap_false
                             occ  = 0 ).

    "Replaces a specified set of literals; if 'case = abap_false'
    "is not specified, case sensitivity is respected
    DATA(str_z11) = replace( val = str_z
                             pcre = `[eC'.,]`
                             with = `#`
                             occ = 0 ).

    "Replaces a specified value range
    DATA(str_z12) = replace( val  = str_z
                             pcre = `[a-eA-C0-9]`
                             with = `#`
                             occ  = 0 ).

    "Replaces a specified value range. The example is the negation
    "of the previous example.
    DATA(str_z13) = replace( val  = str_z
                             pcre = `[^a-eA-C0-9]`
                             with = `#`
                             occ = 0 ).

    DATA(str_zb) = `<p><i>Date:</i> 12/16/2022</p>` &&
                     `<br><p>Time: 10:30</p>`.

    "Replacements considering subgroups
    "Example switches the date format from US to European
    "Sequences of digits are specified as subgroups followed by /
    DATA(str_z15) = replace( val  = str_zb
                             pcre = `(\d+)/(\d+)/`
                             with = `$2.$1.` ).

    "Regex pitfall: Watch greediness when using PCRE expressions
    "Example: Replacing all HTML tags in a string
    DATA(str_z16) = replace( val  = str_zb
                             pcre = `<.*>`
                             with = ``
                             occ  = 0 ). "Whole string replaced

    "The following pattern considers '<' not followed by '>' which is
    "specified in a negated definition for a single character in the
    "brackets. Then '*' greedily, matches anything until the next '>'.
    DATA(str_z17) = replace( val  = str_zb
                             pcre = `<[^>]*>`
                             with = ``
                             occ = 0 ).

    "Positive lookahead: Replaces colons followed by digits
    DATA(str_z18) = replace( val  = str_zb
                             pcre = `:(?=\d+)`
                             with = `.`
                             occ  = 0 ).

    "Negative lookahead: Removes colons not followed by digits
    ":(?!(\d+))
    DATA(str_z19) = replace( val  = str_zb
                             pcre = `:(?!\d+)`
                             with = ``
                             occ  = 0 ).

    "Positive Lookbehind: Replaces a digit preceded by a blank
    DATA(str_z20) = replace( val  = str_zb
                             pcre = `(?<=\s)\d`
                             with = `0`
                             occ  = 0 ).

    "Negative lookbehind: Determines the position before closing p tags
    "not preceded by 4 digits
    DATA(str_z21) = replace( val  = str_zb
                             pcre = `(?<!\d{4})(<\/p>)`
                             with = `:00$1`
                             occ  = 0 ).

    DATA(str_zc) = `ab apppc app`.

    "Greedy search
    "The pattern matches anything before 'p'. The matching is carried
    "out as often as possible. Hence, in this example the match
    "stretches until the end of the string since 'p' is the final
    "character, i. e. this 'p' and anything before is replaced).
    DATA(str_z23) = replace( val  = str_zc
                             pcre = `.*p`
                             with = `#` ).

    "Non-greedy search (denoted by '?' below)
    "The pattern matches anything before 'p'. The matching proceeds
    "until the first 'p' is found and does not go beyond (matching as
    "few as possible). Hence, the first found 'p' including the content
    "before is replaced.
    DATA(str_z24) = replace( val  = str_zc
                             pcre = `.*?p`
                             with = `#` ).

    "Replacements with subgroups
    "Replaces 'PP' (case-insensitive) with '#', the content before and
    "after 'PP' is switched
    DATA(str_z25) = replace( val  = str_zc
                             pcre = `(.*?)PP(.*)`
                             with = `$2#$1`
                             case = abap_false ).

    "REPLACE statement: Changing the source field directly
    REPLACE PCRE `(.*?)PP(.*)` IN str_zc WITH `$2#$1` IGNORING CASE.

    "Replacements in internal tables
    DATA(itab_z) = VALUE string_table( ( `Cathy's black cat was fast asleep on the mat.` )
                                       ( `Later that day, the cat played with Matt.` )
                                       ( `How about that?` ) ).

    "Replaces all 'th' occurrences in words beginning with 'th'
    REPLACE ALL OCCURRENCES OF PCRE `\bth`
     IN TABLE itab_z WITH `#`
     REPLACEMENT COUNT DATA(cnt_z26)
     IGNORING CASE .

    out->write( data = |Original str_z: { str_z }\n| ).
    out->write( |\n| ).
    out->write( data = str_z1 name = `str_z1` ).
    out->write( |\n| ).
    out->write( data = str_z2 name = `str_z2` ).
    out->write( |\n| ).
    out->write( data = str_z3 name = `str_z3` ).
    out->write( |\n| ).
    out->write( data = str_z4 name = `str_z4` ).
    out->write( |\n| ).
    out->write( data = str_z5 name = `str_z5` ).
    out->write( |\n| ).
    out->write( data = str_z6 name = `str_z6` ).
    out->write( |\n| ).
    out->write( data = str_z7 name = `str_z7` ).
    out->write( |\n| ).
    out->write( data = str_z8 name = `str_z8` ).
    out->write( |\n| ).
    out->write( data = str_z9 name = `str_z9` ).
    out->write( |\n| ).
    out->write( data = str_z10 name = `str_z10` ).
    out->write( |\n| ).
    out->write( data = str_z11 name = `str_z11` ).
    out->write( |\n| ).
    out->write( data = str_z12 name = `str_z12` ).
    out->write( |\n| ).
    out->write( data = str_z3 name = `str_z13` ).
    out->write( |\n| ).
    out->write( data = |Original str_zb: { str_zb }\n| ).
    out->write( |\n| ).
    out->write( data = str_z15 name = `str_z15` ).
    out->write( |\n| ).
    out->write( data = str_z16 name = `str_z16` ).
    out->write( |\n| ).
    out->write( data = str_z17 name = `str_z17` ).
    out->write( |\n| ).
    out->write( data = str_z18 name = `str_z18` ).
    out->write( |\n| ).
    out->write( data = str_z19 name = `str_z19` ).
    out->write( |\n| ).
    out->write( data = str_z20 name = `str_z20` ).
    out->write( |\n| ).
    out->write( data = str_z21 name = `str_z21` ).
    out->write( |\n| ).
    out->write( data = |Original str_zc: { str_zc }\n| ).
    out->write( |\n| ).
    out->write( data = str_z23 name = `str_z23` ).
    out->write( |\n| ).
    out->write( data = str_z24 name = `str_z24` ).
    out->write( |\n| ).
    out->write( data = str_z25 name = `str_z25` ).
    out->write( |\n| ).
    out->write( data = str_zc name = `str_zc` ).
    out->write( |\n| ).
    out->write( data = itab_z name = `itab_z` ).
    out->write( |\n| ).
    out->write( data = |Number of replacements in itab (cnt_z26): { cnt_z26 }| ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `27) Excursion: System Classes for Regular Expressions` ) ).

    "Searching for all occurrences
    DATA(some_string) = `a1 # B2 ? cd . E3`.

    "Creating a regex instance for PCRE regular expressions
    "In the example, regex_inst has the type ref to cl_abap_regex.
    DATA(regex_inst) =  cl_abap_regex=>create_pcre( pattern = `\D\d`           "any-non digit followed by a digit
                                                    ignore_case = abap_true ).

    "Creating an instance of CL_ABAP_MATCHER using the method CREATE_MATCHER of the class CL_ABAP_REGEX
    DATA(matcher_1) = regex_inst->create_matcher( text = some_string ).

    "Searching for all occurrences using the 'find_all' method
    "In the example, result has the type match_result_tab containing the findings.
    DATA(result1) = matcher_1->find_all( ).

    out->write( data = result1 name = `result1` ).
    out->write( |\n| ).

    "You can also use method chaining to save lines of code
    DATA(result2) = cl_abap_regex=>create_pcre( pattern = `\s\w`       "any blank followed by any word character
                                                ignore_case = abap_true )->create_matcher( text = some_string )->find_all( ).

    out->write( data = result2 name = `result2` ).
    out->write( |\n| ).

    "Retrieving submatches using the 'get_submatch' method
    DATA str_tab_reg_find TYPE string_table.

    DATA(matcher_2) = cl_abap_regex=>create_pcre( pattern = 'A(.*?)B(.*?)C(.*?)'
                                                  ignore_case = abap_false )->create_matcher( text = 'A.12az.B.34by.C.56cx.D.78dw.E' ).

    IF matcher_2->match( ).
      DO.
        TRY.
            APPEND matcher_2->get_submatch( sy-index ) TO str_tab_reg_find.
          CATCH cx_sy_invalid_submatch cx_sy_no_current_match.
            EXIT.
        ENDTRY.
      ENDDO.
    ENDIF.

    out->write( data = str_tab_reg_find name = `str_tab_reg_find` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `More String Functions` ) ).
    out->write( `29) Checking the Similarity of Strings` ).
    out->write( |\n| ).

    DATA(str_to_check) = `abap`.
    DATA(dist1) = distance( val1 = str_to_check val2 = `abap` ).
    DATA(dist2) = distance( val1 = str_to_check val2 = `axbap` ).
    DATA(dist3) = distance( val1 = str_to_check val2 = `yabyyapy` ).
    DATA(dist4) = distance( val1 = str_to_check val2 = `zabapzzzzzzzzzzzz` max = 5 ).

    out->write( data = dist1 name = `dist1` ).
    out->write( |\n| ).
    out->write( data = dist2 name = `dist2` ).
    out->write( |\n| ).
    out->write( data = dist3 name = `dist3` ).
    out->write( |\n| ).
    out->write( data = dist4 name = `dist4` ).
    out->write( |\n| ).

    "If the value of max is 0 or less, an exception is raised.
    TRY.
        DATA(dist5) = distance( val1 = str_to_check val2 = `#ab#ap#` max = 0 ).
      CATCH cx_sy_strg_par_val INTO DATA(dist_err).
        out->write( data = dist_err->get_text( ) name = `dist_err->get_text( )` ).
    ENDTRY.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `30) Repeating Strings` ) ).

    DATA(repeat1) = repeat( val = `abap` occ = 5 ).
    DATA(repeat2) = |#{ repeat( val = ` ` occ = 10 ) }#|.
    DATA(repeat3) = COND #( WHEN repeat( val = `a` occ = 0 ) = `` THEN `Y` ELSE `Z` ).

    out->write( data = repeat1 name = `repeat1` ).
    out->write( |\n| ).
    out->write( data = repeat2 name = `repeat2` ).
    out->write( |\n| ).
    out->write( data = repeat3 name = `repeat2` ).
    out->write( |\n| ).

    "If occ has a negative value, an exception is raised.
    TRY.
        DATA(repeat4) = repeat( val = `X` occ = -3 ).
      CATCH cx_sy_strg_par_val INTO DATA(rep_err).
        out->write( data = rep_err->get_text( ) name = `rep_err->get_text( )` ).
    ENDTRY.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `31) Returning the Smallest/Biggest of a Set of Character-Like Arguments` ) ).

    DATA(min) =  cmin( val1 = `zzzzzzz`
                   val2 = `zzazzzzzzzz`
                   val3 = `zzzzabc` ).

    DATA(max) =  cmax( val1 = `abcdef`
                       val2 = `aaghij`
                       val3 = `aaaaklmn`
                       val4 = `aaaaaaopqrs`
                       val5 = `aaaaaaaaaatuvwxy`
                       val6 = `aaaaaaaaaaaaaz` ).

    out->write( data = min name = `min` ).
    out->write( |\n| ).
    out->write( data = max name = `max` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32) Escaping Special Characters` ) ).

    "Context: URLs
    DATA(esc1) = escape( val    = '...test: 5@8...'
                         format = cl_abap_format=>e_url_full ).

    "Context: JSON
    DATA(esc2) = escape( val    = 'some "test" json \ with backslash and double quotes'
                         format = cl_abap_format=>e_json_string ).

    "Context: String templates
    DATA(esc3) = escape( val    = 'Special characters in string templates: |, \, {, }'
                         format = cl_abap_format=>e_string_tpl ).

    out->write( data = esc1 name = `esc1` ).
    out->write( |\n| ).
    out->write( data = esc2 name = `esc2` ).
    out->write( |\n| ).
    out->write( data = esc3 name = `esc3` ).
    out->write( |\n| ).

    "Invalid value for the format parameter
    TRY.
        DATA(esc4) = escape( val    = 'This will raise an exception due to an invalid format value.'
                             format = 123 ).
      CATCH cx_sy_strg_par_val INTO DATA(esc_err).
        out->write( data = esc_err->get_text( ) name = `esc_err->get_text( )` ).
    ENDTRY.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `33) Excursion: String Processing Using the XCO Library` ) ).

    "--------- Extracting a substring from a string ---------
    DATA(abc) = `abcdefghijklmnopqrstuvwxyz`.

    "Creating an encapsulation of a string using XCO
    DATA(str) = xco_cp=>string( abc ).

    "Using the FROM and TO methods, you can determine
    "the character position. Note that the value includes the
    "character at the position specified.
    "The character index pattern for the example string above
    "is (the string has 26 characters in total):
    "a = 1, b = 2, c = 3 ... z = 26
    "a = -26, b = -25, c = -24 ... z = -1
    "Providing a value that is out of bounds means that
    "the first (or the last) character of the string is used
    "by default.
    "Note: When combining FROM and TO, e.g. with method
    "chaining ...->from( ...)->to( ... ), note that another
    "instance is created with the first 'from', and another
    "character index pattern is created based on the new
    "and adjusted string value.

    DATA(sub1) = str->from( 2 )->value.
    DATA(sub2) = str->from( -23 )->value.
    DATA(sub3) = str->from( -5 )->value.
    DATA(sub4) = str->to( 5 )->value.
    DATA(sub5) = str->to( -25 )->value.
    DATA(sub6) = str->from( 2 )->to( 6 )->value.
    DATA(sub7) = str->to( -10 )->from( 4 )->value.
    "Values that are out of bounds.
    DATA(sub8) = str->from( 0 )->to( 100 )->value.

    out->write( data = sub1 name = `sub1` ).
    out->write( |\n| ).
    out->write( data = sub2 name = `sub2` ).
    out->write( |\n| ).
    out->write( data = sub3 name = `sub3` ).
    out->write( |\n| ).
    out->write( data = sub4 name = `sub4` ).
    out->write( |\n| ).
    out->write( data = sub5 name = `sub5` ).
    out->write( |\n| ).
    out->write( data = sub6 name = `sub6` ).
    out->write( |\n| ).
    out->write( data = sub7 name = `sub7` ).
    out->write( |\n| ).
    out->write( data = sub8 name = `sub8` ).
    out->write( |\n| ).

    "--------- Splitting and joining ---------

    "Splitting a string into a string table
    DATA(str_table) = xco_cp=>string( `Hello.World.ABAP` )->split( `.` )->value.

    "Concatenating a string table into a string; specifying a delimiter
    str_table = VALUE #( ( `a` ) ( `b` ) ( `c` ) ).

    DATA(conc_str1) = xco_cp=>strings( str_table )->join( `, ` )->value.

    "Concatenating a string table into a string; specifying a delimiter and
    "reversing the table order
    DATA(conc_str2) = xco_cp=>strings( str_table )->reverse( )->join( ` / ` )->value.

    out->write( data = str_table name = `str_table` ).
    out->write( |\n| ).
    out->write( data = conc_str1 name = `conc_str1` ).
    out->write( |\n| ).
    out->write( data = conc_str2 name = `conc_str2` ).
    out->write( |\n| ).

    "--------- Prepending and appending strings ---------
    DATA(name) = xco_cp=>string( `Max Mustermann` ).
    DATA(address) = name->append( `, Some Street 1, 12345 Someplace` )->value.
    DATA(title) = name->prepend( `Mr. ` )->value.

    out->write( data = address name = `address` ).
    out->write( |\n| ).
    out->write( data = title name = `title` ).
    out->write( |\n| ).

    "--------- Transforming to lowercase and uppercase ---------
    DATA(to_upper) = xco_cp=>string( `abap` )->to_upper_case( )->value.
    DATA(to_lower) = xco_cp=>string( `HALLO WORLD` )->to_lower_case( )->value.

    out->write( data = to_upper name = `to_upper` ).
    out->write( |\n| ).
    out->write( data = to_lower name = `to_lower` ).
    out->write( |\n| ).

    "--------- Checking if a string starts/ends with a specific string ---------
    DATA check TYPE string.
    DATA(str_check) = xco_cp=>string( `Max Mustermann` ).

    "yes
    IF str_check->ends_with( `mann` ).
      check = `yes`.
    ELSE.
      check = `no`.
    ENDIF.

    out->write( data = check name = `check` ).
    out->write( |\n| ).

    "no
    IF str_check->starts_with( `John` ).
      check = `yes`.
    ELSE.
      check = `no`.
    ENDIF.

    out->write( data = check name = `check` ).
    out->write( |\n| ).

    "--------- Converting strings to xstrings using a codepage ---------
    DATA(xstr) = xco_cp=>string( `Some string` )->as_xstring( xco_cp_character=>code_page->utf_8 )->value.

    out->write( data = xstr name = `xstr` ).
    out->write( |\n| ).

    "--------- Camel case compositions and decompositions with split and join operations ---------
    "Pascal case is also possible
    DATA(comp) = xco_cp=>string( `some_value` )->split( `_` )->compose( xco_cp_string=>composition->camel_case )->value.
    DATA(decomp) = xco_cp=>string( `someValue` )->decompose( xco_cp_string=>decomposition->camel_case )->join( `_` )->value.

    out->write( data = comp name = `comp` ).
    out->write( |\n| ).
    out->write( data = decomp name = `decomp` ).
    out->write( |\n| ).

    "--------- Matching string against regular expression ---------
    DATA match TYPE string.

    "yes
    IF xco_cp=>string( ` 1` )->matches( `\s\d` ).
      match = 'yes'.
    ELSE.
      match = 'no'.
    ENDIF.

    out->write( data = match name = `match` ).
    out->write( |\n| ).

    "no
    IF xco_cp=>string( ` X` )->matches( `\s\d` ).
      match = 'yes'.
    ELSE.
      match = 'no'.
    ENDIF.

    out->write( data = match name = `match` ).

***********************************************************************

    "------------------------ Byte String Processing ------------------------

    out->write( zcl_demo_abap_aux=>heading( `34) Determining the Length of xstrings` ) ).

    DATA(hi) = `Hello world`.

    DATA(conv_xstring) = cl_abap_conv_codepage=>create_out( codepage = `UTF-8` )->convert( hi ).

    DATA(len_str) = strlen( CONV string( conv_xstring ) ).
    out->write( data = len_str name = `len_str` ).

    DATA(len_xstr) = xstrlen( conv_xstring ).
    out->write( data = len_xstr name = `len_xstr` ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `35) Character String and Byte String Processing with ABAP Statements` ) ).

    DATA off TYPE i.
    DATA(abc_str) = `abc def ghi jkl mno pqr stu vwx yz`.
    DATA(copy_str) = abc_str.

    "-----------------------------------------------------------------------------
    "------------------------ FIND and REPLACE statements ------------------------
    "-----------------------------------------------------------------------------

    "------------------------ IN CHARACTER MODE addition ------------------------

    "Searching for the first blank in the string
    FIND ` ` IN abc_str IN CHARACTER MODE MATCH OFFSET off.

    "The following example is the same as the previous as the IN CHARACTER MODE
    "addition is optional. The FIRST OCCURRENCE OF addition is also optional.
    "Just using FIND without FIRST OCCURRENCE OF means searching for the first
    "occurrence by default.
    FIND FIRST OCCURRENCE OF ` ` IN abc_str MATCH OFFSET off.

    "Searching for all blanks in the string
    FIND ALL OCCURRENCES OF ` ` IN abc_str IN CHARACTER MODE RESULTS DATA(res).
    DATA(offsets_of_findings) = concat_lines_of(
      table = VALUE string_table( FOR wa IN res ( condense( val = CONV string( wa-offset ) to = `` ) ) )  sep = `, ` ).

    "Replacing the first blank in the string
    REPLACE ` ` IN abc_str WITH `#` IN CHARACTER MODE.

    abc_str = copy_str.

    "Replacing all blanks in the string
    REPLACE ALL OCCURRENCES OF ` ` IN abc_str WITH `#` IN CHARACTER MODE.

    abc_str = copy_str.

    "------------------------ IN BYTE MODE addition ------------------------

    "Converting to xstring
    DATA(abc_xstr) = cl_abap_conv_codepage=>create_out( )->convert( abc_str ).
    DATA(blank_xstr) = cl_abap_conv_codepage=>create_out( )->convert( ` ` ).
    DATA(repl_xstr) = cl_abap_conv_codepage=>create_out( )->convert( `#` ).
    DATA(copy_xstr) = abc_xstr.

    "Searching for the first byte that represents a blank in the UTF-8 code page
    FIND blank_xstr IN abc_xstr IN BYTE MODE MATCH OFFSET off.

    FIND ALL OCCURRENCES OF blank_xstr IN abc_xstr IN BYTE MODE RESULTS res.
    DATA(offsets_of_findings_xstr) = concat_lines_of(
      table = VALUE string_table( FOR wa IN res ( condense( val = CONV string( wa-offset ) to = `` ) ) )  sep = `, ` ).

    "Replacing the first byte that represents a blank in the UTF-8 code page
    REPLACE blank_xstr IN abc_xstr WITH repl_xstr IN BYTE MODE.

    abc_xstr = copy_xstr.

    "Replacing all bytes that represent a blank in the UTF-8 code page
    REPLACE ALL OCCURRENCES OF blank_xstr IN abc_xstr WITH repl_xstr IN BYTE MODE.

    "-----------------------------------------------------------------------------
    "--------------------------- CONCATENATE statements --------------------------
    "-----------------------------------------------------------------------------

    DATA(part_str1) = `abc`.
    DATA(part_str2) = `def`.

    CONCATENATE part_str1 part_str2 INTO DATA(concat_str) IN CHARACTER MODE.

    CONCATENATE part_str1 part_str2 INTO concat_str SEPARATED BY `/` IN CHARACTER MODE.

    "Same as above
    CONCATENATE part_str1 part_str2 INTO concat_str.
    CONCATENATE part_str1 part_str2 INTO concat_str SEPARATED BY `/`.

    DATA(part_xstr1) = cl_abap_conv_codepage=>create_out( )->convert( part_str1 ).
    DATA(part_xstr2) = cl_abap_conv_codepage=>create_out( )->convert( part_str2 ).
    DATA(sep_xstr) = cl_abap_conv_codepage=>create_out( )->convert( `/` ).

    CONCATENATE part_xstr1 part_xstr2 INTO DATA(concat_xstr) IN BYTE MODE.

    DATA(concat_xstr_converted) = cl_abap_conv_codepage=>create_in( )->convert( concat_xstr ).

    CONCATENATE part_xstr1 part_xstr2 INTO concat_xstr SEPARATED BY sep_xstr IN BYTE MODE.

    concat_xstr_converted = cl_abap_conv_codepage=>create_in( )->convert( concat_xstr ).

    "Creating a table of type xstring
    DATA(xstr_table) = VALUE xstring_table( ( part_xstr1 ) ( part_xstr2 ) ).

    CONCATENATE LINES OF xstr_table INTO DATA(concat_xstr_tab) IN BYTE MODE.

    DATA(concat_xstr_tab_converted) = cl_abap_conv_codepage=>create_in( )->convert( concat_xstr_tab ).

    "-----------------------------------------------------------------------------
    "------------------------------- SHIFT statements ----------------------------
    "-----------------------------------------------------------------------------

    DATA(test_string) = `abcdef`.
    DATA(copy) = test_string.

    SHIFT test_string IN CHARACTER MODE.

    test_string = copy.

    "Same as
    SHIFT test_string.

    test_string = copy.

    DATA(test_xstr) = cl_abap_conv_codepage=>create_out( )->convert( test_string ).

    SHIFT test_xstr IN BYTE MODE.

    "-----------------------------------------------------------------------------
    "------------------------------- SPLIT statements ----------------------------
    "-----------------------------------------------------------------------------

    test_string = `abc def`.

    SPLIT test_string AT space INTO DATA(test_str1) DATA(test_str2) IN CHARACTER MODE.
    SPLIT test_string AT space INTO TABLE DATA(tab_str) IN CHARACTER MODE.

    "Same as above
    SPLIT test_string AT space INTO test_str1 test_str2.
    SPLIT test_string AT space INTO TABLE tab_str.

    test_xstr = cl_abap_conv_codepage=>create_out( )->convert( test_string ).

    blank_xstr = cl_abap_conv_codepage=>create_out( )->convert( ` ` ).

    SPLIT test_xstr AT blank_xstr INTO DATA(xstr1) DATA(xstr2) IN BYTE MODE.
    SPLIT test_xstr AT blank_xstr INTO TABLE DATA(xstr_tab) IN BYTE MODE.

    out->write( zcl_demo_abap_aux=>no_output ).

  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_structures DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS: class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    "Creating structured data types
    TYPES: "Flat structure
      BEGIN OF gty_struc,
        num1  TYPE i,
        num2  TYPE i,
        char1 TYPE c LENGTH 10,
        char2 TYPE c LENGTH 5,
        pnum  TYPE p LENGTH 8 DECIMALS 2,
      END OF gty_struc,
      "Structures within deep structure
      BEGIN OF line1,
        col1 TYPE i,
        col2 TYPE i,
      END OF line1,
      BEGIN OF line2,
        col2 TYPE i,
        col3 TYPE i,
        col4 TYPE i,
      END OF line2.

    CLASS-DATA:
      "Flat structure
      gs_struc TYPE gty_struc,
      "Deep structure 1
      BEGIN OF gs_deep1,
        comp1 TYPE c LENGTH 1 VALUE 'W',
        BEGIN OF substruc,
          comp1 TYPE c LENGTH 1 VALUE 'X',
          BEGIN OF comp2,
            col1 TYPE c LENGTH 1 VALUE 'Y',
            col2 TYPE c LENGTH 1 VALUE 'Z',
          END OF comp2,
        END OF substruc,
        itab  TYPE TABLE OF line1 WITH EMPTY KEY,
      END OF gs_deep1,
      "Deep structure 2
      BEGIN OF gs_deep2,
        BEGIN OF substruc,
          comp1 TYPE string,
          comp2 TYPE string,
          comp3 TYPE string,
        END OF substruc,
        itab  TYPE TABLE OF line2 WITH EMPTY KEY,
        comp4 TYPE i,
      END OF gs_deep2,
      "Creating internal table for displaying purposes
      gt_tab TYPE STANDARD TABLE OF zdemo_abap_tab1
          WITH NON-UNIQUE KEY key_field.

    CLASS-METHODS:
      initialize_dbtabs,
      fill_deep_structures,
      select_from_dbtab.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_structures IMPLEMENTATION.


  METHOD class_constructor.
    initialize_dbtabs( ).
    fill_deep_structures( ).
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.


  METHOD fill_deep_structures.
    "Clearing all content of gs_deep2
    CLEAR gs_deep2.
    "Filling nested tables in deep structures
    gs_deep2-substruc = VALUE #( comp1 = `aaa`
                                 comp2 = `bbb`
                                 comp3 = `ccc` ).

    gs_deep1-itab = VALUE #(
      ( col1 = 111 col2 = 222 )
      ( col1 = 333 col2 = 444
      ) ).

    gs_deep2-itab = VALUE #(
      ( col2 = 1 col3 = 2 col4 = 3 )
      ( col2 = 4 col3 = 5 col4 = 6 )
      ( col2 = 7 col3 = 8 col4 = 9 )
      ).

    "Filling individual component that is not shared by both structures
    gs_deep2-comp4 = 999.
  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP cheat sheet example: Structures\n\n| ).

**********************************************************************

    out->write( |1) Globally available structures and structured types\n| ).

    "Creating structures based on globally available structured types
    "Database table
    DATA struc_from_dbtab TYPE zdemo_abap_fli.
    "CDS view entity
    DATA struc_from_cds_ve TYPE zdemo_abap_fli.
    "CDS abstract entity
    DATA struc_from_cds_abs TYPE zdemo_abap_abstract_ent.
    "CDS table function
    DATA struc_from_cds_tab_func TYPE zdemo_abap_table_function.

    "Globally available structured type in the public visibility section of
    "classes/interfaces
    DATA struc_from_struc_type_in_cl TYPE zcl_demo_abap_amdp=>fli_struc.

    "Creating structured types based on globally available structured types
    TYPES ty_struc_from_dbtab TYPE zdemo_abap_fli.
    TYPES ty_struc_from_cds_ve TYPE zdemo_abap_fli.

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Nested structure` ) ).

    "The following declarations are just included for demonstration purposes
    "to show how declarations of local structures and structured
    "types can look like.

    "Declaring structured type locally (flat structure)
    TYPES: BEGIN OF lty_struc,
             num1  TYPE i,
             num2  TYPE i,
             char1 TYPE c LENGTH 10,
             char2 TYPE c LENGTH 5,
             pnum  TYPE p LENGTH 8 DECIMALS 2,
           END OF lty_struc.

    "Alternatively, you could use the following syntax.
    "However, a chained statement as above provides better readability.
    TYPES BEGIN OF gs_struc_alt.
    TYPES num1    TYPE i.
    TYPES num2    TYPE i.
    TYPES char1   TYPE c LENGTH 10.
    TYPES char2   TYPE c LENGTH 5.
    TYPES pnum    TYPE p LENGTH 8 DECIMALS 2.
    TYPES END OF gs_struc_alt.

    "Creating local structures
    "a. Based on a local structured type.
    DATA ls_struc TYPE lty_struc.

    "b. Based on global types in the DDIC
    DATA ls_glo_tab TYPE zdemo_abap_flsch. "database table

    "c. Directly declaring a structure with DATA and specifying the components
    DATA: BEGIN OF ls_direct_decl,
            num1  TYPE i,
            num2  TYPE i,
            char1 TYPE c LENGTH 10,
            char2 TYPE c LENGTH 5,
            pnum  TYPE p LENGTH 8 DECIMALS 2,
          END OF ls_direct_decl.

    "d. Alternatively, you could use the following syntax.
    "However, a chained statement as above provides better readability.
    DATA BEGIN OF ls_direct_decl_alt.
    DATA num1    TYPE i.
    DATA num2    TYPE i.
    DATA char1   TYPE c LENGTH 10.
    DATA char2   TYPE c LENGTH 5.
    DATA pnum    TYPE p LENGTH 8 DECIMALS 2.
    DATA END OF ls_direct_decl_alt.

    "e. Based on structure and internal table (type)
    DATA ls_like_dobj LIKE ls_struc.
    DATA ls_like_line_of_itab LIKE LINE OF gt_tab.
    DATA ls_type_line_of_itab TYPE LINE OF string_table.

    "f. Using inline declaration.
    "Type is inferred from the right-hand structure; the content is also assigned
    DATA(struc_inl1) = ls_struc.

    "Declaring structure inline and populating it using the VALUE operator
    DATA(struc_inl2) = VALUE lty_struc( num1 = 1 num2 = 2 ).

    out->write( zcl_demo_abap_aux=>no_output ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Variants of structures` ) ).
    out->write( |3) Flat structure with default values\n\n| ).

    "Flat structures only contain elementary data types

    "Flat structure with default values
    DATA: BEGIN OF ls_flat,
            num1  TYPE i VALUE 1,
            num2  TYPE i VALUE 2,
            char1 TYPE c LENGTH 10 VALUE 'abcdefghij',
            char2 TYPE c LENGTH 5 VALUE 'klmno',
            pnum  TYPE p LENGTH 8 DECIMALS 2 VALUE '123.45',
          END OF ls_flat.

    out->write( data = ls_flat name = `ls_flat` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Nested structure` ) ).

    "Nested structures contain at least one structure as component

    "Nested structure with default values
    DATA: BEGIN OF ls_nested_address,
            BEGIN OF name,
              title      TYPE string VALUE `Mr.`,
              first_name TYPE string VALUE `Duncan`,
              surname    TYPE string VALUE `Pea`,
            END OF name,
            BEGIN OF street,
              name   TYPE string VALUE `Vegetable Lane`,
              number TYPE string VALUE `11`,
            END OF street,
            BEGIN OF city,
              zipcode TYPE string VALUE `349875`,
              name    TYPE string VALUE `Botanica`,
            END OF city,
          END OF ls_nested_address.

    out->write( data = ls_nested_address name = `ls_nested_address` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Deep structure with strings` ) ).

    "Deep structures contain at least one deep component, for
    "example, internal tables, strings.

    "Deep structure with strings and with default values.
    DATA: BEGIN OF ls_flat_address,
            name   TYPE string VALUE `Mr. Duncan Pea`,
            street TYPE string VALUE `Vegetable Lane 11`,
            city   TYPE string VALUE `349875 Botanica`,
          END OF ls_flat_address.

    out->write( data = ls_flat_address name = `ls_flat_address` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Deep structure with internal table as component` ) ).

    "Structured type for nested internal table
    TYPES: BEGIN OF lty_flights,
             connid    TYPE zdemo_abap_flsch-connid,
             countryfr TYPE zdemo_abap_flsch-countryfr,
             cityfrom  TYPE zdemo_abap_flsch-cityfrom,
             airpfrom  TYPE zdemo_abap_flsch-airpfrom,
             countryto TYPE zdemo_abap_flsch-countryto,
             cityto    TYPE zdemo_abap_flsch-cityto,
             airpto    TYPE zdemo_abap_flsch-airpto,
           END OF lty_flights.

    "Creating deep structure
    DATA: BEGIN OF ls_flights,
            carrier      TYPE zdemo_abap_flsch-carrid VALUE 'LH',
            carrier_name TYPE zdemo_abap_carr-carrname VALUE 'Lufthansa',
            lt_flights   TYPE TABLE OF lty_flights WITH EMPTY KEY,
          END OF ls_flights.

    "Filling nested internal table for the output
    SELECT *
      FROM zdemo_abap_flsch
      WHERE carrid = 'LH'
      INTO CORRESPONDING FIELDS OF TABLE @ls_flights-lt_flights
      UP TO 4 ROWS.

    out->write( data = ls_flights name = `ls_flights` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Accessing and populating structures` ) ).
    out->write( |7) Populating structure components using the component selector\n\n| ).

    gs_struc-num1  = 1.
    gs_struc-num2  = 2.
    gs_struc-char1 = 'aaa'.
    gs_struc-char2 = 'bbb'.
    gs_struc-pnum  = '333.33'.

    out->write( data = gs_struc name = `gs_struc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Populating structure components ` &&
    `using the VALUE operator` ) ).

    "Value assignments by addressing the structure components individually
    "can be very bulky. Hence, the use of the VALUE operator is
    "very handy for the value assignment, especially for filling structure
    "components at operand position. In below examples the # sign is used
    "before the parentheses which means that the type of the operand can be
    "implicitly derived.

    "Flat structure
    gs_struc = VALUE #( num1  = 3
                        num2  = 4
                        char1 = 'ccc'
                        char2 = 'ddd'
                        pnum  = '555.55' ).

    "Nested structure
    ls_nested_address = VALUE #(
      name   = VALUE #( title = `Mrs.`
                        first_name = `Jane`
                        surname = `Doe` )
      street = VALUE #( name  = `Main Street`
                        number = 1 )
      city   = VALUE #( zipcode = 12345
                        name = `London` ) ).

    "Deep structure
    ls_flights = VALUE #(
        carrier      = 'AA'
        carrier_name = 'American Airlines'
        lt_flights   = VALUE #( ( connid    = 17 countryfr = 'US'
                                  cityfrom  = 'New York'
                                  airpfrom  = 'JFK'
                                  countryto = 'US'
                                  cityto    = 'San Francisco'
                                  airpto    = 'SFO' )
                                ( connid    = 64
                                  countryfr = 'US'
                                  cityfrom  = 'San Francisco'
                                  airpfrom  = 'SFO'
                                  countryto = 'US'
                                  cityto    = 'New York'
                                  airpto    = 'JFK' ) ) ).

    out->write( data = gs_struc name = `gs_struc` ).
    out->write( |\n| ).
    out->write( data = ls_nested_address name = `ls_nested_address` ).
    out->write( |\n| ).
    out->write( data = ls_flights name = `ls_flights` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) Creating and populating a new structure ` &&
    `using the VALUE operator` ) ).

    "In the example below in which a new structure is created by declaring
    "a variable inline the '#' sign cannot be used before the parentheses
    "because a type cannot be derived. Instead, the type must be
    "specified before the parentheses explicitly.

    DATA(ls_copy) = VALUE gty_struc( num1  = 5
                                     num2  = 6
                                     char1 = 'ggg'
                                     char2 = 'hhh'
                                     pnum  = '555.55' ).

    out->write( data = ls_copy name = `ls_copy` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Accessing individual components using the ` &&
    `component selector` ) ).

    "Assigning value of individual component to a variable
    DATA(lv_copy) = gs_struc-num1.

    "Assigning a value to a component in a nested structure.
    ls_nested_address-name-first_name = 'Emma'.

    "Assigning a value to a component in a deep structure.
    "The table line is determined using a table expression.
    ls_flights-lt_flights[ 1 ]-cityto = 'San Fran'.

    out->write( data = lv_copy name = `lv_copy` ).
    out->write( |\n| ).
    out->write( data = ls_nested_address-name-first_name name = `ls_nested_address-name-first_name` ).
    out->write( |\n| ).
    out->write( data = ls_flights-lt_flights[ 1 ]-cityto name = `ls_flights-lt_flights[ 1 ]-cityto` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Excursion: Addressing components of a variable` &&
    ` referring to a structure ` ) ).

    "Creating a data reference variable.
    DATA(ref) = NEW gty_struc( ).

    "Assigning a structure to the data reference
    ref->* = gs_struc.

    "Accessing a component using the object component selector
    DATA(ref_comp1) = ref->char1.

    "The following syntax is also possible but less comfortable.
    DATA(ref_comp2) = ref->*-char2.

    out->write( data = ref_comp1 name = `ref_comp1` ).
    out->write( |\n| ).
    out->write( data = ref_comp2 name = `ref_comp2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) Using structure components for ` &&
    `data type and data object declarations` ) ).

    TYPES: lty_1 TYPE gty_struc-num1,
           lty_2 LIKE gs_struc-num2.

    DATA: lv_num1 TYPE gty_struc-num1 VALUE 123,
          lv_num2 LIKE gs_struc-num2 VALUE 456.

    out->write( data = lv_num1 name = `lv_num1` ).
    out->write( |\n| ).
    out->write( data = lv_num2 name = `lv_num2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) Creating and populating an anonymous structure ` &&
    `using the NEW operator` ) ).

    "In the example below in which a new structure is created by declaring
    "a variable inline the '#' sign cannot be used before the parentheses
    "because a type cannot be derived. Instead, the type must be
    "specified before the parentheses explicitly.

    "Creating a data reference variable
    TYPES struc_type LIKE ls_flat_address.
    DATA addr_ref1 TYPE REF TO struc_type.

    "Populating the anonymous structure
    addr_ref1 = NEW #( name   = `Mr. Duncan Pea`
                       street = `Vegetable Lane 11`
                       city   = `349875 Botanica` ).

    addr_ref1->name = `Mrs. Jane Doe`.

    "Declaring an anonymous structure/a data reference variable inline
    DATA(addr_ref2) = NEW struc_type( name   = `Mr. Duncan Pea`
                                      street = `Vegetable Lane 11`
                                      city   = `349875 Botanica` ).

    out->write( data = addr_ref2->* name = `addr_ref2->*` ).

    addr_ref2->* = VALUE #( BASE addr_ref2->* name = `Mr. John Doe` ).

    out->write( data = addr_ref2->* name = `addr_ref2->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `14) Copying content of a structure to another ` &&
    ` that has the same type using the assignment operator` ) ).

    "Note: In the case below, a MOVE-CORRESPONDING statement as shown
    "further down would have the same effect:
    "MOVE-CORRESPONDING gs_struc TO gs_struc_2.

    DATA gs_struc_2 TYPE gty_struc.

    gs_struc_2 = gs_struc.

    out->write( data = gs_struc_2 name = `gs_struc_2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Copying content of a structure to another` &&
    ` that has an incompatible type using` &&
    ` MOVE-CORRESPONDING statemtns and the CORRESPONDING operator` ) ).

    "Both statements with MOVE-CORRESPONDING and the CORRESPONDING
    "operator are used to assign identically named components of
    "structures to each other.
    "Note: For value assignments, generally bear in mind that there are
    "special conversion and comparison rules that apply to assignments.
    "The following examples focus on flat structures.

    "Creating flat structure with different type and assigning
    "default values.
    DATA: BEGIN OF gs_struc_diff,
            num1  TYPE i VALUE 111,
            num2  TYPE i VALUE 222,
            char1 TYPE c LENGTH 10 VALUE 'AAA',
            c1    TYPE c LENGTH 1 VALUE 'B',
          END OF gs_struc_diff.

    "Copying structure to have the same values for another syntax variant.
    DATA(gs_struc_diff2) = gs_struc_diff.
    DATA(gs_struc_diff3) = gs_struc_diff.
    DATA(gs_struc_diff4) = gs_struc_diff.
    DATA(gs_struc_diff5) = gs_struc_diff.

    out->write( |Original content of structures:\n\n| ).
    out->write( data = gs_struc name = `gs_struc` ).
    out->write( |\n| ).
    out->write( data = gs_struc_diff name = `gs_struc_diff` ).
    out->write( |\n| ).

    "Identically named components are moved...
    "... and the content in nonidentical components of the target
    "structure are kept.
    MOVE-CORRESPONDING gs_struc TO gs_struc_diff.

    "... and the content in nonidentical components in the target
    "structure are initialized.
    gs_struc_diff2   = CORRESPONDING #( gs_struc ).

    "... and the content in nonidentical components of the target
    "structure are kept. Same as MOVE-CORRESPONDING without additions.
    gs_struc_diff3 = CORRESPONDING #( BASE ( gs_struc_diff3 )
                                      gs_struc ).

    "MAPPING addition: Specifying components of a source structure that
    "are assigned to the components of a target structure in mapping
    "relationships. Note the conversion and assignement rules.
    gs_struc_diff4 = CORRESPONDING #( BASE ( gs_struc_diff4 )
                                      gs_struc MAPPING c1 = char2 ).

    "EXCEPT addition: Excluding components from the assignment.
    gs_struc_diff5 = CORRESPONDING #( BASE ( gs_struc_diff5 )
                                      gs_struc EXCEPT num2 ).

    out->write( |Results of statements:\n\n| ).
    out->write( data = gs_struc_diff name = `gs_struc_diff` ).
    out->write( |\n| ).
    out->write( data = gs_struc_diff2 name = `gs_struc_diff2` ).
    out->write( |\n| ).
    out->write( data = gs_struc_diff3 name = `gs_struc_diff3` ).
    out->write( |\n| ).
    out->write( data = gs_struc_diff4 name = `gs_struc_diff4` ).
    out->write( |\n| ).
    out->write( data = gs_struc_diff5 name = `gs_struc_diff5` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Copying content of a deep ` &&
    `structure to another` ) ).
    out->write( |Original content of deep structures:\n\n| ).

    "Note: The example purposely uses non-fitting components
    "to emphasize conversion and assignment rules.

    out->write( data = gs_deep1 name = `gs_deep1` ).
    out->write( |\n| ).
    out->write( data = gs_deep2 name = `gs_deep2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) MOVE-CORRESPONDING without additions` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc is converted to string. Note that the two
    "  components in component substruc-comp2 of gs_deep1 are drawn
    "  together when being converted to string.
    "- Content of gs_deep2-itab is replaced by table content of
    "  gs_deep1-itab. Value assignment, for example,
    "  for col2 in gs_deep2-itab: Despite the fact that there is no
    "  identically named component col1  in the target structure,
    "  values are assigned starting with the first column of the source
    "  structure.

    MOVE-CORRESPONDING gs_deep1 TO gs_deep2.

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) MOVE-CORRESPONDING with the ` &&
    `EXPANDING NESTED TABLES addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is replaced by table content of
    "  gs_deep1-itab. Due to the addition EXPANDING NESTED TABLES, the
    "  value assignment happens for identically named components. Hence,
    "  only col2 as the only shared and identically named component is
    "  filled.

    MOVE-CORRESPONDING gs_deep1 TO gs_deep2 EXPANDING NESTED TABLES.

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) MOVE-CORRESPONDING with the` &&
    ` KEEPING TARGET LINES addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is kept due to the addition KEEPING
    "  TARGET LINES and content of gs_deep1-itab is added. The value
    "  assignment concerning the added lines happens like the
    "  MOVE-CORRESPONDING statement without addition. That is, despite
    "  the fact that there is no identically named component col1 in
    "  the target structure, values are assigned starting with the
    "  first column of the source structure.

    MOVE-CORRESPONDING gs_deep1 TO gs_deep2 KEEPING TARGET LINES.

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) MOVE-CORRESPONDING with the ` &&
    `EXPANDING NESTED TABLES KEEPING TARGET LINES addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is kept due to the addition KEEPING
    "  TARGET LINES. Content of gs_deep1-itab is added. The value
    "  assignment concerning the added lines happens like the
    "  MOVE-CORRESPONDING statement with the addition EXPANDING NESTED
    "  TABLES. That is, the value assignment happens for identically
    "  named components. Hence, only col2 as the only shared and
    "  identically named component is filled.

    MOVE-CORRESPONDING gs_deep1 TO gs_deep2
      EXPANDING NESTED TABLES KEEPING TARGET LINES.

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) CORRESPONDING operator without additions` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  initialized.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is replaced by table content of
    "  gs_deep1-itab. Note the value assignment, for example, for col2
    "  in gs_deep2-itab. Despite the fact that there is no identically
    "  named component comp1 in the target structure, values are
    "  assigned starting with the first column of the source structure.

    gs_deep2 = CORRESPONDING #( gs_deep1 ).

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) CORRESPONDING operator with the` &&
    ` DEEP addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  initialized.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is replaced by table content of
    "  gs_deep1-itab. Due to the addition DEEP, the value assignment
    "  happens for identically named components in the nested table.
    "  Hence, only col2 as the only shared and identically named
    "  component is filled.

    gs_deep2 = CORRESPONDING #( DEEP gs_deep1 ).

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) CORRESPONDING operator with the` &&
    ` BASE addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is replaced by table content of
    "  gs_deep1-itab. The value assignment in the nested table happens
    "  like using the CORRESPONDING operator without addition. Note the
    "  value assignment, for example, for col2 in gs_deep2-itab.
    "  Despite the fact that there is no identically named component
    "  col1 in the target structure, values are assigned starting with
    "  the first column of the source structure.

    gs_deep2 = CORRESPONDING #( BASE ( gs_deep2 ) gs_deep1 ).

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) CORRESPONDING operator with the ` &&
    `DEEP BASE addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is replaced by table content of
    "  gs_deep1-itab. The value assignment in the nested table happens
    "  like using the CORRESPONDING operator with the addition DEEP.
    "  That is,  the value assignment happens for identically named
    "  components in the nested table. Hence, only col2 as the only
    "  shared and identically named component is filled.

    gs_deep2 = CORRESPONDING #( DEEP BASE ( gs_deep2 ) gs_deep1 ).

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) CORRESPONDING operator with the ` &&
    `APPENDING addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is kept and content of gs_deep1-itab is
    "  added. The value assignment concerning the added lines happens
    "  like using the CORRESPONDING operator without addition. Note the
    "  value assignment, for example, for col2 in gs_deep2- itab.
    "  Despite the fact that there is no identically named component
    "  col1 in the target structure, values are assigned starting with
    "  the first column of the source structure.

    gs_deep2 = CORRESPONDING #( APPENDING ( gs_deep2 ) gs_deep1 ).

    out->write( data = gs_deep2 name = `gs_deep2` ).

    fill_deep_structures( ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `26) CORRESPONDING operator with the ` &&
    `DEEP APPENDING addition` ) ).

    "Notes on the result:
    "- Existing content of identically named components is replaced.
    "- Content in nonidentical components of the target structure is
    "  kept.
    "- Substructure substruc: Same as above
    "- Content of gs_deep2-itab is kept and content of gs_deep1-itab is
    "  added. The value assignment concerning the added lines happens
    "  like using the CORRESPONDING operator with the addition DEEP.
    "  That is, the value assignment happens for identically named
    "  components in the nested table. Hence, only col2 as the only
    "  shared and identically named component is filled.
    "- It has the same effect as using DEEP APPENDING BASE.

    gs_deep2 = CORRESPONDING #( DEEP APPENDING ( gs_deep2 )
                                gs_deep1 ).

    out->write( data = gs_deep2 name = `gs_deep2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `27) Clearing individual components of a ` &&
    `structure and the complete structure` ) ).

    "Clearing individual component
    CLEAR gs_struc-char1.

    out->write( data = gs_struc name = `gs_struc` ).
    out->write( |\n| ).

    "Clearing the whole structure
    CLEAR gs_struc.

    out->write( data = gs_struc name = `gs_struc` ).

    "Note: An assignment using the VALUE operator without entries in the parentheses clears the structure.
    ls_flat_address = VALUE #( name = `Mr. Duncan Pea` ).
    ls_flat_address = VALUE #( ).

    ASSERT ls_flat_address IS INITIAL.

    "The same applies to data reference variables pointing to structures.
    addr_ref2 = NEW struc_type( name = `Mr. Duncan Pea` ).
    addr_ref2 = NEW #( ).

    ASSERT addr_ref2->* IS INITIAL.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Processing structures` ) ).
    out->write( |Reading a row from a database table into a structure ...\n\n| ).
    out->write( |28) ... that has a compatible type\n\n| ).

    "The first entry that is found according to the WHERE condition is
    "returned. Instead of creating a structure having a compatible type,
    "the structure can be declared inline.

    DATA ls_flsch1 TYPE zdemo_abap_flsch.

    SELECT SINGLE FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'LH' AND connid = '0400'
      INTO @ls_flsch1.

    SELECT SINGLE FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'LH' AND connid = '0400'
      INTO @DATA(ls_flsch2).

    out->write( data = ls_flsch1 name = `ls_flsch1` ).
    out->write( |\n| ).
    out->write( data = ls_flsch2 name = `ls_flsch2` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `29) ... that has a different type` ) ).

    "Creating structure having a different type.
    DATA: BEGIN OF ls_fli_diff,
            carrid    TYPE  zdemo_abap_flsch-carrid,
            connid    TYPE zdemo_abap_flsch-connid,
            countryfr TYPE zdemo_abap_flsch-countryfr,
            cityfrom  TYPE zdemo_abap_flsch-cityfrom,
            countryto TYPE zdemo_abap_flsch-countryto,
            cityto    TYPE zdemo_abap_flsch-cityto,
            fldate    TYPE zdemo_abap_fli-fldate,
          END OF ls_fli_diff.

    SELECT SINGLE FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'JL' AND connid = '0408'
      INTO CORRESPONDING FIELDS OF @ls_fli_diff.

    out->write( data = ls_fli_diff name = `ls_fli_diff` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Reading a line from an internal table into a structure ...` ) ).
    out->write( |30) ... using a SELECT statement\n\n| ).

    "Creating and filling an internal table to be read from
    DATA itab TYPE TABLE OF zdemo_abap_flsch WITH EMPTY KEY.
    SELECT FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'LH' ORDER BY PRIMARY KEY
      INTO TABLE @itab
      UP TO 4 ROWS.

    "Reading from an internal table
    SELECT SINGLE FROM @itab AS itab
      FIELDS *
      WHERE carrid = 'LH'
      INTO @DATA(ls_select_itab).

    out->write( data = ls_select_itab name = `ls_select_itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `31) ... using a READ TABLE statement` ) ).

    "The example shows the reading of one line into a work area, field
    "symbol and a data reference variable, all representing structured
    "data objects and declared inline below. Here, the reading of a
    "line is based on the line number by specifying INDEX.

    "Copying line into a work area
    READ TABLE itab INTO DATA(ls_read_table) INDEX 1.

    "Assignment to a field symbol
    READ TABLE itab ASSIGNING FIELD-SYMBOL(<fs1>) INDEX 2.

    "Reading into a data reference variable
    READ TABLE itab REFERENCE INTO DATA(dref) INDEX 3.

    out->write( data = ls_read_table name = `ls_read_table` ).
    out->write( |\n| ).
    out->write( data = <fs1> name = `<fs1>` ).
    out->write( |\n| ).
    out->write( data = dref->* name = `dref->*` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `32) ... using a table expression` ) ).
    "The line number, that is, the index, is specified in square
    "brackets.

    DATA(ls_table_exp) = itab[ 3 ].

    out->write( data = ls_table_exp name = `ls_table_exp` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `Sequentially reading ...` ) ).
    out->write( |33) ... a row from a database table into a structure\n\n| ).

    "In the given simple example, the line that is found and returned
    "in a structure, that is declared inline, is simply added to an
    "internal table.

    SELECT FROM zdemo_abap_flsch
      FIELDS *
      WHERE carrid = 'AZ'
      INTO @DATA(ls_sel_loop).
      IF sy-subrc = 0.
        APPEND  ls_sel_loop TO itab.
      ENDIF.
    ENDSELECT.

    out->write( data = itab name = `itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `34) ... a line from an internal table into a structure` ) ).

    "The given example covers the reading of a line into a field symbol.
    "Within the loop, a modification is carried out on a component
    "of the structures.

    LOOP AT itab ASSIGNING FIELD-SYMBOL(<fs_loop>) WHERE carrid <> 'LH'.
      <fs_loop>-carrid = 'XY'.
    ENDLOOP.

    out->write( data = itab name = `itab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `35) Inserting a single row ` &&
    `into a database table from a structure` ) ).

    "The statements in the given example can be considered as
    "alternatives. The third statement demonstrates that the structure
    "might also be created and filled in place instead of inserting a
    "line from an existing structure.

    DATA ls_struc_db TYPE zdemo_abap_tab1.

    ls_struc_db = VALUE #( key_field = 1
                           char1     = 'aaa'
                           char2     = 'bbb'
                           num1      = 2
                           num2      = 3 ).

    INSERT INTO zdemo_abap_tab1 VALUES @ls_struc_db.

    "Structure filled anew with new primary key to
    "avoid duplicate key error.
    ls_struc_db = VALUE #( key_field = 2
                           char1     = 'ccc'
                           char2     = 'ddd'
                           num1      = 4
                           num2      = 5 ).

    INSERT zdemo_abap_tab1 FROM @ls_struc_db.

    INSERT zdemo_abap_tab1 FROM @( VALUE #( key_field = 3
                                            char1     = 'eee'
                                            char2     = 'fff'
                                            num1      = 6
                                            num2      = 7 ) ).

    select_from_dbtab( ).
    out->write( data = gt_tab name = `gt_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `36) Updating a single row ` &&
    `in a database table from a structure` ) ).

    ls_struc_db = VALUE #( key_field = 2
                           char1     = 'GGG'
                           char2     = 'HHH'
                           num1      = 8
                           num2      = 9 ).

    UPDATE zdemo_abap_tab1 FROM @ls_struc_db.

    UPDATE zdemo_abap_tab1 FROM @( VALUE #( key_field = 3
                                            char1     = 'III'
                                            char2     = 'JJJ'
                                            num1      = 10
                                            num2      = 11 ) ).

    select_from_dbtab( ).
    out->write( data = gt_tab name = `gt_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `37) Updating a single row ` &&
    `in a database table from a structure without overwriting specific ` &&
    `components` ) ).

    "If you want to update a database table row from a structure by
    "specifying components to be changed without overwriting other
    "components, you might choose the following way. First, read the
    "intended line from the database table into a structure.
    "Then, use the VALUE operator with the addition BASE and specify
    "the components to be changed.

    SELECT SINGLE *
      FROM zdemo_abap_tab1
      WHERE key_field = 2
      INTO @DATA(wa).

    UPDATE zdemo_abap_tab1 FROM @( VALUE #( BASE wa char2 = '###' ) ).

    select_from_dbtab( ).
    out->write( data = gt_tab name = `gt_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `38) Updating or creating a single` &&
    ` row in a database table from a structure using MODIFY` ) ).

    "You can update or create an individual row in a database table
    "from a structure using ABAP SQL statements with MODIFY. If a
    "line in the database table already exists having the same keys as
    "specified in the structure, the line gets updated. If a line does
    "not exist with the keys specified in the structure, a new line is
    "created in the database table. In the given example, the first
    "statement demonstrates a modification of an existing line in the
    "database table.The second and third statements create a new line
    "in the database table. The third statement demonstrates that the
    "structure might also be created and filled in place instead of
    "inserting a line based on an existing structure.

    ls_struc_db = VALUE #( key_field = 1
                           char1     = 'kkk'
                           char2     = 'lll'
                           num1      = 12
                           num2      = 13 ).

    MODIFY zdemo_abap_tab1 FROM @ls_struc_db.

    ls_struc_db = VALUE #( key_field = 4
                           char1     = 'mmm'
                           char2     = 'nnn'
                           num1      = 14
                           num2      = 15 ).

    MODIFY zdemo_abap_tab1 FROM @ls_struc_db.

    MODIFY zdemo_abap_tab1 FROM @( VALUE #( key_field = 5
                                            char1     = 'ooo'
                                            char2     = 'ppp'
                                            num1      = 16
                                            num2      = 17 ) ).

    select_from_dbtab( ).
    out->write( data = gt_tab name = `gt_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `39) Adding rows to and updating single rows` &&
    ` in an internal table from a structure` ) ).

    "INSERT and MODIFY are ABAP statements in this context, not ABAP SQL
    "statements. Both INSERT and APPEND add one line (or more) to an
    "internal table. While APPEND adds at the bottom of the internal
    "table, INSERT can be used to add lines at a specific position in
    "tables. MODIFY changes the content of an internal table entry.

    ls_struc_db = VALUE #( key_field = 6
                           char1     = 'ZZZ'
                           char2     = 'YYY'
                           num1      = 18
                           num2      = 19 ).

    INSERT ls_struc_db INTO TABLE gt_tab.

    INSERT VALUE #( key_field = 7
                    char1     = 'XXX'
                    char2     = 'WWW'
                    num1      = 20
                    num2      = 21 ) INTO TABLE gt_tab.

    ls_struc_db = VALUE #( key_field = 8
                           char1     = 'VVV'
                           char2     = 'UUU'
                           num1      = 22
                           num2      = 23 ).

    APPEND ls_struc_db TO gt_tab.

    APPEND VALUE #( key_field = 9
                    char1     = 'TTT'
                    char2     = 'SSS'
                    num1      = 24
                    num2      = 25 ) TO gt_tab.

    ls_struc_db = VALUE #( key_field = 1
                           char1     = 'RRR'
                           char2     = 'QQQ'
                           num1      = 26
                           num2      = 27 ).

    MODIFY TABLE gt_tab FROM ls_struc_db.

    MODIFY TABLE gt_tab FROM VALUE #( key_field = 2
                                      char1     = 'PPP'
                                      char2     = 'OOO'
                                      num1      = 28
                                      num2      = 29 ).

    out->write( data = gt_tab name = `gt_tab` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `40) Including structures` ) ).

    "The example shows the inclusion of structured types and data
    "objects in another structure. First, three structured types as
    "well as a structured data object based on one of those types are
    "created. Then, the types and the structure are included in the
    "structured type address_type. With the optional addition AS and
    "the specification of a name, the included components can be
    "addressed by this common name as if the components are actually
    "components of a substructure. With the optional addition
    "RENAMING WITH SUFFIX and the specification of a name, the included
    "components get a suffix name to avoid naming conflicts with other
    "components.

    TYPES: BEGIN OF name_type,
             title   TYPE string,
             prename TYPE string,
             surname TYPE string,
           END OF name_type,
           BEGIN OF street_type,
             name   TYPE string,
             number TYPE string,
           END OF street_type,
           BEGIN OF city_type,
             zipcode TYPE string,
             name    TYPE string,
           END OF city_type.

    DATA: city_struc TYPE city_type.

    TYPES BEGIN OF address_type.
    INCLUDE TYPE name_type AS name.
    INCLUDE TYPE street_type AS street RENAMING WITH SUFFIX _street.
    INCLUDE STRUCTURE city_struc AS city RENAMING WITH SUFFIX _city.
    TYPES END OF address_type.

    DATA: name    TYPE name_type,
          address TYPE address_type.

    name-title = `Mr.`.
    name-prename = `Duncan`.
    name-surname = `Pea`.
    address-name = name.
    address-street-name = `Vegetable Lane`.
    address-street-number = `11`.
    address-zipcode_city = `349875`.
    address-name_city = `Botanica`.

    out->write( data = address name = `address` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `41) Getting Structured Type Information and Creating Structures at Runtime` ) ).

    TYPES: BEGIN OF demo_struc_type,
             comp1 TYPE c LENGTH 3,
             comp2 TYPE i,
             comp3 TYPE string,
           END OF demo_struc_type.
    DATA demo_struc TYPE demo_struc_type.

    DATA(tdo_c) = cl_abap_typedescr=>describe_by_data( demo_struc ).
    "DATA(tdo_c) = cl_abap_typedescr=>describe_by_name( 'DEMO_STRUC_TYPE' ).

    "Cast to get more specific information
    DATA(tdo_struc) = CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( demo_struc ) ).
    "DATA(tdo_struc) = CAST cl_abap_structdescr( tdo_c ).

    DATA(type_category_struc) = tdo_struc->kind.
    DATA(relative_name_struc) = tdo_struc->get_relative_name( ).
    ... "Explore more options by positioning the cursor behind -> and choosing CTRL + Space
    DATA(type_of_struc) = tdo_struc->struct_kind.
    DATA(struc_comps) = tdo_struc->components.
    DATA(struc_comps_more_details) = tdo_struc->get_components( ).
    DATA(struc_has_include) = tdo_struc->has_include.
    DATA(struc_incl_view) = tdo_struc->get_included_view( ).
    DATA(applies_to_data_struc) = tdo_struc->applies_to_data( `some string` ).

    "Example: "Looping" across a structure
    "For example, this may also be done using a DO loop and dynamic assignments.
    "Demo structure, all components are convertible to type string
    TYPES: BEGIN OF ty_struc,
             comp1 TYPE c LENGTH 3,
             comp2 TYPE string,
             comp3 TYPE i,
             comp4 TYPE n LENGTH 4,
           END OF ty_struc.
    DATA(struct) = VALUE ty_struc( comp1 = 'abc' comp2 = `ABAP` comp3 = 123 comp4 = '9876' ).
    DATA looped_struc TYPE string.

    "In the loop, a string is populated, component by component.
    LOOP AT CAST cl_abap_structdescr( cl_abap_typedescr=>describe_by_data( struct ) )->components INTO DATA(comp).
      looped_struc = |{ looped_struc }{ COND #( WHEN sy-tabix <> 1 THEN ` / ` ) }Name: "{ CONV string( comp-name ) }", Value: "{ struct-(comp-name) }"|.
    ENDLOOP.

    out->write( data = looped_struc name = `looped_struc` ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `42) sy Structure` ) ).

    "Demonstrating prominent sy components that can be used in ABAP for Cloud Development

    "------------------------------------------------------------------------------
    "------------------ sy-subrc: Return code of ABAP statements ------------------
    "------------------------------------------------------------------------------

    "Many ABAP statements set a sy-subrc value. Check the ABAP Keyword Documentation
    "for individual statements. Usually, the value 0 indicates a successful execution.

    DATA(some_string) = `ABAP`.

    "FIND statements
    "Found
    FIND `P` IN some_string.
    ASSERT sy-subrc = 0.

    "Not found
    FIND `p` IN some_string RESPECTING CASE.
    ASSERT sy-subrc = 4.

    DATA(some_itab) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ).

    "READ TABLE statements
    "Entry available
    READ TABLE some_itab INTO DATA(wa1) INDEX 3.
    ASSERT sy-subrc = 0.

    "Entry not available
    READ TABLE some_itab INTO DATA(wa2) INDEX 7.
    ASSERT sy-subrc = 4.

    "ABAP SQL statements
    DELETE FROM zdemo_abap_tab1.
    IF sy-subrc = 0.
      out->write( `DELETE: All rows were deleted.` ).
    ELSE.
      out->write( `DELETE: No row was deleted because it was already empty.` ).
    ENDIF.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 ) ( key_field = 2 ) ) ).
    IF sy-subrc = 0.
      out->write( `INSERT: All rows of the internal table were inserted.` ).
    ENDIF.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 3 ) ( key_field = 3 ) ) ) ACCEPTING DUPLICATE KEYS.
    IF sy-subrc = 4.
      out->write( `INSERT ... ACCEPTING DUPLICATE KEYS: sy-subrc has the value 4 in this case. Not all rows of the ` &&
                  `internal table were inserted because a row with the key already exists.` ).
    ENDIF.

    DELETE FROM zdemo_abap_tab1 WHERE key_field = 3.
    IF sy-subrc = 0.
      out->write( `DELETE: The row matching the WHERE condition was deleted.` ).
    ELSE.
      out->write( `DELETE: No match according to the WHERE condition.` ).
    ENDIF.

    DELETE FROM zdemo_abap_tab1 WHERE key_field = 3.
    IF sy-subrc = 0.
      out->write( `DELETE: The row matching the WHERE condition was deleted.` ).
    ELSE.
      out->write( `DELETE: No match according to the WHERE condition.` ).
    ENDIF.

    "------------------------------------------------------------------------------
    "--------------------------- sy-index: Loop indexes ---------------------------
    "------------------------------------------------------------------------------

    CLEAR some_string.

    "DO loops
    DO 5 TIMES.
      some_string = some_string && sy-index.
    ENDDO.

    ASSERT some_string = `12345`.

    CLEAR some_string.

    DO 10 TIMES.
      some_string = some_string && sy-index.
      IF sy-index = 7.
        EXIT.
      ENDIF.
    ENDDO.

    ASSERT some_string = `1234567`.

    CLEAR some_string.

    DATA number TYPE i.

    "WHILE loop
    WHILE number < 9.
      number = sy-index.
      some_string = some_string && number.
    ENDWHILE.

    ASSERT some_string = `123456789`.

    "------------------------------------------------------------------------------
    "------------------- sy-tabix: Row index of internal tables -------------------
    "------------------------------------------------------------------------------

    "Demo standard internal table with 5 entries
    DATA(std_itab) = VALUE string_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ( `e` ) ).

    "READ TABLE statement using a free key
    READ TABLE std_itab INTO DATA(wa3) WITH KEY table_line = `b`.
    ASSERT sy-tabix = 2.

    "Demo hashed internal table with 5 entries
    DATA(hashed_itab) = VALUE string_hashed_table( ( `a` ) ( `b` ) ( `c` ) ( `d` ) ( `e` ) ).

    "READ TABLE statement using a free key
    READ TABLE hashed_itab INTO DATA(wa4) WITH KEY table_line = `b`.
    "Hashed tables do not have a primary table index.
    ASSERT sy-tabix = 0.

    CLEAR some_string.

    "LOOP statements
    LOOP AT std_itab INTO DATA(wa5).
      some_string = some_string && sy-tabix.
    ENDLOOP.
    ASSERT some_string = `12345`.

    CLEAR some_string.
    "Step addition
    "In the example, the table is looped across backwards
    "indicated by the negative value. The step size 1 indicates
    "that each line is respected.
    LOOP AT std_itab INTO DATA(wa6) STEP -1.
      some_string = some_string && sy-tabix.
    ENDLOOP.
    ASSERT some_string = `54321`.

    CLEAR some_string.
    "Forward loop, step size = 2
    LOOP AT std_itab INTO DATA(wa7) STEP 2.
      some_string = some_string && sy-tabix.
    ENDLOOP.
    ASSERT some_string = `135`.

    CLEAR some_string.
    "FROM/TO additions
    LOOP AT std_itab INTO DATA(wa8) FROM 2 TO 4.
      some_string = some_string && sy-tabix.
    ENDLOOP.
    ASSERT some_string = `234`.

    CLEAR some_string.
    "STEP/FROM additions
    LOOP AT std_itab INTO DATA(wa9) STEP 2 FROM 2.
      some_string = some_string && sy-tabix.
    ENDLOOP.
    ASSERT some_string = `24`.

    CLEAR some_string.
    "Hashed table
    LOOP AT hashed_itab INTO DATA(wa10).
      some_string = some_string && sy-tabix.
    ENDLOOP.
    ASSERT some_string = `00000`.

    "------------------------------------------------------------------------------
    "------------------------ sy-dbcnt: Edited table rows -------------------------
    "------------------------------------------------------------------------------

    DELETE FROM zdemo_abap_tab1.
    DATA(dbcnt) = sy-dbcnt.

    out->write( |Dbtab rows deleted: { dbcnt }| ).

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 1 ) ( key_field = 2 ) ) ).
    ASSERT sy-dbcnt = 2.

    INSERT zdemo_abap_tab1 FROM TABLE @( VALUE #( ( key_field = 3 ) ( key_field = 3 ) ) ) ACCEPTING DUPLICATE KEYS.
    ASSERT sy-dbcnt = 1.

    MODIFY zdemo_abap_tab1 FROM @( VALUE #( key_field = 1 char1 = 'aaa' ) ).
    ASSERT sy-dbcnt = 1.

    UPDATE zdemo_abap_tab1 SET char2 = 'bbb'.
    ASSERT sy-dbcnt = 3.

    DELETE FROM zdemo_abap_tab1 WHERE num1 IS INITIAL.
    ASSERT sy-dbcnt = 3.

    "------------------------------------------------------------------------------
    "------------- sy-fdpos: Occurrence in byte or character strings --------------
    "------------------------------------------------------------------------------
    "For example, relevant in comparison expressions such as CS (constains string).
    "If the comparison is true, sy-fdpos contains the offset of the found value. If it
    "is false, sy-fdpos contains the length of the searched string.

    some_string = `###abap###`.

    IF some_string CS `p`.
      out->write( |The substring is found. Offset of first finding: { sy-fdpos }| ).
    ELSE.
      out->write( |The substring is not found. Length of searched string: { sy-fdpos }| ).
      ASSERT sy-fdpos = strlen( some_string ).
    ENDIF.

    IF some_string CS `#`.
      out->write( |The substring is found. Offset of first finding: { sy-fdpos }| ).
    ELSE.
      out->write( |The substring is not found. Length of searched string: { sy-fdpos }| ).
      ASSERT sy-fdpos = strlen( some_string ).
    ENDIF.

    IF some_string CS `Y`.
      out->write( |The substring is found. Offset of first finding: { sy-fdpos }| ).
    ELSE.
      out->write( |The substring is not found. Length of searched string: { sy-fdpos }| ).
      ASSERT sy-fdpos = strlen( some_string ).
    ENDIF.

  ENDMETHOD.


  METHOD initialize_dbtabs.
    DELETE FROM zdemo_abap_tab1.
  ENDMETHOD.


  METHOD select_from_dbtab.

    SELECT FROM zdemo_abap_tab1
      FIELDS *
      WHERE key_field <> 0
      ORDER BY key_field
      INTO TABLE @gt_tab.

  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_unit_dataprov DEFINITION
  PUBLIC
  CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS get_discount RETURNING VALUE(discount) TYPE decfloat34.
    METHODS get_discount_value IMPORTING day_value             TYPE i
                                         time_value            TYPE i
                               RETURNING VALUE(discount_value) TYPE decfloat34.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcl_demo_abap_unit_dataprov IMPLEMENTATION.
  METHOD get_discount.
    "Getting the weekday
    "1) Monday, 2) Tuesday, 3) Wednesday, 4) Thursday, 5) Friday, 6) Saturday, 7) Sunday
    DATA(weekday) = ( 5 + CONV d( xco_cp=>sy->date( xco_cp_time=>time_zone->utc
      )->as( xco_cp_time=>format->iso_8601_basic )->value ) MOD 7 ) MOD 7 + 1.

    "- Standard discount is granted at the weekend (Saturday, Sunday)
    "- On other weekdays, discount is granted depending on the daytime
    IF weekday = 6 OR weekday = 7.
      discount = '20'.
    ELSE.
      "Retrieving the current time in UTC
      DATA(utc_time) = CONV t( xco_cp=>sy->time( xco_cp_time=>time_zone->utc
         )->as( xco_cp_time=>format->iso_8601_basic )->value ).

      discount = COND #(  WHEN utc_time BETWEEN '000000' AND '045959' THEN '15' "Night discount
                          WHEN utc_time BETWEEN '220000' AND '235959' THEN '15' "Night discount
                          WHEN utc_time BETWEEN '050000' AND '115959' THEN '10' "Morning discount
                          WHEN utc_time BETWEEN '180000' AND '215959' THEN '5'  "Evening discount
                          ELSE 0                                                "No discount
                       ).
    ENDIF.
  ENDMETHOD.

  METHOD get_discount_value.
    CASE day_value.
        "Standard discount is granted at the weekend (Saturday, Sunday)
      WHEN 6 OR 7.
        discount_value = '20'.
        "On other weekdays, discount is granted depending on the daytime
      WHEN OTHERS.
        discount_value = SWITCH #( time_value
                                   WHEN 1 THEN '15' "Night discount
                                   WHEN 2 THEN '10' "Morning discount
                                   WHEN 3 THEN '5'  "Evening discount
                                   ELSE '0'         "No discount
         ).
    ENDCASE.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_unit_tdf DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun.
    "--------------- 1) ABAP OO Test Double Framework ---------------
    "The examples in the test include use the cl_abap_testdouble class.

    "----------- 1a) Demonstrating constructor injection -----------

    "Specifying the instance constructor with an optional parameter
    "for the purpose of constructor injection as injection mechanism.
    "In this example, methods are called from another, non-final class.
    "They represent DOCs. Test doubles are injected when running unit
    "tests. The parameter expects an instance of this class.
    METHODS constructor
      IMPORTING oref_constr_inj TYPE REF TO zcl_demo_abap_unit_dataprov OPTIONAL.

    "Declaring an object reference variable that will be used to call
    "methods of an external class (the DOC)
    DATA oref_data_provider TYPE REF TO zcl_demo_abap_unit_dataprov.

    "Method that is tested and contains a DOC. In this case, it is an
    "external method that is called in the implementation part. The DOC
    "is replaced by a test double created using cl_abap_testdouble.
    METHODS td_constr_inj_calc_discount
      IMPORTING
        value         TYPE numeric
      RETURNING
        VALUE(result) TYPE decfloat34.

    "----------- 1b) Demonstrating parameter injection -----------

    "Method that is tested and contains a DOC. In this case, it is an
    "external method that is called in the implementation part. The DOC
    "is replaced by a test double created using cl_abap_testdouble.
    "The example demonstrates parameter injection. Therefore, an
    "optional importing parameter is included. When running the unit
    "test, 'data_prov' is bound, and the test double is injected.
    METHODS td_param_inj_calc_discount
      IMPORTING value         TYPE numeric
                date          TYPE d
                time          TYPE t
                data_prov     TYPE REF TO zcl_demo_abap_unit_dataprov OPTIONAL
      EXPORTING message       TYPE string
                weekday       TYPE string
      RETURNING VALUE(result) TYPE decfloat34.

    "----------- 2) ABAP SQL Test Double Framework -----------
    "The examples in the test include use the cl_osql_test_environment
    "class. Here, a database table represents the DOC.
    "The method includes a SELECT statement.

    METHODS sql_get_shortest_flight_time IMPORTING carrier                TYPE zdemo_abap_flsch-carrid
                                         RETURNING VALUE(shortest_flight) TYPE i.

    "----------- 3) ABAP CDS Test Double Framework -----------
    "The examples in the test include use the cl_cds_get_data_set_environment class.
    "Here, a CDS view entity represents the DOC. The method includes a SELECT
    "statement. Another test method is implemented in the test inlcude that
    "demonstrates the testing of a CDS view entity (without testing a method in the
    "class under test).
    METHODS cds_get_data_set IMPORTING carrier         TYPE zdemo_abap_cds_ve_agg_exp-carrid
                             RETURNING VALUE(agg_line) TYPE zdemo_abap_cds_ve_agg_exp.

    "----------- 4) Managing dependencies on RAP business objects -----------
    "----------- 4a) Demonstrating mocking ABAP EML APIs --------------------
    "----------- ABAP EML read operations -----------------------------------
    "The examples in the test include use the cl_botd_mockemlapi_bo_test_env class.

    "Populating database tables for ABAP EML read requests
    METHODS prep_dbtab_for_eml IMPORTING read_op TYPE abap_boolean DEFAULT abap_false.
    TYPES read_tab_ro TYPE TABLE FOR READ RESULT zdemo_abap_rap_ro_m.
    TYPES read_tab_ch TYPE TABLE FOR READ RESULT zdemo_abap_rap_ro_m\_child.

    "Method that includes an ABAP EML read request on the root entity
    METHODS eml_read_root IMPORTING key           TYPE zdemo_abap_rap_ro_m-key_field
                          RETURNING VALUE(tab_ro) TYPE read_tab_ro.

    "Method that includes an ABAP EML read-by-associaton request
    METHODS eml_rba IMPORTING key           TYPE zdemo_abap_rap_ro_m-key_field
                    RETURNING VALUE(tab_ch) TYPE read_tab_ch.

    "----------- ABAP EML modify operation -----------
    TYPES modify_tab_ro TYPE TABLE FOR CREATE zdemo_abap_rap_ro_m.
    TYPES ty_mapped TYPE RESPONSE FOR MAPPED EARLY zdemo_abap_rap_ro_m.
    TYPES ty_failed TYPE RESPONSE FOR FAILED EARLY zdemo_abap_rap_ro_m.
    TYPES ty_reported TYPE RESPONSE FOR REPORTED EARLY zdemo_abap_rap_ro_m.

    "Method that includes an ABAP EML modify request on the root entity
    METHODS eml_modify_root IMPORTING VALUE(instances) TYPE modify_tab_ro
                            EXPORTING mapped           TYPE ty_mapped
                                      failed           TYPE ty_failed
                                      reported         TYPE ty_reported.

    "----------- 4b) Demonstrating transactional buffer test doubles ---------
    "The examples in the test include use the cl_botd_txbufdbl_bo_test_env class.
    TYPES read_tab_ro_u TYPE TABLE FOR READ RESULT zdemo_abap_rap_ro_u.

    "Method that includes an ABAP EML read request on the root entity
    METHODS eml_read_root_buffer_td IMPORTING key             TYPE zdemo_abap_rap_ro_u-key_field
                                    RETURNING VALUE(tab_ro_u) TYPE read_tab_ro_u.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.

CLASS zcl_demo_abap_unit_tdf IMPLEMENTATION.
  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Creating Test Doubles Using ABAP Frameworks\n| ).

    out->write( `*********************************************************************` ).
    out->write( |*                                                                   *| ).
    out->write( `* ---> Choose Ctrl/Cmd + Shift + F10 to launch all unit tests  <--- *` ).
    out->write( |*                                                                   *| ).
    out->write( `* As the example is set up with a test class outside of this class  *` ).
    out->write( `* and if the unit tests have not yet run, right-click the Foreign   *` ).
    out->write( `* Tests entry in the ABAP Unit tab of ADT, and choose Run.          *` ).
    out->write( |*                                                                   *| ).
    out->write( |*********************************************************************\n\n| ).

    "This implementation includes method calls of those methods that are unit tested
    "in the test include.
    "The implementation is just for demonstration purposes to explore the effect of
    "the methods.

    "Populating demo database tables (only required for running the example class
    "with F9 and exploring the effect of various method calls)
    zcl_demo_abap_aux=>fill_dbtabs( ).

    "----- 1) Methods demonstrating the ABAP OO Test Double Framework in the test include -----
    "----- 1a) Using constructor injection -----
    DATA(td_constr_inj_calc_discount) = td_constr_inj_calc_discount( 100 ).
    out->write( data = td_constr_inj_calc_discount name = `td_constr_inj_calc_discount` ).
    out->write( |\n| ).

    td_constr_inj_calc_discount = td_constr_inj_calc_discount( 500 ).
    out->write( data = td_constr_inj_calc_discount name = `td_constr_inj_calc_discount` ).
    out->write( |\n| ).

    td_constr_inj_calc_discount = td_constr_inj_calc_discount( CONV decfloat34( '3.4' ) ).
    out->write( data = td_constr_inj_calc_discount name = `td_constr_inj_calc_discount` ).
    out->write( |\n| ).

    "----- 1a) Using parameter injection -----
    "Example with Sunday
    td_param_inj_calc_discount(
      EXPORTING
        value     = 100
        date     = '20241201'
        time     = '100000'
      IMPORTING
       weekday   = DATA(weekday)
       message   = DATA(message)
      RECEIVING
        result    = DATA(td_param_inj_calc_discount)
    ).

    out->write( data = td_param_inj_calc_discount name = `td_param_inj_calc_discount` ).
    out->write( data = weekday name = `weekday` ).
    out->write( data = message name = `message` ).
    out->write( |\n| ).

    "Example with a weekday, morning
    td_param_inj_calc_discount(
     EXPORTING
       value     = 100
       date     = '20241202'
       time     = '100000'
     IMPORTING
      weekday   = weekday
      message   = message
     RECEIVING
       result    = td_param_inj_calc_discount
   ).

    out->write( data = td_param_inj_calc_discount name = `td_param_inj_calc_discount` ).
    out->write( data = weekday name = `weekday` ).
    out->write( data = message name = `message` ).
    out->write( |\n| ).

    "Example with a weekday, afternoon
    td_param_inj_calc_discount(
     EXPORTING
       value    = 100
       date     = '20241203'
       time     = '150000'
     IMPORTING
      weekday   = weekday
      message   = message
     RECEIVING
       result    = td_param_inj_calc_discount
   ).

    out->write( data = td_param_inj_calc_discount name = `td_param_inj_calc_discount` ).
    out->write( data = weekday name = `weekday` ).
    out->write( data = message name = `message` ).
    out->write( |\n| ).

    "Example with a weekday, night
    td_param_inj_calc_discount(
     EXPORTING
       value    = 100
       date     = '20241204'
       time     = '230000'
     IMPORTING
      weekday   = weekday
      message   = message
     RECEIVING
       result    = td_param_inj_calc_discount
   ).

    out->write( data = td_param_inj_calc_discount name = `td_param_inj_calc_discount` ).
    out->write( data = weekday name = `weekday` ).
    out->write( data = message name = `message` ).
    out->write( |\n| ).

    "----- 2) Methods demonstrating the ABAP SQL Test Double Framework in the test include -----
    DATA(sql_shortest_flight_time) = sql_get_shortest_flight_time( 'LH' ).
    out->write( data = sql_shortest_flight_time name = `sql_shortest_flight_time` ).
    out->write( |\n| ).

    sql_shortest_flight_time = sql_get_shortest_flight_time( 'AA' ).
    out->write( data = sql_shortest_flight_time name = `sql_shortest_flight_time` ).
    out->write( |\n| ).

    "----- 3) Methods demonstrating the ABAP CDS Test Double Framework in the test include -----
    DATA(data_set_cds) = cds_get_data_set( 'LH' ).
    out->write( data = data_set_cds name = `data_set_cds` ).
    out->write( |\n\n| ).

    data_set_cds = cds_get_data_set( 'AA' ).
    out->write( data = data_set_cds name = `data_set_cds` ).
    out->write( |\n\n| ).

    "----- Methods demonstrating mocking ABAP EML APIs in the test include -----
    "Populating demo database tables
    prep_dbtab_for_eml( read_op = abap_true ).

    DATA(tab_ro) = eml_read_root( key = 1 ).
    out->write( tab_ro ).
    out->write( |\n\n| ).

    DATA(tab_ch) = eml_rba( key = 1 ).
    out->write( tab_ch ).
    out->write( |\n\n| ).

    prep_dbtab_for_eml( ).

    eml_modify_root(
      EXPORTING
        instances =  VALUE #( ( %cid = `cid1` key_field = 3 field1 = 'aaa' field2 = 'bbb' field3 = 30 field4 = 300  )
                              ( %cid = `cid2` key_field = 4 field1 = 'ccc' field2 = 'ddd' field3 = 40 field4 = 400  ) )
      IMPORTING
        mapped    = DATA(m)
        failed    = DATA(f)
        reported  = DATA(r)
    ).

    ASSERT f IS INITIAL.
    ASSERT r IS INITIAL.
    out->write( data = m-root name = `m-root` ).
    out->write( |\n\n| ).

    SELECT * FROM zdemo_abap_rapt1 INTO TABLE @DATA(itab).
    out->write( data = itab name = `itab` ).
  ENDMETHOD.

  METHOD constructor.
    "--------------------- 1a) ---------------------
    "Demonstrating the constructor injection
    "The parameter is only bound when you run the unit test.
    "In that case, the test double is injected, and method calls
    "in the implementations use data from the test double.
    "Otherwise, a new instance is created that is used to call
    "methods (a test double is not injected).
    IF oref_constr_inj IS BOUND.
      oref_data_provider = oref_constr_inj.
    ELSE.
      oref_data_provider = NEW #( ).
    ENDIF.
  ENDMETHOD.

  METHOD td_constr_inj_calc_discount.
    "--------------------- 1a) ---------------------
    "Method that demonstrates the ABAP OO Test Double Framework and
    "constructor injection in ABAP Unit.
    "When running the unit test, 'oref_data_provider' includes the test
    "double. The method expects a numeric value. 'get_discount' returns
    "another numeric value on whose basis a discount calculation is
    "performed. The value returned by the 'get_discount' method depends
    "on the current weekday and the UTC time.
    result = ( value * oref_data_provider->get_discount( ) ) / 100.
    result = value - result.
  ENDMETHOD.

  METHOD td_param_inj_calc_discount.
    "--------------------- 1b) ---------------------
    "Method that demonstrates the ABAP OO Test Double Framework and
    "parameter injection in ABAP Unit.
    "When running the unit test, the optional parameter 'data_prov' is
    "assigned, and therefore bound here. 'oref_data_provider' then includes
    "the test double.
    "The purpose of this method is similar to 'td_constr_inj_calc_discount'.
    "Here, the method expects a date and time besides a numeric value.
    IF data_prov IS BOUND.
      oref_data_provider = data_prov.
    ENDIF.

    "Getting the weekday
    DATA(day_value) = ( 5 + date MOD 7 ) MOD 7 + 1.
    weekday = SWITCH #( day_value
                        WHEN 1 THEN `Monday`
                        WHEN 2 THEN `Tuesday`
                        WHEN 3 THEN `Wednesday`
                        WHEN 4 THEN `Thursday`
                        WHEN 5 THEN `Friday`
                        WHEN 6 THEN `Saturday`
                        WHEN 7 THEN `Sunday` ).

    DATA(time_value) = COND #( WHEN time BETWEEN '000000' AND '045959' THEN 1 "Night discount
                               WHEN time BETWEEN '220000' AND '235959' THEN 1 "Night discount
                               WHEN time BETWEEN '050000' AND '115959' THEN 2 "Morning discount
                               WHEN time BETWEEN '180000' AND '215959' THEN 3 "Evening discount
                               ELSE 0                                         "No discount
                       ).

    weekday = |{ weekday } ({ SWITCH #( time_value WHEN 1 THEN `night` WHEN 2 THEN `morning` WHEN 3 THEN `evening` ELSE `afternoon` ) })|.

    DATA(disc) = oref_data_provider->get_discount_value( day_value = day_value time_value = time_value ).
    result = ( value * disc ) / 100.
    result = value - result.
    message = |Original value: { value }; discount: { disc }; value with discount: { result }; | &&
    |when: { weekday }, { date DATE = ISO }, { time TIME = ISO }|.
  ENDMETHOD.

  METHOD sql_get_shortest_flight_time.
    "--------------------- 2) ---------------------
    "When running the unit test, the DOC (database table) is replaced with a test double.

    "Getting the shortest flight time among a given carrier
    SELECT MIN( fltime ) AS fltime FROM zdemo_abap_flsch WHERE carrid = @carrier INTO @shortest_flight.
  ENDMETHOD.

  METHOD cds_get_data_set.
    "--------------------- 3) ---------------------
    "When running the unit test, the DOC (CDS view entity) is replaced with a test double.

    "Getting a line filtered by the carrier
    SELECT SINGLE * FROM zdemo_abap_cds_ve_agg_exp WHERE carrid = @carrier INTO @agg_line.
  ENDMETHOD.

  METHOD prep_dbtab_for_eml.
    "Preparing database tables for ABAP EML statements
    DELETE FROM zdemo_abap_rapt1.

    IF read_op = abap_true.
      DELETE FROM zdemo_abap_rapt2.
      INSERT zdemo_abap_rapt1 FROM TABLE @( VALUE #( ( key_field = 1 field1 = 'aaa' field2 = 'bbb' field3 = 10 field4 = 100  ) ) ).
      INSERT zdemo_abap_rapt2 FROM TABLE @( VALUE #( ( key_field = 1 key_ch = 11 field_ch1 = 'ccc' field_ch2 = 111  )
                                                     ( key_field = 1 key_ch = 12 field_ch1 = 'ddd' field_ch2 = 112  ) ) ).
    ENDIF.
  ENDMETHOD.

  METHOD eml_read_root.
    "--------------------- 4a) ---------------------
    "Method that includes an ABAP EML read request on the root entity
    "When running the unit test, the ABAP EML API is mocked.

    READ ENTITIES OF zdemo_abap_rap_ro_m
      ENTITY root
      ALL FIELDS WITH VALUE #( ( key_field = key ) )
      RESULT tab_ro.
  ENDMETHOD.

  METHOD eml_rba.
    "--------------------- 4a) ---------------------
    "Method that includes an ABAP EML read-by-assocation request
    "When running the unit test, the ABAP EML API is mocked.

    READ ENTITIES OF zdemo_abap_rap_ro_m
       ENTITY root
       BY \_child
       ALL FIELDS WITH VALUE #( ( key_field = key ) )
       RESULT tab_ch.
  ENDMETHOD.

  METHOD eml_modify_root.
    "--------------------- 4a) ---------------------
    "Method that includes an ABAP EML create request
    "When running the unit test, the ABAP EML API is mocked.

    MODIFY ENTITIES OF zdemo_abap_rap_ro_m
      ENTITY root
      CREATE
      FIELDS ( key_field field1 field2 field3 field4 )
      WITH instances
      MAPPED mapped
      FAILED failed
      REPORTED reported.

    COMMIT ENTITIES.
  ENDMETHOD.

  METHOD eml_read_root_buffer_td.
    "--------------------- 4b) ---------------------
    "Method that includes an ABAP EML read request
    "When running the unit test, a transactional buffer test double is
    "included.

    READ ENTITIES OF zdemo_abap_rap_ro_u
      ENTITY root
      ALL FIELDS WITH VALUE #( ( key_field = key ) )
      RESULT tab_ro_u.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_unit_test DEFINITION
PUBLIC
CREATE PUBLIC.

  PUBLIC SECTION.

    INTERFACES: if_oo_adt_classrun.

    CLASS-METHODS: class_constructor.

    "Optional parameter for the instance constructor for the purpose of
    "constructor injection
    METHODS constructor
      IMPORTING iref_data_prov TYPE REF TO zdemo_abap_get_data_itf OPTIONAL.

  PROTECTED SECTION.

    TYPES carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY.

    METHODS: select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                                RETURNING VALUE(flight_data) TYPE carr_tab.

  PRIVATE SECTION.

    TYPES: int_tab_so TYPE SORTED TABLE OF i WITH UNIQUE KEY table_line,
           int_tab_st TYPE STANDARD TABLE OF i WITH EMPTY KEY,
           occ_rate   TYPE p LENGTH 4 DECIMALS 2,

           BEGIN OF nums_struc,
             num1 TYPE i,
             num2 TYPE i,
           END OF nums_struc,

           nums_tab TYPE TABLE OF nums_struc WITH EMPTY KEY.

    DATA: seats_table              TYPE zdemo_abap_get_data_itf=>carr_tab,
          flight_tab               TYPE TABLE OF zdemo_abap_fli,

          "Reference variable for back door injection
          "Note: In the example, it is a local interface declared in the
          "Local Types tab (the CCIMP include). To make the type known to
          "the global class, see the Class-relevant Local Types tab (the CCDEF include).
          data_provider_local_itf  TYPE REF TO lif_get_data,

          "Reference variable for constructor injection
          "In the example, the type refers to a global interface.
          data_provider_global_itf TYPE REF TO zdemo_abap_get_data_itf,

          "For demonstrating setter injection
          data_provider_setter_inj TYPE REF TO zdemo_abap_get_data_itf,

          "For demonstrating parameter injection
          data_provider_param_inj  TYPE REF TO zdemo_abap_get_data_itf..

    METHODS:
      "Calculates the sum of two numbers
      "This method demonstrates the use of the setup and teardown methods in the test class.
      get_sum IMPORTING key        TYPE zdemo_abap_tab1-key_field
                        char       TYPE zdemo_abap_tab1-char1
              RETURNING VALUE(sum) TYPE i,

      "Calculates the common divisors and the greatest common divisor of two numbers
      get_common_div_and_gcd IMPORTING a               TYPE i
                                       b               TYPE i
                             EXPORTING common_divisors TYPE int_tab_so
                                       gcd             TYPE i,

      "Calculates the digit sum of a number
      get_digit_sum IMPORTING num              TYPE i
                    RETURNING VALUE(digit_sum) TYPE i,

      "Multiple methods that all do the same (they calculate the occupancy rate of flights)
      "but serve different demonstration purposes for the ABAP unit tests in the example.
      "The method implementations involve a depended-on component (DOC). In this case,
      "it is a database access.
      "The methods are intentionally implemented in a similar way. Therefore, almost
      "all of the following methods will display the same output in the console when the
      "class is executed using F9.

      "Method to demonstrate test double injection using inheritance and method redefinition
      get_occ_rate_using_meth IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                              RETURNING VALUE(occupancy_rate) TYPE occ_rate,

      "Method to demonstrate test double injection using test seams
      get_occ_rate_test_seam IMPORTING carrier_id     TYPE zdemo_abap_fli-carrid
                             EXPORTING occupancy_rate TYPE occ_rate
                                       num1           TYPE i
                                       num2           TYPE i,

      "Method to demonstrate test double injection using back door injection and a local interface
      get_occ_rate_local_itf IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                             RETURNING VALUE(occupancy_rate) TYPE occ_rate,

      "Method to demonstrate test double injection using constructor injection and a global interface
      get_occ_rate_global_itf IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                              RETURNING VALUE(occupancy_rate) TYPE occ_rate,

      "Method to demonstrate test double injection using setter injection and a global interface
      get_occ_rate_setter_inj IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                              RETURNING VALUE(occupancy_rate) TYPE occ_rate,

      "Method for setter injection
      setter_meth IMPORTING data_prov TYPE REF TO zdemo_abap_get_data_itf,

      "Method to demonstrate test double injection using parameter injection and a global interface
      "An optional parameter is specified for passing the test double if the method is tested.
      get_occ_rate_param_inj IMPORTING carrier_id            TYPE zdemo_abap_fli-carrid
                                       data_prov             TYPE REF TO zdemo_abap_get_data_itf OPTIONAL
                             RETURNING VALUE(occupancy_rate) TYPE occ_rate.

ENDCLASS.



CLASS zcl_demo_abap_unit_test IMPLEMENTATION.


  METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).

    "Preparing a demo database table for this example (get_sum method)
    DELETE FROM zdemo_abap_tab1.
    INSERT zdemo_abap_tab1 FROM @(
      VALUE #( key_field = 1 char1 = 'aaa' char2 = 'bbb' num1 = 25 num2 = 75 ) ).
  ENDMETHOD.


  METHOD constructor.

    "For demonstrating the back door injection
    data_provider_local_itf = NEW lcl_data_prov_local_itf( ).

    "For demonstrating the constructor injection
    IF iref_data_prov IS BOUND.
      "Note: The parameter is only bound when you run the unit test.
      "When you run the unit test and you debug, you will see that iref_data_prov
      "has a type reference to LTD_TEST_DATA_GLOBAL_INTF.

      data_provider_global_itf = iref_data_prov.

    ELSE.

      data_provider_global_itf = NEW lcl_data_prov_glo_itf( ).

    ENDIF.

    "Object creation for the method call in the get_occ_rate_setter_inj method
    data_provider_setter_inj = NEW lcl_data_prov_glo_itf( ).

  ENDMETHOD.


  METHOD get_common_div_and_gcd.
    "Calculates the common divisors and the greatest common divisor of two numbers

    CLEAR: common_divisors, gcd.

    CHECK a >= 1.
    CHECK b >= 1.

    IF a >= b.
      DATA(greater_num) = a.
      DATA(lower_num) = b.
    ELSE.
      greater_num = b.
      lower_num = a.
    ENDIF.

    "Getting common divisors
    DATA(div) = 1.

    WHILE div <= lower_num.
      IF lower_num MOD div = 0.
        DATA(divisor) = lower_num / div.
        INSERT divisor INTO TABLE common_divisors.
      ENDIF.

      div += 1.
    ENDWHILE.

    LOOP AT common_divisors ASSIGNING FIELD-SYMBOL(<i>).

      IF greater_num MOD <i> <> 0.
        DELETE common_divisors WHERE table_line = <i>.
      ENDIF.

    ENDLOOP.

    "Extracting the greatest common divisor from the list of common divisors
    gcd = common_divisors[ lines( common_divisors ) ].

  ENDMETHOD.


  METHOD get_digit_sum.
    "Calculates the digit sum of a number

    CLEAR digit_sum.

    CHECK num >= 0.

    DATA(converted_int) = CONV string( num ).
    DATA(len) = strlen( converted_int ).

    DO len TIMES.
      DATA(idx) = sy-index - 1.
      digit_sum = digit_sum + converted_int+idx(1).
    ENDDO.

  ENDMETHOD.


  METHOD get_occ_rate_global_itf.
    "Method to demonstrate test double injection using constructor injection
    "and a global interface

    DATA total_seatsmax_global_itf TYPE i.
    DATA total_seatsocc_global_itf TYPE i.

    "Assumption: The original code in this method was as follows (the line commented out).
    "It was identified as DOC (reading data from a database table).

    "DATA(flight_data) = select_flight_data( carrier = carrier_id ).

    "Instead of a method call like above and for a proper unit testing, a global interface
    "is provided.
    "In the example, an interface method is implemented in a local class in the local types
    "tab (CCIMP include): lcl_data_prov_glo_itf

    "When the class is executed using F9, the object used here refers to type lcl_data_prov_glo_itf.
    "When the unit test is executed, the object used here refers to type ltd_test_data_global_intf,
    "i.e. the local test double is injected.
    DATA(flight_data) = data_provider_global_itf->select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data ASSIGNING FIELD-SYMBOL(<l>).

      total_seatsmax_global_itf = total_seatsmax_global_itf + <l>-seatsmax.
      total_seatsocc_global_itf = total_seatsocc_global_itf + <l>-seatsocc.

    ENDLOOP.

    occupancy_rate = total_seatsocc_global_itf / total_seatsmax_global_itf * 100.

  ENDMETHOD.


  METHOD get_occ_rate_local_itf.
    "Method to demonstrate test double injection using back door
    "injection and a local interface

    DATA total_seatsmax_local_itf TYPE i.
    DATA total_seatsocc_local_itf TYPE i.

    "Assumption: The original code in this method was as follows (the line commented out).
    "It was identified as DOC (reading data from a database table).

    "DATA(flight_data) = select_flight_data( carrier = carrier_id ).

    "Instead of a method call like above and for a proper unit testing - a global interface
    "is not available - a local interface is created, and
    "an interface method is implemented. In this example, the local interface is
    "created in the local types tab (CCIMP include): lif_get_data
    "A local class (lcl_data_prov_local_itf) is also created in the CCIMP include. It
    "implements the local interface.

    "When the class is executed using F9, the object used here refers to type lcl_data_prov_local_itf.
    "When the unit test is executed, the object used here refers to type ltd_test_data_local_itf,
    "i.e. the local test double is injected.
    DATA(flight_data) = data_provider_local_itf->select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data ASSIGNING FIELD-SYMBOL(<k>).

      total_seatsmax_local_itf = total_seatsmax_local_itf + <k>-seatsmax.
      total_seatsocc_local_itf = total_seatsocc_local_itf + <k>-seatsocc.

    ENDLOOP.

    occupancy_rate = total_seatsocc_local_itf / total_seatsmax_local_itf * 100.

  ENDMETHOD.


  METHOD get_occ_rate_param_inj.
    "This method demonstrates test double injection using parameter injection.

    DATA total_seatsmax_param_inj TYPE i.
    DATA total_seatsocc_param_inj TYPE i.

    "Assumption: The original code in this method was as follows (the line commented out).
    "It was identified as DOC (reading data from a database table).

    "DATA(flight_data) = select_flight_data( carrier = carrier_id ).

    "Instead of a method call like above and for a proper unit testing, a global interface
    "is provided.
    "In the example, an interface method is implemented in a local class in the local types
    "tab (CCIMP include): lcl_data_prov_glo_itf

    "The method has an optional importing parameter. When the unit test is executed,
    "the parameter is bound. An object of the test double class is passed in that case.
    "Otherwise, when the class is executed using F9, an object of the actual data provider
    "is created.
    IF data_prov IS BOUND.
      data_provider_param_inj = data_prov.
    ELSE.
      data_provider_param_inj = NEW lcl_data_prov_glo_itf( ).
    ENDIF.

    DATA(flight_data) = data_provider_param_inj->select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data ASSIGNING FIELD-SYMBOL(<o>).

      total_seatsmax_param_inj = total_seatsmax_param_inj + <o>-seatsmax.
      total_seatsocc_param_inj = total_seatsocc_param_inj + <o>-seatsocc.

    ENDLOOP.

    occupancy_rate = total_seatsocc_param_inj / total_seatsmax_param_inj * 100.

  ENDMETHOD.


  METHOD get_occ_rate_setter_inj.
    "This method demonstrates test double injection using setting injection.
    "See the setter_meth method.

    DATA total_seatsmax_setter_inj TYPE i.
    DATA total_seatsocc_setter_inj TYPE i.

    "Assumption: The original code in this method was as follows (the line commented out).
    "It was identified as DOC (reading data from a database table).

    "DATA(flight_data) = select_flight_data( carrier = carrier_id ).

    "Instead of a method call like above and for a proper unit testing, a global interface
    "is provided.
    "In the example, an interface method is implemented in a local class in the local types
    "tab (CCIMP include): lcl_data_prov_glo_itf

    "See the comment in the setter_meth method
    DATA(flight_data) = data_provider_setter_inj->select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data ASSIGNING FIELD-SYMBOL(<n>).

      total_seatsmax_setter_inj = total_seatsmax_setter_inj + <n>-seatsmax.
      total_seatsocc_setter_inj = total_seatsocc_setter_inj + <n>-seatsocc.

    ENDLOOP.

    occupancy_rate = total_seatsocc_setter_inj / total_seatsmax_setter_inj * 100.

  ENDMETHOD.


  METHOD get_occ_rate_test_seam.
    "Method to demonstrate test double injection using test seams
    "Note: The code is just for demonstration purposes. Of course, the result can be
    "achieved more elegantly using SQL expressions, for example.

    TEST-SEAM select_flights.
      "DOC
      SELECT seatsmax, seatsocc
        FROM zdemo_abap_fli
        WHERE carrid = @carrier_id
        INTO CORRESPONDING FIELDS OF TABLE @seats_table.
    END-TEST-SEAM.

    DATA total_seatsmax_tm TYPE i.
    DATA total_seatsocc_tm TYPE i.

    LOOP AT seats_table ASSIGNING FIELD-SYMBOL(<j>).

      total_seatsmax_tm = total_seatsmax_tm + <j>-seatsmax.
      total_seatsocc_tm = total_seatsocc_tm + <j>-seatsocc.

    ENDLOOP.

    occupancy_rate = total_seatsocc_tm / total_seatsmax_tm * 100.

    "Further examples for test seams
    DATA(var) = 0.

    "Empty test seam; code is injected during unit test
    "Check the output when running the class using F9 and
    "the test results when running the unit test.
    TEST-SEAM num1.
    END-TEST-SEAM.

    IF var = 0.
      num1 = 1.
    ELSE.
      num1 = 999.
    ENDIF.

    num2 = 0.

    "Empty injection
    "See the test class: The code that is included in the test
    "seam should be excluded from the test. Therefore, the
    "test injection block in the test class is empty.
    "Check the output when running the class using F9 and
    "the test results when running the unit test.
    TEST-SEAM num2.
      num2 = 123.
    END-TEST-SEAM.

  ENDMETHOD.


  METHOD get_occ_rate_using_meth.
    "This method demonstrates test double injection using inheritance and method redefinition.

    DATA total_seatsmax_no TYPE i.
    DATA total_seatsocc_no TYPE i.

    "During the unit test, the redefined method in the test class is called.
    DATA(flight_data) = select_flight_data( carrier = carrier_id ).

    LOOP AT flight_data ASSIGNING FIELD-SYMBOL(<m>).

      total_seatsmax_no = total_seatsmax_no + <m>-seatsmax.
      total_seatsocc_no = total_seatsocc_no + <m>-seatsocc.

    ENDLOOP.

    occupancy_rate = total_seatsocc_no / total_seatsmax_no * 100.

  ENDMETHOD.


  METHOD get_sum.
    "The method selects a record from a database table and sums the values
    "of two fields, both are of type i.

    SELECT SINGLE
            FROM zdemo_abap_tab1
            FIELDS num1 + num2 AS sum
            WHERE key_field = @key
            AND char1 = @char
            INTO @sum.

  ENDMETHOD.


  METHOD if_oo_adt_classrun~main.
    "Note: The example includes a couple of implementations for the methods
    "declared above. And by choosing F9 in ADT, you can run the class and check the
    "output in the console.
    "However, the focus of the example is unit tests. Therefore, check the
    "test classes and methods in the test include (Test Classes tab in ADT).
    "Choose Ctrl/Cmd + Shift + F10 to launch all tests in the class and check the
    "test results in the ABAP Unit tab in ADT.

    out->write( |ABAP Cheat Sheet Example: ABAP Unit Tests\n\n| ).

    out->write( `************************************************************************` ).
    out->write( `---> Choose Ctrl/Cmd + Shift + F10 to launch all tests in the class <---` ).
    out->write( |************************************************************************\n| ).

    out->write( |1) get_sum Method\n\n| ).
    "This method demonstrates the use of the setup and teardown methods in the test class.

    DATA(sum) = get_sum( key = 1 char = 'aaa' ).

    out->write( data = sum name = `sum`  ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) get_common_div_and_gcd Method` ) ).

    "Filling an internal table with numbers on whose bases the common divisors and the
    "greatest common divisor are to be calculated
    DATA(tab) = VALUE nums_tab( ( num1 = 10 num2 = 20 )
                                ( num1 = 100 num2 = 200 )
                                ( num1 = 12 num2 = 6 )
                                ( num1 = 5 num2 = 1 )
                                ( num1 = 50 num2 = 50 )
                                ( num1 = 4 num2 = 8 ) ).

    LOOP AT tab ASSIGNING FIELD-SYMBOL(<a>).
      DATA(tabix) = sy-tabix.
      get_common_div_and_gcd( EXPORTING a = <a>-num1
                                        b = <a>-num2
                              IMPORTING common_divisors = DATA(common_divs) gcd = DATA(gcd) ).

      out->write( |Common divisors of { <a>-num1 } and { <a>-num2 }\n|  ).
      out->write( |\n| ).
      out->write( data = common_divs name = `common_divs`  ).
      out->write( |\n| ).
      out->write( |Greatest common divisor of { <a>-num1 } and { <a>-num2 }: { gcd } |  ).
      out->write( |\n| ).
      IF tabix < lines( tab ).
        out->write( `--------------------------` ).
        out->write( |\n| ).
      ENDIF.
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) get_digit_sum Method` ) ).

    "Filling an internal table with numbers on whose bases the digit sum is to be calculated
    DATA(tab_i) = VALUE int_tab_so( ( 12 )
                                    ( 123 )
                                    ( 3 )
                                    ( 8246 )
                                    ( 1001001 )
                                    ( 0 ) ).

    LOOP AT tab_i ASSIGNING FIELD-SYMBOL(<b>).
      DATA(digit_sum) = get_digit_sum( <b> ).

      out->write( |The digit sum of { <b> } is { digit_sum }.|  ).
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) get_occ_rate_using_meth Method` ) ).
    "In the test class, this method demonstrates test double injection
    "using inheritance and method redefinition.

    "Filling an internal table with carrier ids on whose bases the occupancy
    "rate is to be calculated.
    DATA(tab_str) = VALUE zdemo_abap_get_data_itf=>carr_tab( ( carrid = 'LH' )
                                                              ( carrid = 'AA' )
                                                              ( carrid = 'DL' ) ).

    LOOP AT tab_str ASSIGNING FIELD-SYMBOL(<c>).
      DATA(occupancy_rate) = get_occ_rate_using_meth( <c>-carrid ).

      out->write( |The occupancy rate for airline { <c>-carrid } is { occupancy_rate }%.|  ).
      out->write( |\n| ).
    ENDLOOP.
    out->write( zcl_demo_abap_aux=>heading( `5) get_occ_rate_test_seam Method` ) ).
    "This method demonstrates test double injection using test seams.

    LOOP AT tab_str ASSIGNING FIELD-SYMBOL(<d>).
      get_occ_rate_test_seam( EXPORTING carrier_id = <d>-carrid
                              IMPORTING occupancy_rate = DATA(occupancy_rate_test_seam)
                                        num1           = DATA(num1)
                                        num2           = DATA(num2) ).

      out->write( |The occupancy rate for airline { <d>-carrid } is { occupancy_rate_test_seam }%.|  ).
      out->write( |\n| ).
      out->write( |num1: { num1 }|  ).
      out->write( |\n| ).
      out->write( |num2: { num2 }|  ).
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) get_occ_rate_local_itf Method` ) ).
    "This method demonstrates test double injection using back door
    "injection and a local interface.

    LOOP AT tab_str ASSIGNING FIELD-SYMBOL(<e>).
      DATA(occupancy_rate_local_itf) = get_occ_rate_local_itf( <e>-carrid ).

      out->write( |The occupancy rate for airline { <e>-carrid } is { occupancy_rate_local_itf }%.|  ).
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) get_occ_rate_global_itf Method` ) ).
    "This method demonstrates test double injection using constructor
    "injection and a global interface.

    LOOP AT tab_str ASSIGNING FIELD-SYMBOL(<f>).
      DATA(occupancy_rate_global_itf) = get_occ_rate_global_itf( <f>-carrid ).

      out->write( |The occupancy rate for airline { <f>-carrid } is { occupancy_rate_global_itf }%.| ).
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) get_occ_rate_setter_inj Method` ) ).
    "This method demonstrates test double injection using setter injection and a global interface.

    LOOP AT tab_str ASSIGNING FIELD-SYMBOL(<g>).
      DATA(occupancy_rate_setter_inj) = get_occ_rate_setter_inj( <g>-carrid ).

      out->write( |The occupancy rate for airline { <g>-carrid } is { occupancy_rate_setter_inj }%.| ).
      out->write( |\n| ).
    ENDLOOP.

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `9) get_occ_rate_param_inj Method` ) ).
    "This method demonstrates test double injection using parameter injection and a global interface.

    LOOP AT tab_str ASSIGNING FIELD-SYMBOL(<h>).
      DATA(occupancy_rate_param_inj) = get_occ_rate_param_inj( carrier_id = <h>-carrid ).

      out->write( |The occupancy rate for airline { <h>-carrid } is { occupancy_rate_param_inj }%.| ).
      out->write( |\n| ).
    ENDLOOP.
  ENDMETHOD.

  METHOD select_flight_data.
    "Method that is identified as DOC in the method implementations above.
    "This method is also used for demonstrating test double injection and method redefinition.

    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.
  ENDMETHOD.


  METHOD setter_meth.
    "Method to demonstrate the test double injection using setter injection

    "When the unit test is executed, an object of the test double class is passed as
    "a parameter. Then, the object used here refers to type ltd_test_data_setter_inj,
    "i.e. the local test double is injected.
    data_provider_setter_inj =  data_prov.
  ENDMETHOD.
ENDCLASS.""",
    r"""INTERFACE lif_get_data DEFERRED.""",
    r"""INTERFACE lif_get_data.

  TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
         occ_rate TYPE p LENGTH 4 DECIMALS 2.

  METHODS:
    select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                       RETURNING VALUE(flight_data) TYPE carr_tab,

    "This method is included to demonstrate the PARTIALLY IMPLEMENTED
    "addition in the test class when implementing the test double
    say_hello RETURNING VALUE(hi) TYPE string.

ENDINTERFACE.""",
    r"""CLASS lcl_data_prov_local_itf DEFINITION.
  PUBLIC SECTION.
    INTERFACES lif_get_data.
ENDCLASS.""",
    r"""CLASS lcl_data_prov_local_itf IMPLEMENTATION.

  METHOD lif_get_data~select_flight_data.

    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.

  ENDMETHOD.

  METHOD lif_get_data~say_hello.
    hi = `Hello, ` && sy-uname && `.`.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS lcl_data_prov_glo_itf DEFINITION.
  PUBLIC SECTION.
    INTERFACES zdemo_abap_get_data_itf.
ENDCLASS.""",
    r"""CLASS lcl_data_prov_glo_itf IMPLEMENTATION.

  METHOD zdemo_abap_get_data_itf~select_flight_data.

    SELECT seatsmax, seatsocc
      FROM zdemo_abap_fli
      WHERE carrid = @carrier
      INTO CORRESPONDING FIELDS OF TABLE @flight_data.

  ENDMETHOD.

  METHOD zdemo_abap_get_data_itf~say_hello.
    hi = `Hello, ` && sy-uname && `.`.
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS ltc_test_simple_1 DEFINITION DEFERRED.
CLASS ltc_test_simple_2 DEFINITION DEFERRED.
CLASS ltc_test_doc_seam DEFINITION DEFERRED.
CLASS ltc_test_doc_global_itf DEFINITION DEFERRED.
CLASS ltc_test_doc_local_itf DEFINITION DEFERRED.
CLASS ltc_test_doc_redef DEFINITION DEFERRED.
CLASS ltc_test_doc_setter_inj DEFINITION DEFERRED.
CLASS ltc_test_doc_param_inj DEFINITION DEFERRED.

CLASS zcl_demo_abap_unit_test DEFINITION LOCAL FRIENDS ltc_test_simple_1
                                                      ltc_test_simple_2
                                                      ltc_test_doc_seam
                                                      ltc_test_doc_global_itf
                                                      ltc_test_doc_local_itf
                                                      ltc_test_doc_redef
                                                      ltc_test_doc_setter_inj
                                                      ltc_test_doc_param_inj.""",
    r"""CLASS ltc_test_simple_1 DEFINITION FOR TESTING
RISK LEVEL HARMLESS
DURATION SHORT.

PRIVATE SECTION.

  METHODS: test_get_digit_sum FOR TESTING.

ENDCLASS.
CLASS ltc_test_simple_1 IMPLEMENTATION.
METHOD test_get_digit_sum.
  "The method to be tested calculates the digit sum of an number.

  "Creating an object of class under test
  DATA(ref_cut) = NEW zcl_demo_abap_unit_test( ).

  "Filling an internal table and providing some values against which the production
  "method is tested a few times. There are values included for which the assertion
  "deliberately fails.
  "num1 = actual parameter for the method call
  "num2 = expected result of the method call
  DATA(tab_digit_sum) = VALUE zcl_demo_abap_unit_test=>nums_tab( ( num1 = 124 num2 = 7 )
                                                                  ( num1 = 57 num2 = 12 )
                                                                  ( num1 = 11111 num2 = 5 )
                                                                  ( num1 = 1000 num2 = 1 )
                                                                  ( num1 = 0 num2 = 0 )

                                                                  "To fail:
                                                                  ( num1 = 124 num2 = 8 ) "correct: 7
                                                                  ( num1 = 57 num2 = 13 ) "correct: 12
                                                                  ( num1 = 11111 num2 = 6 ) ). "correct: 5

  "Looping across the internal table and test the method with the values provided.
  LOOP AT tab_digit_sum ASSIGNING FIELD-SYMBOL(<a>).

    "Calling method that is to be tested
    DATA(digit_sum) = ref_cut->get_digit_sum( <a>-num1 ).

    "Assertion
    cl_abap_unit_assert=>assert_equals(
          act = digit_sum
          exp = <a>-num2
          msg = |The digit sum of { <a>-num1 } is not { <a>-num2 }. It is { digit_sum }.|
          quit = if_abap_unit_constant=>quit-no ).

  ENDLOOP.

ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_xml_json DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES: if_oo_adt_classrun,
      "This interface is implemented for serializing and
      "deserialzing instances of classes (objects).
      if_serializable_object.
    CLASS-METHODS class_constructor.

  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-METHODS format IMPORTING input         TYPE data
                                   xml           TYPE abap_bool DEFAULT abap_true
                         RETURNING VALUE(string) TYPE string.
    TYPES c50 TYPE c LENGTH 50.
    TYPES c50_tab_type TYPE TABLE OF c50 WITH EMPTY KEY.
    TYPES x30 TYPE x LENGTH 30.
    TYPES x30_tab_type TYPE TABLE OF x30 WITH EMPTY KEY.

    "The following instance attribues and methods are used for serializing and
    "deserialzing instances of classes (objects)
    DATA: attr_string_a      TYPE string,
          attr_string_b      TYPE string,
          attr_concat_string TYPE string,
          attr_lowercase_str TYPE string.
    METHODS: concatenate_string,
      lowercase_string,
      "The following method can only have output parameters.
      "For each output parameter of the serialize_helper method, you must specify
      "an identically named input parameter of the deserialize_helper method
      "with the same type.
      serialize_helper EXPORTING attr_string_a      TYPE string
                                 attr_string_b      TYPE string
                                 attr_concat_string TYPE string,
      "This method can only have input parameters.
      deserialize_helper IMPORTING attr_string_a      TYPE string
                                   attr_string_b      TYPE string
                                   attr_concat_string TYPE string.

ENDCLASS.""",
    r"""CLASS zcl_demo_abap_xml_json IMPLEMENTATION.

  METHOD if_oo_adt_classrun~main.

    out->write( |ABAP Cheat Sheet Example: Working with XML and JSON in ABAP\n\n| ).
    out->write( |1) Excursion: Converting string <-> xstring| ).
    "In the following examples, many operations are performed using binary data.
    "This excursion shows the conversion of string to xstring and the other way round
    "using a codepage. The examples use UTF-8.
    "For this purpose, you can, for example, use the cl_abap_conv_codepage class
    "and the XCO library.

    "Storing XML data in a data object of type string
    DATA(xml_string) =
      `<flights>` &&
      `    <flight>` &&
      `        <carrier>LH</carrier>` &&
      `        <flightnumber>400</flightnumber>` &&
      `        <departure>` &&
      `            <city>Frankfurt</city>` &&
      `            <airport>FRA</airport>` &&
      `            <time>2023-12-23T10:30:00</time>` &&
      `        </departure>` &&
      `        <arrival>` &&
      `            <city>Berlin</city>` &&
      `            <airport>SXF</airport>` &&
      `            <time>2023-12-23T11:35:00</time>` &&
      `        </arrival>` &&
      `    </flight>` &&
      `    <flight>` &&
      `        <carrier>DL</carrier>` &&
      `        <flightnumber>1984</flightnumber>` &&
      `        <departure>` &&
      `            <city>San Francisco</city>` &&
      `            <airport>SFO</airport>` &&
      `            <time>2023-07-19T10:00:00</time>` &&
      `        </departure>` &&
      `        <arrival>` &&
      `            <city>New York</city>` &&
      `            <airport>JFK</airport>` &&
      `            <time>2023-07-19T18:25:00</time>` &&
      `        </arrival>` &&
      `    </flight>` &&
      `</flights>`.

    "string -> xstring
    "Note: UTF-8 is used by default. Here, it is specified explicitly.
    "Conversion errors are caught using the cx_sy_conversion_codepage class.
    TRY.
        DATA(conv_xstring) = cl_abap_conv_codepage=>create_out( codepage = `UTF-8` )->convert( xml_string ).
      CATCH cx_sy_conversion_codepage.
    ENDTRY.

    "xstring -> string
    DATA(conv_string) = cl_abap_conv_codepage=>create_in( )->convert( conv_xstring ).

    "As an alternative, you can use methods of the XCO library.
    "string -> xstring
    DATA(conv_xstring_xco) = xco_cp=>string( xml_string
      )->as_xstring( xco_cp_character=>code_page->utf_8
      )->value.

    "xstring -> string
    DATA(conv_string_xco) = xco_cp=>xstring( conv_xstring_xco
      )->as_string( xco_cp_character=>code_page->utf_8
      )->value.

    conv_string = format( conv_string ).
    conv_string_xco = format( conv_string_xco ).
    out->write( |\n| ).
    out->write( `Results of the xstring to string conversions:`  ).
    out->write( |\n| ).
    out->write( conv_string  ).
    out->write( |\n| ).
    out->write( conv_string_xco  ).

**********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `2) Processing XML Using Class Libraries` ) ).
    out->write( |Excursion: Usable iXML/sXML Classes and Interfaces\n\n| ).
    "Using a released CDS view, classes and interfaces are retrieved that
    "have 'ixml' and 'sxml' in the name for you to explore the released classes
    "and interfaces in this context.

    SELECT ReleasedObjectType, ReleasedObjectName, ReleaseState
      FROM i_apisforclouddevelopment
      WHERE releasestate = 'RELEASED'
      AND
      ( ReleasedObjectType = 'CLAS' OR ReleasedObjectType = 'INTF' )
      AND
      ( ReleasedObjectName LIKE '%IXML%' OR ReleasedObjectName LIKE '%SXML%' )
      INTO TABLE @DATA(released_xml_libs).

    out->write( zcl_demo_abap_aux=>no_output ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `3) Creating XML Data Using iXML` ) ).
    "In the following example, XML data is created using the iXML library.
    "This is done by creating DOM nodes step by step. The nodes are created as
    "elements and attributes. Content is inserted into the XML data.
    "The example uses an appropriate attribute setting so that the result
    "represents XML data in asXML format.
    "Note: You can check out more examples in the system by choosing CTRL +
    "SHIFT + A in ADT and search for *demo_ixml*.
    "For more information on the classes/methods used, check the documentation
    "by choosing F2 in ADT when placing the cursor on a class/methods.

    "Creating one factory object of the access class cl_ixml_core using the
    "create method. The object is used to access the iXML library.
    DATA(ixml_cr) = cl_ixml_core=>create( ).

    "Creating a document
    DATA(document_cr) = ixml_cr->create_document( ).

    "Step-by-step creation of DOM nodes
    "Creating a root node
    DATA(root) = document_cr->create_element_ns( name   = 'abap'
                                                 prefix = 'asx' ).
    root->set_attribute_ns( name   =  'asx'
                            prefix = 'xmlns'
                            value  = 'http://www.sap.com/abapxml' ).
    root->set_attribute_ns( name  =  'version'
                            value = '1.0' ).
    document_cr->append_child( root ).
    DATA(xml_node1) = document_cr->create_element_ns( prefix = 'asx'
                                                      name   = 'values' ).
    root->append_child( xml_node1 ).
    DATA(xml_node2) = document_cr->create_element_ns( name = 'STRING' ).
    xml_node1->append_child( xml_node2 ).
    xml_node2->append_child( document_cr->create_text( 'Hello ABAP' ) ).

    "Creating a renderer (for rendering the XML document into the output stream)
    DATA xml_doc TYPE xstring.
    ixml_cr->create_renderer( document = document_cr
                              ostream  = ixml_cr->create_stream_factory( )->create_ostream_xstring( string = xml_doc )
                            )->render( ).

    "Getting XML data
    DATA(xml_output) = format( cl_abap_conv_codepage=>create_in( )->convert( xml_doc ) ).
    out->write( xml_output ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `4) Parsing XML Data Using iXML` ) ).
    "Notes on the example:
    "- XML data is transformed to an input steam object and imported to a DOM object in one go using a parser object
    "- If the XML is successfully parsed, DOM object nodes are iterated and accessed
    "- Elements of the XML data and their attributes are processed, read and output
    "- The create_renderer method is used to render XML data into an output stream

    TRY.
        DATA(some_xml) = cl_abap_conv_codepage=>create_out( )->convert(
             `<?xml version="1.0"?>` &&
             `<node attr_a="123">` &&
             ` <subnode1>` &&
             ` <letter>A</letter>` &&
             ` <date format="mm-dd-yyyy">01-01-2024</date>` &&
             ` </subnode1>` &&
             ` <subnode2>`  &&
             ` <text attr_b="1" attr_c="a">abc</text>` &&
             ` <text attr_b="2" attr_c="b">def</text>` &&
             ` <text attr_b="3" attr_c="c">ghi</text>` &&
             ` <text attr_b="4" attr_c="d">jkl</text>` &&
             ` </subnode2>` &&
             `</node>` ).
      CATCH cx_sy_conversion_codepage.
    ENDTRY.

    "Creating one factory object of the access class cl_ixml_core using the
    "create method. It is used to access the iXML library.
    DATA(ixml_pa) = cl_ixml_core=>create( ).
    "Creaing an input stream that is used for the input of XML data
    DATA(stream_factory_pa) = ixml_pa->create_stream_factory( ).
    "Creating an XML document stored in DOM format in the memory
    DATA(document_pa) = ixml_pa->create_document( ).
    "Creating a parser
    "It requires the following input parameters: input stream to be parsed,
    "the XML document to which the stream is parsed, a factory required to create a stream
    DATA(parser_pa) = ixml_pa->create_parser(
                       istream = stream_factory_pa->create_istream_xstring( string = some_xml )
                       document = document_pa
                       stream_factory = stream_factory_pa ).

    IF parser_pa->parse( ) <> 0.
      "Processing errors
      DATA(error_pa_num) = parser_pa->num_errors( ).

      DO error_pa_num TIMES.
        DATA(error_pa) = parser_pa->get_error(
                    index        = sy-index - 1
                    min_severity = 3
                  ).
        DATA(reason_pa) = error_pa->get_reason( ).
        out->write( |Error: { reason_pa }| ).
      ENDDO.
    ELSE.
      "Processing document
      IF document_pa IS NOT INITIAL.
        DATA(iterator_pa) = document_pa->create_iterator( ).
        DATA(node_pa) = iterator_pa->get_next( ).
        WHILE NOT node_pa IS INITIAL.
          DATA(indent) = node_pa->get_height( ) * 2.
          "Rettrieving the node type
          CASE node_pa->get_type( ).
            WHEN if_ixml_node=>co_node_element.
              "Retrieving attributes
              DATA(attributes_pa) = node_pa->get_attributes( ).
              out->write( |Element:{ repeat( val = ` ` occ = indent + 2  ) }{ node_pa->get_name( ) }| ).
              IF NOT attributes_pa IS INITIAL.
                DO attributes_pa->get_length( ) TIMES.
                  DATA(attr) = attributes_pa->get_item( sy-index - 1 ).
                  out->write( |Attribute:{ repeat( val = ` ` occ = indent ) }{ attr->get_name( ) } = { attr->get_value( ) } | ).
                ENDDO.
              ENDIF.
            WHEN if_ixml_node=>co_node_text OR
            if_ixml_node=>co_node_cdata_section.
              out->write( |Text:{ repeat( val = ` ` occ = indent + 5 ) }{ node_pa->get_value( ) }| ).
          ENDCASE.
          "Retrieving the next node
          node_pa = iterator_pa->get_next( ).
        ENDWHILE.
      ENDIF.
    ENDIF.

    "Creating a renderer
    DATA xml_pa TYPE xstring.
    ixml_pa->create_renderer( document = document_pa
                              ostream = ixml_pa->create_stream_factory( )->create_ostream_xstring( string = xml_pa )
                            )->render( ).

    "Getting XML
    DATA(output_ixml_parsing) = cl_abap_conv_codepage=>create_in( )->convert( xml_pa ).

    out->write( |\n| ).
    out->write( output_ixml_parsing ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `5) Creating XML Data Using sXML (Token-Based Rendering)` ) ).
    "For sXML, there are specialized writer classes, such as CL_SXML_STRING_WRITE.
    "Writers created with this class render XML data to a byte string.
    "The XML 1.0 format and UTF-8 are used by default in the create method.
    "Here, the parameters are specified explicitly.
    "Note: The interface IF_SXML_WRITER contains the components that are valid
    "for all readers (the abstract superclass CL_SXML_WRITER includes this
    "interface as well as implementations for all readers). In the example below,
    "a cast is required so as to access special methods (such as open_element).

    DATA(writer) = CAST if_sxml_writer( cl_sxml_string_writer=>create( type     = if_sxml=>co_xt_xml10
                                                                       encoding = 'UTF-8' ) ).

    TRY.
        "Creating nodes (the order of the nodes is important)
        writer->open_element( name = 'flights' ).
        writer->open_element( name = 'flight' ).
        writer->open_element( name = 'carrier' ).
        writer->write_value( 'LH' ).
        writer->close_element( ).
        writer->open_element( name = 'flightnumber' ).
        writer->write_value( '400' ).
        writer->close_element( ).
        writer->close_element( ).
        writer->open_element( name = 'flight' ).
        writer->open_element( name = 'carrier' ).
        writer->write_value( 'DL' ).
        writer->close_element( ).
        writer->open_element( name = 'flightnumber' ).
        writer->write_value( '1984' ).
        writer->close_element( ).
        writer->close_element( ).
        writer->close_element( ).
      CATCH cx_sxml_state_error INTO DATA(error_token).
        out->write( error_token->get_text( ) ).
    ENDTRY.

    "Getting XML data
    "The XML data can be retrieved with the GET_OUTPUT method.
    "Also here, a cast is required. The result is of type xstring.
    DATA(xml_sxml) = CAST cl_sxml_string_writer( writer )->get_output(  ).

    DATA(output_sxml_token_rendering) = format( cl_abap_conv_codepage=>create_in( )->convert( xml_sxml ) ).
    out->write( output_sxml_token_rendering ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `6) Creating XML Data using sXML (Object-Oriented Rendering)` ) ).

    DATA(writer_oo) = CAST if_sxml_writer( cl_sxml_string_writer=>create( type     = if_sxml=>co_xt_xml10
                                                                          encoding = 'UTF-8' ) ).

    TRY.
        writer_oo->write_node( writer_oo->new_open_element( name = 'flights' ) ).

        writer_oo->write_node( writer_oo->new_open_element( name = 'flight' ) ).
        writer_oo->write_node( writer_oo->new_open_element( name = 'carrier' ) ).
        DATA(val) = writer_oo->new_value( ).
        val->set_value( 'AZ' ).
        writer_oo->write_node( val ).
        writer_oo->write_node( writer_oo->new_close_element( ) ).
        writer_oo->write_node( writer_oo->new_open_element( name = 'flightnumber' ) ).
        val = writer_oo->new_value( ).
        val->set_value( '788' ).
        writer_oo->write_node( val ).
        writer_oo->write_node( writer_oo->new_close_element( ) ).
        writer_oo->write_node( writer_oo->new_close_element( ) ).

        writer_oo->write_node( writer_oo->new_open_element( name = 'flight' ) ).
        writer_oo->write_node( writer_oo->new_open_element( name = 'carrier' ) ).
        val = writer_oo->new_value( ).
        val->set_value( 'JL' ).
        writer_oo->write_node( val ).
        writer_oo->write_node( writer_oo->new_close_element( ) ).
        writer_oo->write_node( writer_oo->new_open_element( name = 'flightnumber' ) ).
        val = writer_oo->new_value( ).
        val->set_value( '407' ).
        writer_oo->write_node( val ).
        writer_oo->write_node( writer_oo->new_close_element( ) ).
        writer_oo->write_node( writer_oo->new_close_element( ) ).

        writer_oo->write_node( writer_oo->new_close_element( ) ).
      CATCH cx_sxml_state_error INTO DATA(error_oo).
        out->write( error_oo->get_text( ) ).
    ENDTRY.

    DATA(xml_sxml_oo_rendering) =  CAST cl_sxml_string_writer( writer_oo )->get_output(  ).

    DATA(output_sxml_oo_rendering) = format( cl_abap_conv_codepage=>create_in( )->convert( xml_sxml_oo_rendering ) ).
    out->write( output_sxml_oo_rendering ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `7) Parsing XML Data using sXML (Token-Based Parsing)` ) ).

    "Creating demo XML data to be used in the example
    TRY.
        DATA(xml_to_parse) = cl_abap_conv_codepage=>create_out( )->convert(
             `<?xml version="1.0"?>` &&
             `<node attr_a="123">` &&
             ` <subnode1>` &&
             ` <letter>A</letter>` &&
             ` <date format="mm-dd-yyyy">01-01-2024</date>` &&
             ` </subnode1>` &&
             ` <subnode2>`  &&
             ` <text attr_b="1" attr_c="a">abc</text>` &&
             ` <text attr_b="2" attr_c="b">def</text>` &&
             ` <text attr_b="3" attr_c="c">ghi</text>` &&
             ` <text attr_b="4" attr_c="d">jkl</text>` &&
             ` </subnode2>` &&
             `</node>` ).
      CATCH cx_sy_conversion_codepage.
    ENDTRY.

    "Creating an internal table for display purposes
    DATA: BEGIN OF node_info,
            node_type TYPE string,
            name      TYPE string,
            value     TYPE string,
          END OF node_info,
          nodes_tab LIKE TABLE OF node_info.

    "Creating reader
    "Note: See the comments for the writer above which is similar. For readers,
    "the interface IF_SXML_READER exists. In this example, no special methods
    "are used. Therefore, a cast is not carried out.
    DATA(reader) = cl_sxml_string_reader=>create( xml_to_parse ).
    "DATA(reader_cast) = CAST if_sxml_reader( cl_sxml_string_reader=>create( xml_oo ) ).

    "To iterate accros all nodes, you can call the NEXT_NODE method.
    TRY.
        DO.
          CLEAR node_info.
          reader->next_node( ).

          "When reaching the end of the XML data, the loop is exited.
          IF reader->node_type = if_sxml_node=>co_nt_final.
            EXIT.
          ENDIF.

          "You can access the properties of the node directly.
          "For display purposes, the property information is stored in an internal table.
          "The example here just uses simple demo JSON data. Not all properties are
          "retrieved and displayed.

          "Node type, see the interface if_sxml_node
          node_info-node_type = SWITCH #( reader->node_type WHEN if_sxml_node=>co_nt_initial THEN `CO_NT_INITIAL`
                                                            WHEN if_sxml_node=>co_nt_element_open THEN `CO_NT_ELEMENT_OPEN`
                                                            WHEN if_sxml_node=>co_nt_element_close THEN `CO_NT_ELEMENT_CLOSE`
                                                            WHEN if_sxml_node=>co_nt_value THEN `CO_NT_VALUE`
                                                            WHEN if_sxml_node=>co_nt_attribute THEN `CO_NT_ATTRIBUTE`
                                                            ELSE `Error` ).
          "Name of the element
          node_info-name = reader->name.
          "Character-like value (if it is textual data)
          node_info-value = COND #( WHEN reader->node_type = if_sxml_node=>co_nt_value THEN reader->value ).
          APPEND node_info TO nodes_tab.

          "Once the method is called, you can directly access the attributes of the reader with the required
          "properties of the node. When the parser is on the node of an element opening, you can use the method
          "NEXT_ATTRIBUTE to iterate across the XML element attributes.
          IF reader->node_type = if_sxml_node=>co_nt_element_open.
            DO.
              reader->next_attribute( ).
              IF reader->node_type <> if_sxml_node=>co_nt_attribute.
                EXIT.
              ENDIF.
              APPEND VALUE #( node_type  = `CO_NT_ATTRIBUTE`
                              name       = reader->name
                              value      = reader->value ) TO nodes_tab.
            ENDDO.
          ENDIF.
        ENDDO.

        out->write( nodes_tab ).
      CATCH cx_sxml_state_error INTO DATA(error_parse_token).
        out->write( error_parse_token->get_text( ) ).
    ENDTRY.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `8) Parsing XML Data using sXML (Object-Oriented Parsing)` ) ).

    CLEAR nodes_tab.
    DATA(reader_oo) = cl_sxml_string_reader=>create( xml_to_parse ).

    TRY.
        DO.
          "To iterate accros all nodes, you can call the READ_NEXT_NODE method.
          "When the end of the XML data is reached, the returned value is initial.
          DATA(node_oo) = reader_oo->read_next_node( ).
          IF node_oo IS INITIAL.
            EXIT.
          ENDIF.

          "In object-oriented parsing, methods for token-based parsing are wrapped.
          "An object-oriented access to the node is provided.
          "References to objects that represent the current node are returned.

          "Getting the node type
          DATA(n_type) = node_oo->type.

          "If the parser is currently on the node of an element opening,
          "the node object has the class CL_SXML_OPEN_ELEMENT that implements the
          "interface IF_SXML_OPEN_ELEMENT. With the methods included, you can
          "access the XML attributes of the element, e.g. using the GET_ATTRIBUTES
          "method to put the references for all attributes into an internal table.
          "To access the attributes, a downcast is required.

          CASE n_type.
            WHEN if_sxml_node=>co_nt_element_open.
              DATA(open_element) = CAST if_sxml_open_element( node_oo ).

              APPEND VALUE #( node_type = `open element`
                              name      = open_element->qname-name
                            ) TO nodes_tab.

              DATA(attributes) = open_element->get_attributes( ).

              LOOP AT attributes INTO DATA(attribute).
                APPEND VALUE #( node_type = `attribute`
                                name      = attribute->qname-name
                                value  = SWITCH #( attribute->value_type WHEN if_sxml_value=>co_vt_text THEN attribute->get_value( ) )
                              ) TO nodes_tab.
              ENDLOOP.

            WHEN  if_sxml_node=>co_nt_element_close.
              DATA(close_element) = CAST if_sxml_close_element( node_oo ).

              APPEND VALUE #( node_type = `close element`
                              name      = close_element->qname-name
                            ) TO nodes_tab.

            WHEN  if_sxml_node=>co_nt_value.
              DATA(value_node_oo) = CAST if_sxml_value_node( node_oo ).

              APPEND VALUE #( node_type = `value`
                              value     = SWITCH #( value_node_oo->value_type WHEN if_sxml_value=>co_vt_text THEN value_node_oo->get_value( ) )
                            ) TO nodes_tab.

            WHEN OTHERS.
              APPEND VALUE #( node_type = `Error` ) TO nodes_tab.
          ENDCASE.
        ENDDO.
      CATCH cx_sxml_state_error INTO DATA(error_parse_oo).
        out->write( error_parse_oo->get_text( ) ).
    ENDTRY.

    out->write( nodes_tab ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `XML Transformations` ) ).

    out->write( |9) Excursion: Available ABAP Cheat Sheet Transformations in the System\n\n| ).
    "Excursion using the XCO library. In this example, tranformation programs are retrieved.
    "A filter is applied. Because of a filter that is applied, only the ABAP cheat sheet
    "transformation programs are returned.

    DATA(filter) = xco_cp_abap_repository=>object_name->get_filter(
           xco_cp_abap_sql=>constraint->contains_pattern( 'ZDEMO_ABAP_%' ) ).

    DATA(filtered_transformations) = xco_cp_abap_repository=>objects->xslt->where( VALUE #( ( filter )
      ) )->in( xco_cp_abap=>repository )->get( ).

    IF filtered_transformations IS NOT INITIAL.
      TYPES cst TYPE TABLE OF sxco_tf_object_name WITH EMPTY KEY.
      DATA(cheat_sheet_transformations) = VALUE cst( FOR tr IN filtered_transformations ( tr->name ) ).
      out->write( cheat_sheet_transformations ).
      out->write( |\n| ).
      out->write( `The code contains an implementation that gets all the transformations in the system.` ).
      out->write( `You can check the content of the variable in the debugger. Among the transformations is the predefined identity transformation ID.` ).
    ENDIF.

    "Getting all transformations in the system
    "You can check the table content in the debugger.
    DATA(all_transformations) = xco_cp_abap_repository=>objects->xslt->all->in( xco_cp_abap=>repository )->get( ).
    IF all_transformations IS NOT INITIAL.
      DATA(all_transformations_in_system) = VALUE cst( FOR tr IN all_transformations ( tr->name ) ).
    ENDIF.

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `10) Transforming XML to XML Using XSLT` ) ).
    "In this example, XML is transformed to XML. For this purpose, a simple XSLT
    "program does the following:
    "- All nodes and attributes are copied from the source XML to the target XML
    "  without any changes.
    "- A match on two elements is performed. If matched, two new elements are created
    "  in the target XML. In this operation, calculations are carried out (free seats
    "  and the occupancy rate based on the values of maximum and occupied seats).
    "Note:
    "- The element names in the demo XML data are capitalized on purpose because the
    "  XML data is used in another example that uses the asXML format. In deserializations
    "  of XML data to ABAP data, the elements that are deserialized must be capitalized
    "  so that they can be identified.
    "Tranformations are performed using CALL TRANSFORMATION statements.

    "Creating demo XML data to be used in the example
    TRY.
        DATA(xml_flights) = cl_abap_conv_codepage=>create_out( codepage = `UTF-8` )->convert(
        `<FLIGHTS>` &&
        `    <FLIGHT>` &&
        `        <CARRIER>AA</CARRIER>` &&
        `        <CONNECTIONID>17</CONNECTIONID>` &&
        `        <MAXSEATS>385</MAXSEATS>` &&
        `        <OCCSEATS>369</OCCSEATS>` &&
        `    </FLIGHT>` &&
        `    <FLIGHT>` &&
        `        <CARRIER>LH</CARRIER>` &&
        `        <CONNECTIONID>400</CONNECTIONID>` &&
        `        <MAXSEATS>330</MAXSEATS>` &&
        `        <OCCSEATS>319</OCCSEATS>` &&
        `    </FLIGHT>` &&
        `</FLIGHTS>` ).
      CATCH cx_sy_conversion_codepage.
    ENDTRY.

    DATA xml_a TYPE xstring.

    CALL TRANSFORMATION zdemo_abap_xslt_fl
                        SOURCE XML xml_flights
                        RESULT XML xml_a.

    DATA(conv_xml_a) = format( cl_abap_conv_codepage=>create_in( )->convert( xml_a ) ).
    out->write( conv_xml_a ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `11) Transforming ABAP to XML Using XSLT` ) ).
    "In the example, data entries are retrieved from a database table. Appropriate names for the
    "table columns are used with the AS addition so that the transformation can be carried
    "out based on the selected data.
    "Note: The resulting XML has the asXML format.

    SELECT carrid AS carrier,
           connid AS connectionid,
           seatsmax AS maxSeats,
           seatsocc AS occSeats
      FROM zdemo_abap_fli
      WHERE carrid = 'AZ'
      INTO TABLE @DATA(fli_itab)
      UP TO 2 ROWS.

    DATA xml_b TYPE xstring.

    CALL TRANSFORMATION zdemo_abap_xslt_fl
                        SOURCE flights = fli_itab
                        RESULT XML xml_b.

    DATA(conv_xml_b) = format( cl_abap_conv_codepage=>create_in( )->convert( xml_b ) ).
    out->write( conv_xml_b ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `12) ABAP <-> XML using Simple Transformations (1)` ) ).
    "The following simple transformation examples transform ABAP to XML and back. The
    "Simple Transformation is implemented in a way to transform to the HTML format.
    "This example transforms string tables to html.

    DATA(string_table_a) = VALUE string_table( ( `abc` ) ( `def` ) ( `ghi` ) ).

    DATA xml_c TYPE xstring.

    "ABAP -> XML
    CALL TRANSFORMATION zdemo_abap_st_strhtml
                        SOURCE string_table = string_table_a
                        RESULT XML xml_c.

    DATA(conv_xml_c) = format( cl_abap_conv_codepage=>create_in( )->convert( xml_c ) ).
    out->write( `ABAP -> XML` ).
    out->write( conv_xml_c ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA string_table_b TYPE string_table.
    CALL TRANSFORMATION zdemo_abap_st_strhtml
                              SOURCE XML xml_c
                              RESULT string_table = string_table_b.

    out->write( `XML -> ABAP` ).
    out->write( string_table_b ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `13) ABAP <-> XML using Simple Transformations (2)` ) ).
    "In this example, an internal table is transformed to XML using Simple Transformation.
    "HTML tags are inserted into the XML data as literals.

    SELECT carrid, carrname, currcode, url
     FROM zdemo_abap_carr
     INTO TABLE @DATA(carr_tab_a)
     UP TO 2 ROWS.

    "ABAP -> XML
    DATA str_a TYPE string.

    "The following CALL TRANSFORMATION statement includes the OPTIONS
    "addition. In this example, the XML header should not be added.
    "So, you can take the resulting html and test it in an HTML viewer.

    CALL TRANSFORMATION zdemo_abap_st_carrhtml
                        SOURCE carrier_info = carr_tab_a
                        RESULT XML str_a
                        OPTIONS xml_header = 'NO'.

    out->write( `ABAP -> XML` ).
    out->write( format( str_a ) ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA carr_tab_b LIKE carr_tab_a.

    CALL TRANSFORMATION zdemo_abap_st_carrhtml
                        SOURCE XML str_a
                        RESULT carrier_info = carr_tab_b.

    out->write( `XML -> ABAP` ).
    out->write( carr_tab_b ).

***********************************************************************

    out->write( zcl_demo_abap_aux=>heading( `ABAP <-> XML using XSLT (Using the Predefined Identity Transformation ID)` ) ).
    "The following examples demonstrate serializations (ABAP to XML) and deserializations (XML to ABAP)
    "using the predefined identity transformation ID.
    "Note: In doing so, ABAP data is transformed to their asXML representations that can be used as an
    "      intermediate format and which define a mapping between ABAP data and XML.

    out->write( |14) Elementary type\n\n| ).
    "The example uses type string as an elementary type.

    "ABAP -> XML
    DATA xml_d TYPE xstring.
    DATA(str_b) = `This is some string.`.

    CALL TRANSFORMATION id SOURCE txt = str_b
                           RESULT XML xml_d.

    DATA(conv_xml_d) = cl_abap_conv_codepage=>create_in( )->convert( xml_d ).
    out->write( `ABAP -> XML` ).
    out->write( format( conv_xml_d ) ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA str_c TYPE string.
    CALL TRANSFORMATION id SOURCE XML xml_d
                           RESULT txt = str_c.

    out->write( `XML -> ABAP` ).
    out->write( str_c ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `15) Structures` ) ).

    SELECT SINGLE carrid, carrname, currcode, url
      FROM zdemo_abap_carr
      WHERE carrid = 'LH'
      INTO @DATA(carr_struc_a).

    "ABAP -> XML
    DATA xml_e TYPE xstring.
    CALL TRANSFORMATION id SOURCE structure = carr_struc_a
                           RESULT XML xml_e.

    DATA(conv_xml_e) = cl_abap_conv_codepage=>create_in( )->convert( xml_e ).
    out->write( `ABAP -> XML` ).
    out->write( format( conv_xml_e ) ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA carr_struc_b LIKE carr_struc_a.
    CALL TRANSFORMATION id SOURCE XML xml_e
                           RESULT structure = carr_struc_b.

    out->write( `XML -> ABAP` ).
    out->write( carr_struc_b ).
    out->write( |\n| ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `16) Internal tables` ) ).

    SELECT carrid, connid, fldate, price, currency
      FROM zdemo_abap_fli
      WHERE carrid = 'JL'
      INTO TABLE @DATA(fli_tab_a)
      UP TO 2 ROWS.

    "ABAP -> XML
    DATA xml_f TYPE xstring.
    CALL TRANSFORMATION id SOURCE itab = fli_tab_a
                           RESULT XML xml_f.

    DATA(conv_xml_f) = cl_abap_conv_codepage=>create_in( )->convert( xml_f ).
    out->write( `ABAP -> XML` ).
    out->write( format( conv_xml_f ) ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA fli_tab_b LIKE fli_tab_a.
    CALL TRANSFORMATION id SOURCE XML xml_f
                           RESULT itab = fli_tab_b.

    out->write( `XML -> ABAP` ).
    out->write( fli_tab_b ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `17) Data References` ) ).

    DATA(dref_a) = NEW i( 123 ).

    "ABAP -> XML
    DATA xml_g TYPE xstring.
    CALL TRANSFORMATION id SOURCE dref = dref_a
                           RESULT XML xml_g.

    DATA(conv_xml_g) = cl_abap_conv_codepage=>create_in( )->convert( xml_g ).

    out->write( `ABAP -> XML` ).
    out->write( format( conv_xml_g ) ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA dref_b LIKE dref_a.
    CALL TRANSFORMATION id SOURCE XML xml_g
                           RESULT dref = dref_b.

    out->write( `XML -> ABAP` ).
    out->write( dref_b->* ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `18) Object References` ) ).
    "The following example demonstrates the serialization and deserialization of
    "instances of classes (objects). For example, to serialize instance attributes,
    "classes must implement the if_serializable_object interface. By default, all instance
    "attributes of an object are serialized, regardless of their visibility section.
    "However, you can change this behavior using the serialize_helper and deserialize_helper
    "instance methods. As a result of the transformation, you get an asXML representation of
    "the object.
    "The example is implemented as follows:
    "- The class implements the if_serializable_object interface.
    "- There are 4 instance attributes of type string.
    "- There are two instance methods:
    "  - One method concatenates two of the strings and assigns the resulting string to
    "    another string.
    "  - Another method concatenates two strings and converts the string to lowercase.
    "    The result is assigned to another string.
    "- Serialization preserves instance attribute values in the asXML representation of the
    "  object.
    "- During deserialization, the instance attribute values are transformed back and can
    "  be accessed.
    "- The example includes the implementation of the serialize_helper and deserialize_helper
    "  instance methods. Without implementation, all instance attributes would be
    "  serialized/deserialized. The sample implementation limits serialization/deserialization.
    "  The fourth instance attribute, which is converted to a lowercase string when calling the
    "  method, is not part of the serialization/deserialization. See the implementation of the
    "  serialize_helper and deserialize_helper instance methods. They explicitly specify what
    "  to serialize and deserialize.
    "- Note: For each output parameter of the serialize_helper method, you must specify an
    "  identically-named input parameter of the deserialize_helper method. The parameters must
    "  have the same type.

    DATA(oref_a) = NEW zcl_demo_abap_xml_json(  ).
    oref_a->attr_string_a = `AB`.
    oref_a->attr_string_b = `AP`.
    oref_a->concatenate_string( ).
    oref_a->lowercase_string( ).

    out->write( `Value of instance attribute attr_lowercase_str for the created instance (before serialization/deserialization):` ).
    out->write( oref_a->attr_lowercase_str ).
    out->write( |\n| ).

    "ABAP -> XML
    DATA xml_oref_a TYPE xstring.
    CALL TRANSFORMATION id SOURCE oref = oref_a
                           RESULT XML xml_oref_a.

    DATA(conv_xml_oref_a) = cl_abap_conv_codepage=>create_in( )->convert( xml_oref_a ).

    out->write( `ABAP -> XML` ).
    out->write( format( conv_xml_oref_a ) ).
    out->write( |\n| ).

    "XML -> ABAP
    DATA oref_b LIKE oref_a.
    CALL TRANSFORMATION id SOURCE XML xml_oref_a
                           RESULT oref = oref_b.

    out->write( `XML -> ABAP` ).
    out->write( oref_b->attr_string_a ).
    out->write( oref_b->attr_string_b ).
    out->write( oref_b->attr_concat_string ).
    out->write( |\n| ).
    IF oref_b->attr_lowercase_str IS INITIAL.
      out->write( `The instance attribute attr_lowercase_str is initial. The serialization/deserialization is restricted.` ).
    ENDIF.

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `19) CALL TRANSFORMATION Syntax: Specifying Transformations` ) ).
    "As already covered in the examples above, transformations are specified after
    "CALL TRANSFORMATION. They are either ...

    "... XSLT programs
    CALL TRANSFORMATION zdemo_abap_st_carrhtml SOURCE carrier_info = carr_tab_a
                                                    RESULT XML str_a.

    "... predefined identity transformations
    CALL TRANSFORMATION id SOURCE dref = dref_a
                           RESULT XML xml_g.

    "... dynamically specified transformation (valid for both XSLT and ST). In the examples above,
    "the transformation is specified statically. Dynamic specifications are possible. A
    "character-like data object in uppercase letters is expected in parentheses (either a named
    "or unnamed data objects).
    CALL TRANSFORMATION ('ID') SOURCE dref = dref_a
                               RESULT XML xml_g.

    "If a dynamically specified transformation is not found, an exception of the class
    "CX_INVALID_TRANSFORMATION is raied. The example uses a named data object.
    DATA(notr) = 'NON_EXISTENT_TRANSFORMATION'.
    TRY.
        CALL TRANSFORMATION (notr) SOURCE dref = dref_a
                                   RESULT XML xml_g.
      CATCH cx_invalid_transformation INTO DATA(error_non).
        out->write( error_non->get_text( ) ).
    ENDTRY.

    "... Simple Transformation
    CALL TRANSFORMATION zdemo_abap_st_carrhtml SOURCE XML str_a
                                                    RESULT carrier_info = carr_tab_b.

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `20) CALL TRANSFORMATION Syntax: Sources of Transformations` ) ).
    "The following examples use the predefined identity transformation ID.
    "The result is asXML data and stored in a variable of type xstring.
    "Multiple options and variants are possible. The examples cover a selection.

    out->write( `********** Source options for transforming XML data **********` ).
    out->write( |\n| ).

    "Source: XML data in a data object of type string. It is implicitly transformed to
    "XML in this case.
    "Note: It must have character-like XML data in XML 1.0 format.
    DATA(str_d) = `<TXT>Hello world</TXT>`.
    DATA xml_h TYPE xstring.
    CALL TRANSFORMATION id SOURCE XML str_d
                           RESULT XML xml_h.

    DATA(conv_xml_h) = cl_abap_conv_codepage=>create_in( )->convert( xml_h ).

    out->write( `Source: XML data in data object of type string` ).
    out->write( format( conv_xml_h ) ).
    out->write( |\n| ).

    "Source: XML data in a data object of type xstring
    DATA(xml_i) = cl_abap_conv_codepage=>create_out( )->convert( `<TEXT name="TXT">Hi ABAP</TEXT>` ).
    DATA xml_j TYPE xstring.
    CALL TRANSFORMATION id SOURCE XML xml_i
                           RESULT XML xml_j.

    DATA(conv_xml_j) = cl_abap_conv_codepage=>create_in( )->convert( xml_j ).
    out->write( `Source: XML data in a data object of type xstring` ).
    out->write( format( conv_xml_j ) ).
    out->write( |\n| ).

    "Source: Standard table with character-like data type
    DATA(stdtab_clike) = VALUE c50_tab_type( ( 'Hi' ) ( 'ABAP' ) ).
    DATA xml_k TYPE xstring.
    CALL TRANSFORMATION id SOURCE tab = stdtab_clike
                           RESULT XML xml_k.

    DATA(conv_xml_k) = cl_abap_conv_codepage=>create_in( )->convert( xml_k ).
    out->write( `Source: Standard table with character-like data type` ).
    out->write( format( conv_xml_k ) ).
    out->write( |\n| ).

    "Source: Standard table with byte-like data type
    DATA(stdtab_bytelike) = VALUE x30_tab_type( ( cl_abap_conv_codepage=>create_out( )->convert( `Hello` ) )
                                                ( cl_abap_conv_codepage=>create_out( )->convert( `ABAP` ) ) ).
    DATA xml_l TYPE xstring.
    CALL TRANSFORMATION id SOURCE xtab = stdtab_bytelike
                           RESULT XML xml_l.

    DATA(conv_xml_l) = cl_abap_conv_codepage=>create_in( )->convert( xml_l ).
    out->write( `Source: Standard table with byte-like data type` ).
    out->write( format( conv_xml_l ) ).
    out->write( |\n| ).

    "Furthermore, some references to iXML and sXML libraries are possible.
    "The following example covers sXML (an interface reference variable of type if_sxml_reader).
    DATA(sxml_reader) = cl_sxml_string_reader=>create( xml_h ).
    DATA xml_m TYPE xstring.
    CALL TRANSFORMATION id SOURCE XML sxml_reader
                           RESULT XML xml_m.

    DATA(conv_xml_m) = cl_abap_conv_codepage=>create_in( )->convert( xml_m ).
    out->write( `Source: Interface reference variable with TYPE REF TO if_sxml_reader` ).
    out->write( format( conv_xml_m ) ).
    out->write( |\n| ).

    out->write( `********** Source options for transforming ABAP data **********` ).
    out->write( |\n| ).
    "Using ... SOURCE ... without specifying XML
    "One or multiple ABAP data objects can be specified.

    "Source: Data object of type string
    "elem stands for the name of an XML element.
    DATA(str_e) = `abcdef`.
    DATA xml_n TYPE xstring.
    CALL TRANSFORMATION id SOURCE elem = str_e
                           RESULT XML xml_n.

    DATA(conv_xml_n) = cl_abap_conv_codepage=>create_in( )->convert( xml_n ).
    out->write( `Source: Character string in data object of type string` ).
    out->write( format( conv_xml_n ) ).
    out->write( |\n| ).

    "Source: Data object of type string
    DATA(str_f) = `some string`.
    DATA xml_o TYPE xstring.
    CALL TRANSFORMATION id SOURCE txt = str_f
                           RESULT XML xml_o.

    DATA(conv_xml_o) = cl_abap_conv_codepage=>create_in( )->convert( xml_o ).
    out->write( `Source: Character string of type string` ).
    out->write( format( conv_xml_o ) ).
    out->write( |\n| ).

    "Source: Multiple data objects
    DATA a_i TYPE i VALUE 123.
    DATA b_str TYPE string VALUE `Hallo`.
    DATA c_p TYPE p LENGTH 5 DECIMALS 2 VALUE `4.56`.
    DATA xml_p TYPE xstring.

    CALL TRANSFORMATION id SOURCE x = a_i
                                  y = b_str
                                  z = c_p
                           RESULT XML xml_p.

    DATA(conv_xml_p) = cl_abap_conv_codepage=>create_in( )->convert( xml_p ).
    out->write( `Source: Multiple ABAP data objects in a static parameter list` ).
    out->write( format( conv_xml_p ) ).
    out->write( |\n| ).

    "Source: Dynamic specification of ABAP data objects in an internal table of
    "type abap_trans_srcbind_tab
    DATA(srctab) = VALUE abap_trans_srcbind_tab(
      ( name = 'X' value = REF #( a_i ) )
      ( name = 'Y' value = REF #( b_str ) )
      ( name = 'Z' value = REF #( c_p ) ) ).
    DATA xml_q TYPE xstring.

    CALL TRANSFORMATION id SOURCE (srctab)
                           RESULT XML xml_q.

    DATA(conv_xml_q) = cl_abap_conv_codepage=>create_in( )->convert( xml_q ).
    out->write( `Source: Multiple ABAP data objects in an internal table` ).
    out->write( format( conv_xml_q ) ).

*************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `21) CALL TRANSFORMATION Syntax: Results of Transformations` ) ).
    "As in the examples above, the predefined identity transformation is used here.

    "Creating demo XML data to be used in the example as the source.
    DATA(demo_xml) = cl_abap_conv_codepage=>create_out( )->convert( `<TEXT name="TXT">Hi ABAP</TEXT>` ).

    out->write( `********** Result options for transforming to XML data ********** ` ).
    out->write( |\n| ).

    "Result: Data object of type string
    "The example uses the OPTIONS addition. The XML header should not be added.
    DATA str_g TYPE string.
    CALL TRANSFORMATION id SOURCE XML demo_xml
                           RESULT XML str_g
                           OPTIONS xml_header = 'NO'.

    out->write( `Result: Data object of type string` ).
    out->write( str_g ).
    out->write( |\n| ).

    "Data object of type xstring
    DATA xml_r TYPE xstring.
    CALL TRANSFORMATION id SOURCE XML demo_xml
                           RESULT XML xml_r.

    DATA(conv_xml_r) = cl_abap_conv_codepage=>create_in( )->convert( xml_r ).
    out->write( `Result: Data object of type xstring` ).
    out->write( format( conv_xml_r ) ).
    out->write( |\n| ).

    "Data object declared inline (e.g. DATA(a) or FINAL(b)), which has then the type xstring
    CALL TRANSFORMATION id SOURCE XML demo_xml
                           RESULT XML DATA(xml_s).

    DATA(conv_xml_s) = cl_abap_conv_codepage=>create_in( )->convert( xml_s ).
    out->write( `Result: Data object declared inline (type xstring)` ).
    out->write( format( conv_xml_s ) ).
    out->write( |\n| ).

    "Standard table with character-like line type
    DATA stdtab_clike_b TYPE c50_tab_type.
    CALL TRANSFORMATION id SOURCE XML demo_xml
                           RESULT XML stdtab_clike_b
                           OPTIONS xml_header = 'NO'.

    out->write( `Result: Standard table with character-like line type` ).
    out->write( stdtab_clike_b ).
    out->write( |\n| ).

    "Standard table with byte-like line type
    DATA stdtab_bytelike_b TYPE x30_tab_type.
    CALL TRANSFORMATION id SOURCE XML demo_xml
                           RESULT XML stdtab_bytelike_b.

    out->write( `Result: Standard table with byte-like line type` ).
    out->write( stdtab_bytelike_b ).
    out->write( |\n| ).

    "Furthermore, some references to iXML and sXML libraries are possible.
    "The following example covers sXML (an object reference variable of type ref to cl_sxml_string_writer)
    "Other types are possible, for example JSON writers.
    DATA(writer4tr) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_xml10 ).
    CALL TRANSFORMATION id SOURCE XML demo_xml
                           RESULT XML writer4tr.

    DATA(xml_t) = writer4tr->get_output( ).
    DATA(conv_xml_t) = cl_abap_conv_codepage=>create_in( )->convert( xml_t ).
    out->write( `Result: Object reference variable with type ref to cl_sxml_string_writer` ).
    out->write( format( conv_xml_t ) ).
    out->write( |\n| ).

    out->write( `********** Result options for transforming to ABAP data **********` ).
    out->write( |\n| ).

    "Similar to above, multiple ABAP data objects can be specified as a static parameter list.
    "Here, the example from above is used. The tranformation is performed the other way round.
    DATA d_i LIKE a_i.
    DATA e_str LIKE b_str.
    DATA f_p LIKE c_p.

    CALL TRANSFORMATION id SOURCE XML xml_p
                           RESULT x = d_i
                                  y = e_str
                                  z = f_p.

    out->write( `Result: Multiple ABAP data objects in a static parameter list` ).
    out->write( d_i ).
    out->write( e_str ).
    out->write( f_p ).
    out->write( |\n| ).

    "Specifying an internal table of type abap_trans_resbind_tab
    DATA g_i LIKE a_i.
    DATA h_str LIKE b_str.
    DATA i_p LIKE c_p.

    "Note: Only bound parts are deserialized, i.e. the result table must be
    "filled accordingly.
    DATA(restab) = VALUE abap_trans_resbind_tab(
       ( name = 'X' value = REF #( d_i ) )
       ( name = 'Y' value = REF #( e_str ) )
       ( name = 'Z' value = REF #( f_p ) ) ).

    CALL TRANSFORMATION id SOURCE XML xml_q
                           RESULT (restab).

    out->write( `Result: Multiple ABAP data objects in an internal table` ).
    out->write( restab ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `22) Transforming JSON Data Using Transformations` ) ).
    "Note: When the identity transformation ID is used, the format is asJSON.

    "Elementary type
    DATA str_h TYPE string VALUE `Hello`.
    "ABAP -> JSON
    "Creating a JSON writer
    DATA(json_wr_a) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_json ).

    CALL TRANSFORMATION id SOURCE hi = str_h
                           RESULT XML json_wr_a.

    DATA(json_a) = cl_abap_conv_codepage=>create_in( )->convert( json_wr_a->get_output( ) ).

    out->write( `ABAP -> JSON: Elementary type` ).
    out->write( json_a ).
    out->write( |\n| ).

    "JSON -> ABAP
    DATA str_i TYPE string.
    "Note: CALL TRANSFORMATION handles JSON sources implicitly.
    CALL TRANSFORMATION id SOURCE XML json_a
                           RESULT hi = str_i.

    out->write( `JSON -> ABAP: Elementary type` ).
    out->write( str_i ).
    out->write( |\n| ).

    "Structure
    SELECT SINGLE carrid, carrname, currcode, url
      FROM zdemo_abap_carr
      WHERE carrid = 'AZ'
      INTO @DATA(carr_struc_c).

    "ABAP -> JSON
    DATA(json_wr_b) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_json ).

    CALL TRANSFORMATION id SOURCE structure = carr_struc_c
                           RESULT XML json_wr_b.

    DATA(json_b) = cl_abap_conv_codepage=>create_in( )->convert( json_wr_b->get_output( ) ).
    out->write( `ABAP -> JSON: Structure` ).
    out->write( json_b ).
    out->write( |\n| ).

    "JSON -> ABAP
    DATA carr_struc_d LIKE carr_struc_c.
    CALL TRANSFORMATION id SOURCE XML json_b
                           RESULT structure = carr_struc_d.

    out->write( `JSON -> ABAP: Structure` ).
    out->write( carr_struc_d  ).
    out->write( |\n| ).

    "Internal table
    SELECT carrid, carrname, currcode, url
      FROM zdemo_abap_carr
      INTO TABLE @DATA(carr_tab_c)
      UP TO 2 ROWS.

    "ABAP -> JSON
    "This examples uses a cast to get access to further methods.
    DATA(json_wr_c) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_json ).
    DATA(json_wr_cast) = CAST if_sxml_writer( json_wr_c ).

    "With the following method calls, the result is formatted.
    json_wr_cast->set_option( option = if_sxml_writer=>co_opt_linebreaks ).
    json_wr_cast->set_option( option = if_sxml_writer=>co_opt_indent ).

    CALL TRANSFORMATION id SOURCE itab = carr_tab_c
                           RESULT XML json_wr_c.

    DATA(json_c) = cl_abap_conv_codepage=>create_in( )->convert( json_wr_c->get_output( ) ).
    out->write( `ABAP -> JSON: Internal table` ).
    out->write( json_c ).
    out->write( |\n| ).

    "JSON -> ABAP
    DATA carr_tab_d LIKE carr_tab_c.

    CALL TRANSFORMATION id SOURCE XML json_c
                           RESULT itab = carr_tab_d.

    out->write( `JSON -> ABAP: Internal table` ).
    out->write( carr_tab_d ).
    out->write( |\n| ).

    "JSON -> XML
    DATA(str_j) =
    `{` &&
    `"flights": [` &&
    `    {` &&
    `        "carrier": "LH",` &&
    `        "connectionid": "400",` &&
    `        "from": "Frankfurt",` &&
    `        "to": "Berlin"` &&
    `    },` &&
    `    {` &&
    `        "carrier": "DL",` &&
    `        "connectionid": "400",` &&
    `        "from": "San Francisco",` &&
    `        "to": "New York"` &&
    `    }` &&
    `]` &&
    `}`.

    DATA(json_d) = cl_abap_conv_codepage=>create_out( )->convert( str_j ).
    DATA(json_wr_d) = cl_sxml_string_reader=>create( json_d ).
    DATA json2xml_ct TYPE xstring.

    "JSON -> XML using CALL TRANSFORMATION
    CALL TRANSFORMATION id SOURCE XML json_wr_d
                           RESULT XML json2xml_ct.

    DATA(conv_json2xml_ct) = cl_abap_conv_codepage=>create_in( )->convert( json2xml_ct ).

    out->write( `JSON -> XML using CALL TRANSFORMATION` ).
    out->write( format( conv_json2xml_ct ) ).
    out->write( |\n| ).

    "JSON -> XML using sXML
    DATA(reader_a) = cl_sxml_string_reader=>create( cl_abap_conv_codepage=>create_out(
                        )->convert( str_j ) ).
    "XML writer (note the type specification in contrast to the previous examples)
    DATA(xml_wr) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_xml10 ).

    TRY.
        reader_a->next_node( ).
        "The reader parses the data in one go by calling the SKIP_NODE method.
        "The data is passed to an XML writer.
        reader_a->skip_node( xml_wr ).
      CATCH cx_sxml_parse_error INTO DATA(err_pa).
        out->write( err_pa->get_text( ) ).
    ENDTRY.

    DATA(json2xml_sxml) = cl_abap_conv_codepage=>create_in( )->convert( xml_wr->get_output( ) ).
    out->write( `JSON -> XML using sXML` ).
    out->write( format( json2xml_sxml ) ).
    out->write( |\n| ).

    "XML -> JSON using CALL TRANSFORMATION
    DATA(json_wr_f) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_json ).

    CALL TRANSFORMATION id SOURCE XML json2xml_sxml
                           RESULT XML json_wr_f.

    DATA(xml2json_ct) = cl_abap_conv_codepage=>create_in( )->convert( json_wr_f->get_output( ) ).
    out->write( `XML -> JSON using CALL TRANSFORMATION` ).
    out->write( xml2json_ct ).
    out->write( |\n| ).

    "XML -> JSON using sXML
    DATA(reader_b) = cl_sxml_string_reader=>create( cl_abap_conv_codepage=>create_out( )->convert( xml2json_ct ) ).
    DATA(json_wr) = cl_sxml_string_writer=>create( type = if_sxml=>co_xt_json ).

    TRY.
        reader_b->next_node( ).
        reader_b->skip_node( json_wr ).
      CATCH cx_sxml_parse_error INTO DATA(err_xj).
        out->write( err_xj->get_text( ) ).
    ENDTRY.

    DATA(xml2json_sxml) = cl_abap_conv_codepage=>create_in( )->convert( json_wr->get_output( ) ).
    out->write( `XML -> JSON using sXML` ).
    out->write( xml2json_sxml ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `23) Handling JSON Data with XCO Classes` ) ).
    "Note: Unlike above, the following snippets do not work with asJSON as intermediate
    "format.

    DATA: BEGIN OF carrier_struc,
            carrier_id    TYPE c LENGTH 3,
            connection_id TYPE n LENGTH 4,
            city_from     TYPE c LENGTH 20,
            city_to       TYPE c LENGTH 20,
          END OF carrier_struc.

    DATA carriers_tab LIKE TABLE OF carrier_struc WITH EMPTY KEY.

    carrier_struc = VALUE #( carrier_id = 'AA' connection_id = '17' city_from = 'New York' city_to = 'San Francisco' ).
    carriers_tab = VALUE #( ( carrier_id = 'AZ' connection_id = '788' city_from = 'Rome' city_to = 'Tokyo' )
                            ( carrier_id = 'JL' connection_id = '408' city_from = 'Frankfurt' city_to = 'Tokyo' )
                            ( carrier_id = 'LH' connection_id = '2402' city_from = 'Frankfurt' city_to = 'Berlin' ) ).

    "ABAP (structure) -> JSON using XCO
    DATA(struc2json_xco) = xco_cp_json=>data->from_abap( carrier_struc )->to_string( ).
    out->write( `ABAP (structure) -> JSON using XCO` ).
    out->write( format( input = struc2json_xco xml = abap_false ) ).
    out->write( |\n| ).

    "ABAP (internal table) -> JSON using XCO
    DATA(itab2json_xco) = xco_cp_json=>data->from_abap( carriers_tab )->to_string( ).
    out->write( `ABAP (internal table) -> JSON using XCO` ).
    out->write( format( input = itab2json_xco xml = abap_false ) ).
    out->write( |\n| ).

    "JSON -> ABAP (structure) using XCO
    DATA json2struc_xco LIKE carrier_struc.
    xco_cp_json=>data->from_string( struc2json_xco )->write_to( REF #( json2struc_xco ) ).
    out->write( `JSON -> ABAP (structure) using XCO` ).
    out->write( json2struc_xco ).
    out->write( |\n| ).

    "JSON -> ABAP (internal table) using XCO
    DATA json2itab_xco LIKE carriers_tab.
    xco_cp_json=>data->from_string( itab2json_xco )->write_to( REF #( json2itab_xco ) ).
    out->write( `JSON -> ABAP (internal table) using XCO` ).
    out->write( json2itab_xco ).
    out->write( |\n| ).

    "Creating JSON using XCO
    "Check out more methods that offer more options to build the JSON by clicking
    "CTRL + Space after '->' in ADT.
    DATA(json_builder_xco) = xco_cp_json=>data->builder( ).
    json_builder_xco->begin_object(
      )->add_member( 'CarrierId' )->add_string( 'DL'
      )->add_member( 'ConnectionId' )->add_string( '1984'
      )->add_member( 'CityFrom' )->add_string( 'San Francisco'
      )->add_member( 'CityTo' )->add_string( 'New York'
      )->end_object( ).

    "Getting JSON data
    DATA(json_created_xco) = json_builder_xco->get_data( )->to_string( ).

    out->write( `Creating JSON using XCO` ).
    out->write( format( input = json_created_xco xml = abap_false ) ).
    out->write( |\n| ).

    "Transforming the created JSON to ABAP (structure)
    "Note: The JSON was intentionally created without the underscores in the
    "name to demonstrate the 'apply' method. The following example demonstrates
    "a transformation of camel case and underscore notation. As above, check out
    "more options by clicking CTRL + Space after '...transformation->'.
    CLEAR json2struc_xco.
    xco_cp_json=>data->from_string( json_created_xco )->apply( VALUE #(
      ( xco_cp_json=>transformation->pascal_case_to_underscore ) ) )->write_to( REF #( json2struc_xco ) ).

    out->write( `JSON -> ABAP (structure) using XCO demonstrating the apply method` ).
    out->write( json2struc_xco ).

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `24) Handling JSON Data with the  /ui2/cl_json Class` ) ).

    TYPES: BEGIN OF demo_struc,
             carrier_id    TYPE c LENGTH 3,
             connection_id TYPE n LENGTH 4,
             city_from     TYPE c LENGTH 20,
             city_to       TYPE c LENGTH 20,
           END OF demo_struc.
    DATA itab TYPE TABLE OF demo_struc WITH EMPTY KEY.
    itab = VALUE #( ( carrier_id = 'AA' connection_id = '0017' city_from = 'New York' city_to = 'San Francisco' )
                    ( carrier_id = 'AZ' connection_id = '0789' city_from = 'Tokyo' city_to = 'Rome' ) ).

    "---------------- Serializing ----------------

    DATA(abap_to_json) = /ui2/cl_json=>serialize( data = itab ).
    "Note the many additional, optional parameters such as for formatting the
    "serialized JSON. For more information, see the class documentation.
    DATA(abap_to_json_pretty) = /ui2/cl_json=>serialize( data = itab
                                                         format_output = abap_true ).
    DATA(abap_to_json_pretty_name) = /ui2/cl_json=>serialize( data = itab
                                                              format_output = abap_true
                                                              pretty_name = /ui2/cl_json=>pretty_mode-camel_case ).

    out->write( `---------- ABAP -> JSON ----------` ).
    out->write( abap_to_json ).
    out->write( |\n| ).
    out->write( `---------- ABAP -> JSON (pretty printed) ----------` ).
    out->write( abap_to_json_pretty ).
    out->write( |\n| ).
    out->write( `---------- ABAP -> JSON (camel case) ----------` ).
    out->write( abap_to_json_pretty_name ).
    out->write( |\n| ).

    "---------------- Deserializing ----------------

    DATA(json_to_abap) = abap_to_json.
    DATA itab_json_to_abap LIKE itab.

    /ui2/cl_json=>deserialize( EXPORTING json = json_to_abap
                               CHANGING data  = itab_json_to_abap ).

    out->write( `---------- JSON -> ABAP ----------` ).
    out->write( itab_json_to_abap ).
    out->write( |\n| ).

    "---------------- Deserializing: Applying name mapping ----------------
    "Creating an internal table with different field names
    TYPES: BEGIN OF demo_struc4map,
             carr TYPE c LENGTH 3,
             conn TYPE n LENGTH 4,
             from TYPE c LENGTH 20,
             to   TYPE c LENGTH 20,
           END OF demo_struc4map.
    DATA itab4map TYPE TABLE OF demo_struc4map WITH EMPTY KEY.

    /ui2/cl_json=>deserialize( EXPORTING json = json_to_abap
                               name_mappings = VALUE #( ( abap = 'CARR' json = `CARRIER_ID` )
                                                        ( abap = 'CONN' json = `CONNECTION_ID` )
                                                        ( abap = 'FROM' json = `CITY_FROM` )
                                                        ( abap = 'TO' json = `CITY_TO` ) )
                               CHANGING data  = itab4map ).

    out->write( `---------- JSON -> ABAP (Name mapping) ----------` ).
    out->write( itab4map ).
    out->write( |\n| ).

    "---------------- Deserializing: Using JSON as xstring ----------------

    DATA(json_xstring) = cl_abap_conv_codepage=>create_out( )->convert(
   `[` &&
   `    {` &&
   `        "carrier_id": "LH",` &&
   `        "connection_id": "400",` &&
   `        "city_from": "Frankfurt",` &&
   `        "city_to": "Berlin"` &&
   `    },` &&
   `    {` &&
   `        "carrier_id": "DL",` &&
   `        "connection_id": "1984",` &&
   `        "city_from": "San Francisco",` &&
   `        "city_to": "New York"` &&
   `    },` &&
   `    {` &&
   `        "carrier_id": "AZ",` &&
   `        "connection_id": "790",` &&
   `        "city_from": "Rome",` &&
   `        "city_to": "Osaka"` &&
   `    }` &&
   `]` ).

    DATA itab_json_xstr_to_abap LIKE itab.
    /ui2/cl_json=>deserialize( EXPORTING jsonx = json_xstring
                               CHANGING data  = itab_json_xstr_to_abap ).

    out->write( `---------- JSON (xstring) -> ABAP ----------` ).
    out->write( itab_json_xstr_to_abap ).
    out->write( |\n| ).

    "---------------- Deserializing: No equivalent ABAP type available ----------------

    "The example assumes that there is no equivalent ABAP type available for JSON data
    "that is to be deserialized. You can use the 'generate' method that has a
    "returning parameter of the generic type 'ref to data'.
    DATA(json) = `[{"CARRIER_ID":"AA","CONNECTION_ID":17,"CITY_FROM":"New York","CITY_TO":"San Francisco"},` &&
                 `{"CARRIER_ID":"AZ","CONNECTION_ID":789,"CITY_FROM":"Tokyo","CITY_TO":"Rome"}]`.

    DATA(dref) = /ui2/cl_json=>generate( json = json ).
    DATA(dref_xstr) = /ui2/cl_json=>generate( jsonx = json_xstring ).

    "You can further process the content, for example, with RTTS as outlined in the
    "Dynamic Programming cheat sheet.
    IF dref IS BOUND.
      out->write( `---------- JSON -> ABAP (unknown type) ----------` ).
      out->write( dref->* ).
      out->write( |\n| ).
    ENDIF.

    IF dref_xstr IS BOUND.
      out->write( `---------- JSON (xstring) -> ABAP (unknown type) ----------` ).
      out->write( dref_xstr->* ).
    ENDIF.

************************************************************************

    out->write( zcl_demo_abap_aux=>heading( `25) Excursion: Compressing and Decompressing Binary Data` ) ).
    "You may want to process or store binary data. The data can be very large.
    "You can compress the data in gzip format and decompress it for further processing using
    "the cl_abap_gzip class. Check out appropriate exceptions to be caught. The simple example
    "just specifies cx_root. See the class documentation for more information.
    "This example uses a data object of type xstring from a previous example.

    "Compressing binary data
    DATA xstr_comp TYPE xstring.
    TRY.
        cl_abap_gzip=>compress_binary( EXPORTING raw_in   = xml_oref_a
                                       IMPORTING gzip_out = xstr_comp ).
      CATCH cx_root INTO DATA(error_comp).
        out->write( error_comp->get_text( ) ).
    ENDTRY.

    "Decompressing binary data
    DATA xstr_decomp TYPE xstring.
    TRY.
        cl_abap_gzip=>decompress_binary( EXPORTING gzip_in = xstr_comp
                                         IMPORTING raw_out = xstr_decomp ).

      CATCH cx_root INTO DATA(error_decomp).
        out->write( error_decomp->get_text( ) ).
    ENDTRY.

    "Checking the xstring length of the variables used and comparing the result
    DATA(strlen_original_xstring) = xstrlen( xml_oref_a ).
    out->write( |Length of original binary data object: { strlen_original_xstring }| ).
    DATA(strlen_comp) = xstrlen( xstr_comp ).
    out->write( |Length of compressed binary data object: { strlen_comp }| ).
    DATA(strlen_decomp) = xstrlen( xstr_decomp ).
    out->write( |Length of decompressed binary data object: { strlen_decomp }| ).
    IF xml_oref_a = xstr_decomp.
      out->write( `The decompressed binary data object has the same value as the original binary data object.` ).
    ENDIF.

  ENDMETHOD.
  METHOD format.
    TRY.
        DATA(xstr) = cl_abap_conv_codepage=>create_out( )->convert( input ).
        DATA(reader) = cl_sxml_string_reader=>create( xstr ).
        DATA(writer) = CAST if_sxml_writer( cl_sxml_string_writer=>create(
          type = COND #( WHEN xml = abap_true THEN  if_sxml=>co_xt_xml10 ELSE if_sxml=>co_xt_json ) ) ).
        writer->set_option( option = if_sxml_writer=>co_opt_linebreaks ).
        writer->set_option( option = if_sxml_writer=>co_opt_indent ).
        reader->next_node( ).
        reader->skip_node( writer ).
        string = cl_abap_conv_codepage=>create_in( )->convert( CAST cl_sxml_string_writer( writer )->get_output( ) ).
      CATCH cx_root.
        string = `Issue when formatting.`.
    ENDTRY.

  ENDMETHOD.

  METHOD class_constructor.
    "Filling demo database tables.
    zcl_demo_abap_aux=>fill_dbtabs( ).
  ENDMETHOD.

  METHOD concatenate_string.
    attr_concat_string = attr_string_a && attr_string_b.
  ENDMETHOD.

  METHOD deserialize_helper.
    me->attr_string_a = attr_string_a.
    me->attr_string_b = attr_string_b.
    me->attr_concat_string = attr_concat_string.
  ENDMETHOD.

  METHOD serialize_helper.
    attr_string_a = me->attr_string_a.
    attr_string_b = me->attr_string_b.
    attr_concat_string = me->attr_concat_string.
  ENDMETHOD.

  METHOD lowercase_string.
    attr_lowercase_str = to_lower( attr_string_a && attr_string_b ).
  ENDMETHOD.

ENDCLASS.""",
    r"""CLASS zcx_demo_abap_error_a DEFINITION
  PUBLIC
  INHERITING FROM cx_dynamic_check
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES if_t100_message.

    CONSTANTS message_class TYPE symsgid VALUE 'ZDEMO_ABAP_MESSAGES'.

    CONSTANTS:
      BEGIN OF zcx_demo_abap_error_a,
        msgid TYPE symsgid VALUE message_class,
        msgno TYPE symsgno VALUE '001',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zcx_demo_abap_error_a.

    CONSTANTS:
      BEGIN OF error_002,
        msgid TYPE symsgid VALUE message_class,
        msgno TYPE symsgno VALUE '002',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF error_002.

    CONSTANTS:
      BEGIN OF error_003,
        msgid TYPE symsgid VALUE message_class,
        msgno TYPE symsgno VALUE '003',
        attr1 TYPE scx_attrname VALUE 'P_003_A',
        attr2 TYPE scx_attrname VALUE 'P_003_B',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF error_003.

    CONSTANTS:
      BEGIN OF error_004,
        msgid TYPE symsgid VALUE message_class,
        msgno TYPE symsgno VALUE '004',
        attr1 TYPE scx_attrname VALUE 'P_004_A',
        attr2 TYPE scx_attrname VALUE 'P_004_B',
        attr3 TYPE scx_attrname VALUE 'P_004_C',
        attr4 TYPE scx_attrname VALUE 'P_004_D',
      END OF error_004.

    CONSTANTS:
      BEGIN OF error_005,
        msgid TYPE symsgid VALUE message_class,
        msgno TYPE symsgno VALUE '005',
        attr1 TYPE scx_attrname VALUE 'P_005_A',
        attr2 TYPE scx_attrname VALUE 'P_005_B',
        attr3 TYPE scx_attrname VALUE 'P_005_C',
        attr4 TYPE scx_attrname VALUE 'P_005_D',
      END OF error_005.

    DATA p_003_a TYPE string.
    DATA p_003_b TYPE string.
    DATA p_004_a TYPE string.
    DATA p_004_b TYPE string.
    DATA p_004_c TYPE string.
    DATA p_004_d TYPE string.
    DATA p_005_a TYPE string.
    DATA p_005_b TYPE string.
    DATA p_005_c TYPE string.
    DATA p_005_d TYPE string.

    METHODS constructor
      IMPORTING
        textid   LIKE if_t100_message=>t100key OPTIONAL
        previous LIKE previous OPTIONAL
        p_003_a  TYPE string OPTIONAL
        p_003_b  TYPE string OPTIONAL
        p_004_a  TYPE string OPTIONAL
        p_004_b  TYPE string OPTIONAL
        p_004_c  TYPE string OPTIONAL
        p_004_d  TYPE string OPTIONAL
        p_005_a  TYPE string OPTIONAL
        p_005_b  TYPE string OPTIONAL
        p_005_c  TYPE string OPTIONAL
        p_005_d  TYPE string OPTIONAL
      .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcx_demo_abap_error_a IMPLEMENTATION.


  METHOD constructor ##ADT_SUPPRESS_GENERATION.

    super->constructor( previous = previous ).

    me->p_003_a = p_003_a.
    me->p_003_b = p_003_b.
    me->p_004_a = p_004_a.
    me->p_004_b = p_004_b.
    me->p_004_c = p_004_c.
    me->p_004_d = p_004_d.
    me->p_005_a = p_005_a.
    me->p_005_b = p_005_b.
    me->p_005_c = p_005_c.
    me->p_005_d = p_005_d.

    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS.""",
    r"""CLASS zcx_demo_abap_error_b DEFINITION
  PUBLIC
  INHERITING FROM cx_static_check
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.

    INTERFACES if_t100_message.
    INTERFACES if_t100_dyn_msg.

    METHODS constructor
      IMPORTING
        textid   LIKE if_t100_message=>t100key OPTIONAL
        previous LIKE previous OPTIONAL.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.""",
    r"""CLASS zcx_demo_abap_error_b IMPLEMENTATION.
  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    super->constructor( previous = previous ).

    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS.""",
    r"""INTERFACE zdemo_abap_get_data_itf
  PUBLIC.

  TYPES: carr_tab TYPE TABLE OF zdemo_abap_fli WITH EMPTY KEY,
         occ_rate TYPE p LENGTH 4 DECIMALS 2.

  METHODS: select_flight_data IMPORTING carrier            TYPE zdemo_abap_fli-carrid
                              RETURNING VALUE(flight_data) TYPE carr_tab,
           say_hello RETURNING VALUE(hi) TYPE string.

ENDINTERFACE.""",
    r"""INTERFACE zdemo_abap_objects_interface
  PUBLIC.

  METHODS: double IMPORTING i_op            TYPE i
                  RETURNING VALUE(r_double) TYPE i,

    triple DEFAULT IGNORE IMPORTING i_op            TYPE i
                          RETURNING VALUE(r_triple) TYPE i .

  DATA in_str TYPE string.

  CLASS-METHODS: halve IMPORTING i_op           TYPE i
                       RETURNING VALUE(r_halve) TYPE i.

  CLASS-DATA: stat_str TYPE string.

  CONSTANTS const_intf TYPE i VALUE 987.

  TYPES c3 TYPE c LENGTH 3.
  DATA add_result TYPE i.
  CLASS-DATA: subtr_result TYPE i.
  METHODS addition IMPORTING num1 TYPE i
                             num2 TYPE i.
  CLASS-METHODS subtraction IMPORTING num1 TYPE i
                                      num2 TYPE i.

  METHODS meth_ignore DEFAULT IGNORE RETURNING VALUE(int) TYPE i.
  METHODS meth_fail DEFAULT FAIL RETURNING VALUE(int) TYPE i.

ENDINTERFACE."""
]

id_counter = 1
dataset = []
for code in safe_templates:
    dataset.append({
        "id": f"ABAP-cheat-sheet-{id_counter}",
        "cwe": "safe",
        "label": "safe",
        "code": code
    })
    id_counter += 1

with open("./abap_dataset.jsonl", "w", encoding="utf-8") as f:
    for item in dataset:
        f.write(json.dumps(item, ensure_ascii=False) + "\n")
